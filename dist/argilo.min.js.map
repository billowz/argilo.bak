{"version":3,"file":"argilo.min.js","sources":["../src/utility/consts.ts","../src/utility/is.ts","../src/utility/fn.ts","../src/utility/reg.ts","../src/utility/proto.ts","../src/utility/prop.ts","../src/utility/create.ts","../src/utility/collection/control.ts","../src/utility/collection/each.ts","../src/utility/collection/map.ts","../src/utility/collection/idxOf.ts","../src/utility/collection/reduce.ts","../src/utility/collection/obj2arr.ts","../src/utility/collection/arr2obj.ts","../src/utility/collection/index.ts","../src/utility/propPath.ts","../src/utility/string.ts","../src/utility/format.ts","../src/utility/assign.ts","../src/utility/assert.ts","../src/utility/List/List.ts","../src/utility/List/FnList.ts","../src/utility/nextTick.ts","../src/utility/AST/util.ts","../src/utility/AST/Rule.ts","../src/utility/AST/MatchRule.ts","../src/utility/AST/CharMatchRule.ts","../src/utility/AST/RegMatchRule.ts","../src/utility/AST/StringMatchRule.ts","../src/utility/AST/ComplexRule.ts","../src/utility/AST/AndRule.ts","../src/utility/AST/OrRule.ts","../src/utility/AST/index.ts"],"sourcesContent":["/**\n *\n * @author Tao Zeng (tao.zeng.zt@qq.com)\n * @module utility\n * @created 2018-11-09 15:23:35\n * @modified 2018-11-09 15:23:35 by Tao Zeng (tao.zeng.zt@qq.com)\n */\n\nexport const CONSTRUCTOR = 'constructor'\n\nexport const PROTOTYPE = 'prototype'\n\nexport const PROTO = '__proto__'\n\nexport const TYPE_BOOL = 'boolean'\n\nexport const TYPE_FN = 'function'\n\nexport const TYPE_NUM = 'number'\n\nexport const TYPE_STRING = 'string'\n\nexport const TYPE_UNDEF = 'undefined'\n\nexport const GLOBAL: any =\n\ttypeof window !== TYPE_UNDEF\n\t\t? window\n\t\t: typeof global !== TYPE_UNDEF\n\t\t? global\n\t\t: typeof self !== TYPE_UNDEF\n\t\t? self\n\t\t: {}\n\nexport interface ObjArray {\n\tlength: number;\n}\nexport  type IArray = any[] |string | IArguments | ObjArray\n","/**\n * type checker\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Sat Dec 15 2018 18:43:45 GMT+0800 (China Standard Time)\n */\n\nimport { CONSTRUCTOR, GLOBAL, TYPE_BOOL, TYPE_FN, TYPE_NUM, TYPE_STRING, TYPE_UNDEF } from './consts'\n\n/**\n * is equals\n * > o1 === o2 || NaN === NaN\n */\nexport function eq(o1: any, o2: any): boolean {\n\treturn o1 === o2 || (o1 !== o1 && o2 !== o2)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    primitive type                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * is null\n */\nexport function isNull(o: any): boolean {\n\treturn o === null\n}\n\n/**\n * is undefined\n */\nexport function isUndef(o: any): boolean {\n\treturn o === undefined\n}\n\n/**\n * is null or undefined\n */\nexport function isNil(o: any): boolean {\n\treturn o === null || o === undefined\n}\n\n/**\n * is boolean\n */\nexport const isBool: (o: any) => boolean = mkIsPrimitive(TYPE_BOOL)\n\n/**\n * is a number\n */\nexport const isNum: (o: any) => boolean = mkIsPrimitive(TYPE_NUM)\n\n/**\n * is a string\n */\nexport const isStr: (o: any) => boolean = mkIsPrimitive(TYPE_STRING)\n\n/**\n * is a function\n */\nexport const isFn: (o: any) => boolean = mkIsPrimitive(TYPE_FN)\n\n/**\n * is integer number\n */\nexport function isInt(o: any): boolean {\n\treturn o === 0 || (o ? typeof o === TYPE_NUM && o % 1 === 0 : false)\n}\n\n/**\n * is primitive type\n * - null\n * - undefined\n * - boolean\n * - number\n * - string\n * - function\n */\nexport function isPrimitive(o: any): boolean {\n\tif (o === undefined || o === null) {\n\t\treturn true\n\t}\n\tswitch (typeof o) {\n\t\tcase TYPE_BOOL:\n\t\tcase TYPE_NUM:\n\t\tcase TYPE_STRING:\n\t\tcase TYPE_FN:\n\t\t\treturn true\n\t}\n\treturn false\n}\n\nfunction mkIsPrimitive(type: string): (o: any) => boolean {\n\treturn function is(o: any): boolean {\n\t\treturn typeof o === type\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    reference type                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * is instanceof\n */\nexport function instOf(obj: any, Cls: Function): boolean {\n\treturn obj !== undefined && obj !== null && obj instanceof Cls\n}\n\n/**\n * is child instance of Type\n */\nexport function is(o: any, Type: Function | Function[]): boolean {\n\tif (o !== undefined && o !== null) {\n\t\tconst C = o[CONSTRUCTOR] || Object\n\t\tif (Type[CONSTRUCTOR] === Array) {\n\t\t\tvar i = Type.length\n\t\t\twhile (i--) {\n\t\t\t\tif (C === (Type as Function[])[i]) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn C === Type\n\t\t}\n\t}\n\treturn false\n}\n\n/**\n * is boolean or Boolean\n */\nexport const isBoolean: (o: any) => boolean = mkIs(Boolean)\n\n/**\n * is number or Number\n */\nexport const isNumber: (o: any) => boolean = mkIs(Number)\n\n/**\n * is string or String\n */\nexport const isString: (o: any) => boolean = mkIs(String)\n\n/**\n * is Date\n */\nexport const isDate: (o: any) => boolean = mkIs(Date)\n\n/**\n * is RegExp\n */\nexport const isReg: (o: any) => boolean = mkIs(RegExp)\n\n/**\n * is Array\n */\nexport const isArray: (o: any) => boolean = Array.isArray || mkIs(Array)\n\n/**\n * is Typed Array\n */\nexport const isTypedArray: (o: any) => boolean = isFn(ArrayBuffer) ? ArrayBuffer.isView : () => false\n\n/**\n * is Array or pseudo-array\n * - Array\n * - String\n * - IArguments\n * - NodeList\n * - HTMLCollection\n * - Typed Array\n * - {length: int, [length-1]: any}\n */\nexport function isArrayLike(o: any): boolean {\n\tif (o) {\n\t\tswitch (o[CONSTRUCTOR]) {\n\t\t\tcase Array:\n\t\t\tcase String:\n\t\t\tcase GLOBAL.NodeList:\n\t\t\tcase GLOBAL.HTMLCollection:\n\t\t\tcase GLOBAL.Int8Array:\n\t\t\tcase GLOBAL.Uint8Array:\n\t\t\tcase GLOBAL.Int16Array:\n\t\t\tcase GLOBAL.Uint16Array:\n\t\t\tcase GLOBAL.Int32Array:\n\t\t\tcase GLOBAL.Uint32Array:\n\t\t\tcase GLOBAL.Float32Array:\n\t\t\tcase GLOBAL.Float64Array:\n\t\t\t\treturn true\n\t\t}\n\t\tconst len = o.length\n\t\treturn typeof len === TYPE_NUM && (len === 0 || (len > 0 && len % 1 === 0 && len - 1 in o))\n\t}\n\treturn o === ''\n}\n\n/**\n * is simple Object\n * TODO object may has constructor property\n */\nexport function isObj(o: any): boolean {\n\tif (o === undefined || o === null) {\n\t\treturn false\n\t}\n\tconst C = o[CONSTRUCTOR]\n\treturn C === undefined || C === Object\n}\n\nfunction mkIs(Type: Function): (o: any) => boolean {\n\treturn function is(o: any): boolean {\n\t\treturn o !== undefined && o !== null && o[CONSTRUCTOR] === Type\n\t}\n}\n\nconst blankStrReg = /^\\s*$/\n/**\n * is empty\n * - string: trim(string).length === 0\n * - array: array.length === 0\n * - pseudo-array: pseudo-array.length === 0\n */\nexport function isBlank(o: any): boolean {\n\tif (o) {\n\t\tif (o[CONSTRUCTOR] === String) {\n\t\t\treturn blankStrReg.test(o)\n\t\t}\n\t\treturn o.length === 0\n\t}\n\treturn true\n}\n","/**\n * Function utilities\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Fri Nov 23 2018 11:18:33 GMT+0800 (China Standard Time)\n */\n\nimport { GLOBAL, PROTOTYPE } from './consts'\nimport { isNil } from './is'\n\n// ========================================================================================\n/*                                                                                      *\n *                                    create function                                   *\n *                                                                                      */\n// ========================================================================================\n\n/**\n * create function by code string\n * @param body\tfunction body\n * @param args\tfunction argument names\n * @param name\tfunction name\n */\nexport function createFn<T extends Function>(body: string, args?: string[], name?: string): T {\n\treturn name\n\t\t? Function(`return function ${name}(${args ? args.join(', ') : ''}){${body}}`)()\n\t\t: applyScope(Function, Function, args && args.length ? args.concat(body) : [body])\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                    function apply                                    *\n *                                                                                      */\n// ========================================================================================\n\n/**\n * generate apply function\n */\nfunction applyBuilder<T extends Function>(maxArgs: number, scope: any, offset: any): T {\n\tscope = scope ? 'scope' : ''\n\toffset = offset ? 'offset' : ''\n\tconst args = new Array(maxArgs + 1)\n\tconst cases = new Array(maxArgs + 1)\n\tfor (let i = 0; i <= maxArgs; i++) {\n\t\targs[i] = `${i || scope ? ', ' : ''}args[${offset ? `offset${i ? ' + ' + i : ''}` : i}]`\n\t\tcases[i] = `case ${i}: return fn${scope && '.call'}(${scope}${args.slice(0, i).join('')});`\n\t}\n\treturn Function(`return function(fn, ${scope && scope + ', '}args${offset && ', offset, len'}){\nswitch(${offset ? 'len' : 'args.length'}){\n${cases.join('\\n')}\n}\n${offset &&\n\t\t`var arr = new Array(len);\nfor(var i=0; i<len; i++) arr[i] = arr[offset + i];`}\nreturn fn.apply(${scope || 'null'}, ${offset ? 'arr' : 'args'});\n}`)()\n}\n\n/**\n * apply function with scope\n * @param fn\ttarget function\n * @param scope\tscope of function\n * @param args\targuments of function\n */\nexport const applyScope: (fn: Function, scope: any, args: any[] | IArguments) => any = applyBuilder(8, 1, 0)\n\n/**\n * apply function without scope\n * @param fn\t\ttarget function\n * @param args\targuments of function\n */\nexport const applyNoScope: (fn: Function, args: any[] | IArguments) => any = applyBuilder(8, 0, 0)\n\n/**\n * apply function with scope\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport const applyScopeN: (\n\tfn: Function,\n\tscope: any,\n\targs: any[] | IArguments,\n\toffset: number,\n\tlen: number\n) => any = applyBuilder(8, 1, 1)\n\n/**\n * apply function without scope\n * @param fn\t\ttarget function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport const applyNoScopeN: (fn: Function, args: any[] | IArguments, offset: number, len: number) => any = applyBuilder(\n\t8,\n\t0,\n\t1\n)\n\n/**\n * apply function\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n */\nexport function apply(fn: Function, scope: any, args: any[] | IArguments): any {\n\tif (scope === undefined || scope === null || scope === GLOBAL) {\n\t\treturn applyNoScope(fn, args || [])\n\t}\n\treturn applyScope(fn, scope, args || [])\n}\n\n/**\n * apply function\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport function applyN(fn: Function, scope: any, args: any[] | IArguments, offset: number, len: number): any {\n\tif (scope === undefined || scope === null || scope === GLOBAL) {\n\t\treturn applyNoScopeN(fn, args, offset, len)\n\t}\n\treturn applyScopeN(fn, scope, args, offset, len)\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                     function name                                    *\n *                                                                                      */\n// ========================================================================================\n\nconst varGenReg = /\\$\\d+$/\n\n/**\n * get function name\n */\nexport function fnName(fn: Function): string {\n\tconst name: string = (fn as any).name\n\treturn name ? name.replace(varGenReg, '') : 'anonymous'\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                         bind                                         *\n *                                                                                      */\n// ========================================================================================\n\nlet _bind\nconst funcProto = Function[PROTOTYPE]\nif (funcProto.bind) {\n\t_bind = function bind<T extends Function>(fn: T, scope: any): T {\n\t\tconst args = arguments,\n\t\t\targLen = args.length\n\t\tif (isNil(scope)) {\n\t\t\treturn argLen > 2 ? bindPolyfill(fn, scope, args, 2) : fn\n\t\t}\n\t\treturn applyScopeN(fn.bind, fn, args, 1, argLen - 1)\n\t}\n} else {\n\tfuncProto.bind = function bind(scope) {\n\t\treturn bindPolyfill(this, scope, arguments, 1)\n\t}\n\t_bind = function bind<T extends Function>(fn: T, scope: any): T {\n\t\treturn bindPolyfill(fn, scope, arguments, 2)\n\t}\n}\n\n/**\n * bind scope or arguments on function\n * - return source function when without arguments and scope is undefined or null\n * - only bind arguments when scope is undefined or null, well can call the new function proxy with some scope\n *\n * @example\n * \t\tfunction example() {\n * \t\t\tconsole.log(this, arguments);\n * \t\t}\n * \t\tvar proxy = bind(example, null) \t// proxy === example\n * \t\tproxy() \t\t\t\t\t\t\t// log: window | undefined, []\n * \t\tproxy.call(1) \t\t\t\t\t\t// log: 1, []\n *\n * \t\tproxy = bind(example, null, 1) \t\t// proxy !== example\n * \t\tproxy() \t\t\t\t\t\t\t// log: window | undefined, [1]\n * \t\tproxy(2) \t\t\t\t\t\t\t// log: window | undefined, [1, 2]\n * \t\tproxy.call(1, 2) \t\t\t\t\t// log: 1, [1, 2]\n *\n * \t\tproxy = bind(example, {}, 1, 2)\t\t// proxy !== example\n * \t\tproxy() \t\t\t\t\t\t\t// log: {}, [1]\n * \t\tproxy(2) \t\t\t\t\t\t\t// log: {}, [1, 2, 2]\n * \t\tproxy.call(1, 2) \t\t\t\t\t// log: {}, [1, 2, 2]\n *\n * @param fn\tsource function\n * @param scope\tbind scope\n * @param args\tbind arguments\n * @return function proxy\n */\nexport const bind: <T extends Function>(fn: T, scope: any, ...args: any[]) => T = _bind\n\n/**\n * bind\n * > not bind scope when scope is null or undefined\n * @param fn\t\tsource function\n * @param scope\t\tbind scope\n * @param args\t\tbind arguments\n * @param argOffset\toffset of args\n * @return function proxy\n */\nfunction bindPolyfill<T extends Function>(fn: T, scope: any, bindArgs: any[] | IArguments, argOffset: number): T {\n\tconst argLen = bindArgs.length - argOffset\n\tif (scope === undefined) {\n\t\tscope = null\n\t}\n\tif (argLen > 0) {\n\t\t// bind with arguments\n\t\treturn function bindProxy() {\n\t\t\tconst args = arguments\n\t\t\tlet i = args.length\n\t\t\tif (i) {\n\t\t\t\tconst params = new Array(argLen + i)\n\t\t\t\twhile (i--) {\n\t\t\t\t\tparams[argLen + i] = args[i]\n\t\t\t\t}\n\t\t\t\ti = argLen\n\t\t\t\twhile (i--) {\n\t\t\t\t\tparams[i] = bindArgs[i + argOffset]\n\t\t\t\t}\n\t\t\t\treturn apply(fn, scope === null ? this : scope, params) // call with scope or this\n\t\t\t}\n\t\t\treturn applyN(fn, scope === null ? this : scope, bindArgs, argOffset, argLen) // call with scope or this\n\t\t} as any\n\t}\n\tif (scope === null) {\n\t\treturn fn\n\t}\n\tif (scope === GLOBAL) {\n\t\t// bind on GLOBAL\n\t\treturn function bindProxy() {\n\t\t\treturn applyNoScope(fn, arguments)\n\t\t} as any\n\t}\n\treturn function bindProxy() {\n\t\treturn applyScope(fn, scope, arguments)\n\t} as any\n}\n","/**\n * regexp utilities\n * @module utility/reg\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Sep 06 2018 18:27:51 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 20:00:44 GMT+0800 (China Standard Time)\n */\n\nimport { isBool } from './is'\n\n/**\n * is support sticky on RegExp\n */\nexport const regStickySupport = isBool(/(?:)/.sticky)\n\n/**\n * is support unicode on RegExp\n */\nexport const regUnicodeSupport = isBool(/(?:)/.unicode)\n\nconst REG_ESCAPE = /[-\\/\\\\^$*+?.()|[\\]{}]/g\n\n/**\n * escape string for RegExp\n */\nexport function reEscape(str: string): string {\n\treturn str.replace(REG_ESCAPE, '\\\\$&')\n}\n","/**\n * prototype utilities\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:23:56 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 20:00:18 GMT+0800 (China Standard Time)\n */\nimport { CONSTRUCTOR, PROTO, PROTOTYPE } from './consts'\n\nconst __hasOwn = Object[PROTOTYPE].hasOwnProperty\nconst __getProto = Object.getPrototypeOf,\n\t____setProto = Object.setPrototypeOf\n\n/**\n * is support Object.getPrototypeOf and Object.setPrototypeOf\n */\nexport const prototypeOfSupport = !!____setProto\n\nexport const protoPropSupport = { __proto__: [] } instanceof Array\n\n/**\n * Object.getPrototypeOf shim\n */\nexport const protoOf: (o: any) => any = ____setProto\n\t? __getProto\n\t: __getProto\n\t? function getPrototypeOf(obj) {\n\t\t\treturn obj[PROTO] || __getProto(obj)\n\t  }\n\t: function getPrototypeOf(obj) {\n\t\t\treturn (__hasOwn.call(obj, PROTO) ? obj[PROTO] : obj[CONSTRUCTOR][PROTOTYPE]) || null\n\t  }\n\nexport const __setProto: <T>(obj: any, proto: any) => any =\n\t____setProto ||\n\tfunction setPrototypeOf(obj, proto) {\n\t\tobj[PROTO] = proto\n\t\treturn obj\n\t}\n\n/**\n * Object.setPrototypeOf shim\n */\nexport const setProto: <T>(obj: any, proto: any) => any =\n\t____setProto ||\n\t(protoPropSupport\n\t\t? __setProto\n\t\t: function setPrototypeOf(obj, proto) {\n\t\t\t\tfor (let p in proto) {\n\t\t\t\t\tif (__hasOwn.call(proto, p)) {\n\t\t\t\t\t\tobj[p] = proto[p]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn __setProto(obj, proto)\n\t\t  })\n","/**\n * prop utilities\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:22:57 GMT+0800 (China Standard Time)\n * @modified Mon Dec 10 2018 12:44:40 GMT+0800 (China Standard Time)\n */\nimport { PROTO, PROTOTYPE } from './consts'\nimport { protoPropSupport } from './proto'\n\nconst __hasOwn = Object[PROTOTYPE].hasOwnProperty\n\n/**\n * has own property\n */\nexport const hasOwnProp: (obj: any, prop: string) => boolean = protoPropSupport\n\t? function hasOwnProp(obj: any, prop: string): boolean {\n\t\t\treturn __hasOwn.call(obj, prop)\n\t  }\n\t: function hasOwnProp(obj: any, prop: string): boolean {\n\t\t\treturn prop !== PROTO && __hasOwn.call(obj, prop)\n\t  }\n\n/**\n * get owner property value\n * @param prop \t\t\tproperty name\n * @param defaultVal \tdefault value\n */\nexport function getOwnProp(obj: any, prop: string, defaultVal?: any): any {\n\treturn hasOwnProp(obj, prop) ? obj[prop] : defaultVal\n}\n\nlet __defProp = Object.defineProperty\n/**\n * is support Object.defineProperty\n */\nexport const defPropSupport: boolean =\n\t__defProp &&\n\t(function() {\n\t\ttry {\n\t\t\tvar val,\n\t\t\t\tobj: any = {}\n\t\t\t__defProp(obj, 's', {\n\t\t\t\tget() {\n\t\t\t\t\treturn val\n\t\t\t\t},\n\t\t\t\tset(value) {\n\t\t\t\t\tval = value\n\t\t\t\t}\n\t\t\t})\n\t\t\tobj.s = 1\n\t\t\treturn obj.s === val\n\t\t} catch (e) {}\n\t})()\n\nif (!defPropSupport) {\n\t__defProp = function defineProperty(\n\t\tobj: any,\n\t\tprop: string | number | symbol,\n\t\tdesc: PropertyDescriptor & ThisType<any>\n\t): any {\n\t\tif (desc.get || desc.set) {\n\t\t\tthrow new Error('not support getter/setter on defineProperty')\n\t\t}\n\t\tobj[prop] = desc.value\n\t\treturn obj\n\t}\n}\n\n/**\n * define property\n */\nexport const defProp = __defProp\n\n/**\n * define property by value\n */\nexport const defPropValue: <V>(\n\tobj: any,\n\tprop: string,\n\tvalue: V,\n\tenumerable?: boolean,\n\tconfigurable?: boolean,\n\twritable?: boolean\n) => V = defPropSupport\n\t? function defPropValue(obj, prop, value, configurable, writable, enumerable) {\n\t\t\t__defProp(obj, prop, {\n\t\t\t\tvalue,\n\t\t\t\tenumerable: enumerable !== false,\n\t\t\t\tconfigurable: configurable !== false,\n\t\t\t\twritable: writable !== false\n\t\t\t})\n\t\t\treturn value\n\t  }\n\t: function defPropValue(obj, prop, value) {\n\t\t\tobj[prop] = value\n\t\t\treturn value\n\t  }\n","/**\n * Object.create shim\n * @module utility/create\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:24:47 GMT+0800 (China Standard Time)\n * @modified Mon Dec 10 2018 11:45:30 GMT+0800 (China Standard Time)\n */\n\nimport { CONSTRUCTOR, PROTOTYPE } from './consts'\nimport { defProp, hasOwnProp } from './prop'\nimport { __setProto } from './proto'\n\nfunction __() {}\n\n/**\n * create shim\n */\nfunction doCreate(o: object | null, props?: PropertyDescriptorMap & ThisType<any>): object {\n\t__[PROTOTYPE] = o\n\tconst obj = new __()\n\t__[PROTOTYPE] = null\n\tif (props) {\n\t\tvar k, v\n\t\tfor (k in props) {\n\t\t\tif (hasOwnProp(props, k)) {\n\t\t\t\tdefProp(obj, k, props[k])\n\t\t\t}\n\t\t}\n\t}\n\treturn obj\n}\n\n/**\n * create object\n */\nexport const create = Object.create ||\n\t(Object.getPrototypeOf\n\t\t? doCreate\n\t\t: function create(o: object | null, props?: PropertyDescriptorMap & ThisType<any>): object {\n\t\t\t\tconst obj = doCreate(o, props)\n\t\t\t\t__setProto(obj, o)\n\t\t\t\treturn obj\n\t\t  })\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:10:41 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 14:17:32 GMT+0800 (China Standard Time)\n */\nexport class Control {\n\tprivate desc: string\n\tconstructor(desc: string) {\n\t\tthis.desc = desc\n\t}\n\ttoString() {\n\t\treturn this.desc\n\t}\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:10:41 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:39:11 GMT+0800 (China Standard Time)\n */\nimport { Control } from './control'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { hasOwnProp } from '../prop'\nimport { isArrayLike, isBool } from '../is'\n\n/**\n * STOP Control\n * > stop each/map/indexOf...\n */\nexport const STOP = new Control('STOP')\n//========================================================================================\n/*                                                                                      *\n *                                each object properties                                *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on object\n * - will stop each on return STOP\n */\nexport type EachPropCallback = (prop: string, obj: object) => Control | void\n\n/**\n * each properties\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties, default: true\n * @return stoped property name or false\n */\nexport function eachProps(obj: object, callback: EachPropCallback, own: boolean): false | string\nexport function eachProps(obj: object, callback: EachPropCallback, scope?: any, own?: boolean): false | string\nexport function eachProps(obj: object, callback: EachPropCallback, scope?: any, own?: boolean): false | string {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tlet k: string\n\tif (own === false) {\n\t\tfor (k in obj) if (callback(k, obj) === STOP) return k\n\t} else {\n\t\tfor (k in obj) if (hasOwnProp(obj, k) && callback(k, obj) === STOP) return k\n\t}\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      each object                                     *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on object\n * - will stop each on callback return STOP\n */\nexport type EachObjCallback = (value: any, prop: string, obj: object) => Control | void\n\n/**\n * each object\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties, default: true\n * @return stoped property name or false\n */\nexport function eachObj(obj: object, callback: EachObjCallback, own: boolean): false | string\nexport function eachObj(obj: object, callback: EachObjCallback, scope?: any, own?: boolean): false | string\nexport function eachObj(obj: object, callback: EachObjCallback, scope?: any, own?: boolean): false | string {\n\tconst args = arguments\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tlet k: string\n\tif (own === false) {\n\t\tfor (k in obj) if (callback(obj[k], k, obj) === STOP) return k\n\t} else {\n\t\tfor (k in obj) if (hasOwnProp(obj, k) && callback(obj[k], k, obj) === STOP) return k\n\t}\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      each array                                      *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on array\n * - will stop each on callback return STOP\n */\nexport type EachArrayCallback = (data: any, index: number, array: IArray) => Control | void\n\n/**\n * each array\n * - will stop each on callback return STOP\n * @param array\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @return stoped index or false\n */\nexport function eachArray(array: IArray, callback: EachArrayCallback, scope?: any): false | number {\n\tcallback = bind(callback, scope)\n\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\tif (callback(array[i], i, array) === STOP) return i\n\t}\n\treturn false\n}\n\n/**\n * reverse each array\n * - will stop each on callback return STOP\n * @param array\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @return stoped index or false\n */\nexport function reachArray(array: IArray, callback: EachArrayCallback, scope?: any): false | number {\n\tcallback = bind(callback, scope)\n\tlet i = array.length\n\twhile (i--) if (callback(array[i], i, array) === STOP) return i\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         each                                         *\n *                                                                                      */\n//========================================================================================\n\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: IArray,\n\tcallback: EachArrayCallback,\n\tscope?: any\n): false | number\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object,\n\tcallback: EachObjCallback,\n\town?: boolean\n): false | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object,\n\tcallback: EachObjCallback,\n\tscope?: any,\n\town?: boolean\n): false | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\town?: boolean\n): false | number | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\tscope?: any,\n\town?: boolean\n): false | number | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: any,\n\tcallback: any,\n\tscope?: any,\n\town?: boolean\n): false | number | string {\n\tif (isArrayLike(obj)) return _eachArray(obj, callback, scope)\n\treturn _eachObj(obj, callback, scope, own)\n}\n\n/**\n * each\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties on object, default: true\n * @return stoped index or false\n */\n\nexport function each(obj: IArray, callback: EachArrayCallback, scope?: any): false | number\nexport function each(obj: object, callback: EachObjCallback, own?: boolean): false | string\nexport function each(obj: object, callback: EachObjCallback, scope?: any, own?: boolean): false | string\nexport function each(\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\town?: boolean\n): false | number | string\nexport function each(\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\tscope?: any,\n\town?: boolean\n): false | number | string\nexport function each(obj: any, callback: any, scope?: any, own?: boolean): false | number | string {\n\treturn doEach(eachArray, eachObj, obj, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:54:35 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport {create} from '../create'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool } from '../is'\n\n/**\n * SKIP Control\n * > skip map\n */\nexport const SKIP = new Control('SKIP')\n\n//========================================================================================\n/*                                                                                      *\n *                                    map object                                   *\n *                                                                                      */\n//========================================================================================\n\n/**\n * callback on object\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param value\tproperty value\n * @param prop\tproperty name\n * @param obj\tmap target\n */\nexport type MapObjCallback<T> = (callback: any, prop: string, obj: object) => T | Control\n\nexport function doMapObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\town?: boolean\n): { [key: string]: T }\nexport function doMapObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T }\nexport function doMapObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tconst copy: { [key: string]: T } = create(null)\n\teach(\n\t\tobj,\n\t\t(value, prop, obj) => {\n\t\t\tconst v = callback(value, prop, obj)\n\t\t\tif (v === STOP) return STOP\n\t\t\tif (v !== SKIP) copy[prop] = v as T\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn copy\n}\n\n/**\n * object: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param obj\t\tmap target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\tmap own properties, default: true\n */\nexport function mapObj<T>(obj: object, callback: MapObjCallback<T>, own?: boolean): { [key: string]: T }\nexport function mapObj<T>(obj: object, callback: MapObjCallback<T>, scope?: any, own?: boolean): { [key: string]: T }\nexport function mapObj<T>(obj: object, callback: MapObjCallback<T>, scope?: any, own?: boolean): { [key: string]: T } {\n\treturn doMapObj(eachObj, obj, callback, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     indexof Array                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * callback on array\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param data\titem data\n * @param index\titem index\n * @param array\tmap target\n */\nexport type MapArrayCallback<T> = (data: any, index: number, array: IArray) => T | Control\n\nexport function doMapArray<T>(each: typeof eachArray, array: IArray, callback: MapArrayCallback<T>, scope?: any): T[] {\n\tcallback = bind(callback, scope)\n\tconst copy: T[] = []\n\tlet j = 0\n\teach(array, (data, index, array) => {\n\t\tconst v = callback(data, index, array)\n\t\tif (v === STOP) return STOP\n\t\tif (v !== SKIP) copy[j++] = v as T\n\t})\n\treturn copy\n}\n\n/**\n * array: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param array\t\tmap target\n * @param value\t\tcallback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function mapArray<T>(array: IArray, callback: MapArrayCallback<T>, scope?: any): T[] {\n\treturn doMapArray(eachArray, array, callback, scope)\n}\n\n/**\n * revice array: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param array\t\tmap target\n * @param value\t\tmap value of callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function rmapArray<T>(array: IArray, callback: MapArrayCallback<T>, scope?: any): T[] {\n\treturn doMapArray(reachArray, array, callback, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       map                                       *\n *                                                                                      */\n//========================================================================================\n\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray,\n\tcallback: MapArrayCallback<T>,\n\tscope?: any\n): any[]\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\town?: boolean\n): { [key: string]: T }\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T }\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: any,\n\tcallback: any,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | any[] {\n\tif (isArrayLike(obj)) return doMapArray(eacharray, obj, callback, scope)\n\treturn doMapObj(eachobj, obj, callback, scope, own)\n}\n\n/**\n * map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param obj\t\tmap target\n * @param value\t\tmap value of callback\n * @param scope\t\tscope of callback\n * @param own\t\tmap own properties on object, default: true\n * @return array index or property name or -1\n */\nexport function map<T>(obj: IArray, callback: MapArrayCallback<T>, scope?: any): any[]\nexport function map<T>(obj: object, callback: MapObjCallback<T>, own?: boolean): { [key: string]: T }\nexport function map<T>(obj: object, callback: MapObjCallback<T>, scope?: any, own?: boolean): { [key: string]: T }\nexport function map<T>(\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function map<T>(\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function map<T>(obj: object | IArray, callback: any, scope?: any, own?: boolean): { [key: string]: T } | T[] {\n\treturn doMap(eachArray, eachObj, obj, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:38:16 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool, isFn, eq } from '../is'\n\nfunction parseCallback(value: any, scope: any) {\n\tif (isFn(value)) return bind(value, scope)\n\treturn function defaultHandler(data, idx, obj) {\n\t\treturn eq(data, value)\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    index of object                                   *\n *                                                                                      */\n//========================================================================================\n\n/**\n * indexOf callback on object\n * - will stop find on callback return STOP\n * @param value\tproperty value\n * @param prop\tproperty name\n * @param obj\t\tindexOf target\n * @return\n * - boolean: is finded\n * - void: find next\n * - STOP: stop find\n */\nexport type IdxOfObjCallback = (value: any, prop: string, obj: object) => boolean | Control | void\n\nexport function doIdxOfObj(each: typeof eachObj, obj: object, value: any, own?: boolean): -1 | string\nexport function doIdxOfObj(each: typeof eachObj, obj: object, value: IdxOfObjCallback, own?: boolean): -1 | string\nexport function doIdxOfObj(\n\teach: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback,\n\tscope?: any,\n\town?: boolean\n): -1 | string\n\nexport function doIdxOfObj(\n\teach: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback | any,\n\tscope?: any,\n\town?: boolean\n): -1 | string {\n\tif (isBool(scope)) {\n\t\town = scope\n\t\tscope = null\n\t}\n\tconst callback: IdxOfObjCallback = parseCallback(value, scope)\n\tlet idx: -1 | string = -1\n\teach(\n\t\tobj,\n\t\t(data, prop, obj) => {\n\t\t\tconst r = callback(data, prop, obj)\n\t\t\tif (r === true) {\n\t\t\t\tidx = prop\n\t\t\t\treturn STOP\n\t\t\t} else if (r === STOP) return r\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn idx\n}\n\n/**\n * object: indexOf\n * - will stop find on callback return STOP\n * @param obj\t\tfind target\n * @param callback\tfind value or callback\n * @param scope\t\tscope of callback\n * @param own\t\tfind own properties, default: true\n * @return property name or -1\n */\nexport function idxOfObj(obj: object, value: any, own?: boolean): -1 | string\nexport function idxOfObj(obj: object, value: IdxOfObjCallback, own?: boolean): -1 | string\nexport function idxOfObj(obj: object, value: IdxOfObjCallback, scope?: any, own?: boolean): -1 | string\nexport function idxOfObj(obj: object, value: IdxOfObjCallback | any, scope?: any, own?: boolean): -1 | string {\n\treturn doIdxOfObj(eachObj, obj, value, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     indexof Array                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * indexOf callback on array\n * - will stop find on callback return STOP\n * @param data\titem data\n * @param index\titem index\n * @param array\tindexOf target\n * @return\n * - boolean: is finded\n * - void: find next\n * - STOP: stop find\n */\nexport type IdxOfArrayCallback = (data: any, index: number, array: IArray) => boolean | Control | void\n\nexport function doIdxOfArray(each: typeof eachArray, array: IArray, value: any): number\nexport function doIdxOfArray(each: typeof eachArray, array: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function doIdxOfArray(\n\teach: typeof eachArray,\n\tarray: IArray,\n\tvalue: IdxOfArrayCallback | any,\n\tscope?: any\n): number {\n\tconst callback: IdxOfArrayCallback = parseCallback(value, scope)\n\tlet idx = -1\n\teach(array, (data, index, array) => {\n\t\tconst r = callback(data, index, array)\n\t\tif (r === true) {\n\t\t\tidx = index\n\t\t\treturn STOP\n\t\t} else if (r === STOP) return r\n\t})\n\treturn idx\n}\n\n/**\n * array: indexOf\n * - will stop find on callback return STOP\n * @param array\t\tfind target\n * @param value\t\tfind value or callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function idxOfArray(array: IArray, value: any): number\nexport function idxOfArray(array: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function idxOfArray(array: IArray, value: IdxOfArrayCallback | any, scope?: any): number {\n\treturn doIdxOfArray(eachArray, array, value, scope)\n}\n\n/**\n * revice array: indexOf\n * - will stop find on callback return STOP\n * @param array\t\tfind target\n * @param value\t\tfind value of callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function ridxOfArray(array: IArray, value: any): number\nexport function ridxOfArray(array: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function ridxOfArray(array: IArray, value: IdxOfArrayCallback | any, scope?: any): number {\n\treturn doIdxOfArray(reachArray, array, value, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       index of                                       *\n *                                                                                      */\n//========================================================================================\n// find by value\nexport function doIdxOf(eacharray: typeof eachArray, eachobj: typeof eachObj, obj: IArray, value: any): number\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tvalue: any,\n\town?: boolean\n): string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tvalue: any,\n\town?: boolean\n): number | string\n// find by callback\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray,\n\tvalue: IdxOfArrayCallback,\n\tscope?: any\n): number\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback,\n\town?: boolean\n): -1 | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback,\n\tscope?: any,\n\town?: boolean\n): -1 | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\town?: boolean\n): number | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\tscope?: any,\n\town?: boolean\n): number | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: any,\n\tvalue: any,\n\tscope?: any,\n\town?: boolean\n): number | string {\n\tif (isArrayLike(obj)) return doIdxOfArray(eacharray, obj, value, scope)\n\treturn doIdxOfObj(eachobj, obj, value, scope, own)\n}\n\n/**\n * indexOf\n * - will stop find on callback return STOP\n * @param obj\t\tfind target\n * @param value\t\tfind value of callback\n * @param scope\t\tscope of callback\n * @param own\t\tfind own properties on object, default: true\n * @return array index or property name or -1\n */\nexport function idxOf(obj: IArray, value: any): number | string\nexport function idxOf(obj: object, value: any, own?: boolean): number | string\nexport function idxOf(obj: object | IArray, value: any, own?: boolean): number | string\nexport function idxOf(obj: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function idxOf(obj: object, value: IdxOfObjCallback, own?: boolean): -1 | string\nexport function idxOf(obj: object, value: IdxOfObjCallback, scope?: any, own?: boolean): -1 | string\nexport function idxOf(\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\town?: boolean\n): number | string\nexport function idxOf(\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\tscope?: any,\n\town?: boolean\n): number | string\nexport function idxOf(obj: object | IArray, value: any, scope?: any, own?: boolean): number | string {\n\treturn doIdxOf(eachArray, eachObj, obj, value, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 14:02:39 GMT+0800 (China Standard Time)\n */\nimport { Control } from './control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool } from '../is'\n\n//========================================================================================\n/*                                                                                      *\n *                                     reduce object                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * reduce callback on object\n * - will stop reduce on return STOP\n */\nexport type ReduceObjCallback<T> = (accumulator: T, value: any, prop: string, obj: object) => T | Control\n\nexport function doReduceObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\town?: boolean\n): T\nexport function doReduceObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduceObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\teach(\n\t\tobj,\n\t\t(value, prop, obj) => {\n\t\t\tconst rs = callback(accumulator, value, prop, obj)\n\t\t\tif (rs === STOP) return STOP\n\t\t\taccumulator = rs as T\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn accumulator\n}\n\n/**\n * reduce object\n * - will stop reduce on callback return STOP\n * @param obj\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n * @param own\t\t\treduce own properties, default: true\n */\nexport function reduceObj<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, own?: boolean)\nexport function reduceObj<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, scope?: any, own?: boolean)\nexport function reduceObj<T>(\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\treturn doReduceObj(eachObj, obj, accumulator, callback, scope, own)\n}\n//========================================================================================\n/*                                                                                      *\n *                                     reduce array                                     *\n *                                                                                      */\n//========================================================================================\n\n/**\n * reduce callback on array\n * - will stop reduce on return STOP\n */\nexport type ReduceArrayCallback<T> = (accumulator: T, data: any, index: number, array: IArray) => T | Control\n\nexport function doReduceArray<T>(\n\teach: typeof eachArray,\n\tarray: IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T>,\n\tscope?: any\n): T {\n\tcallback = bind(callback, scope)\n\teach(array, (data, index, array) => {\n\t\tconst rs = callback(accumulator, data, index, array)\n\t\tif (rs === STOP) return STOP\n\t\taccumulator = rs as T\n\t})\n\treturn accumulator\n}\n\n/**\n * reduce array\n * - will stop reduce on callback return STOP\n * @param array\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n */\nexport function reduceArray<T>(array: IArray, accumulator: T, callback: ReduceArrayCallback<T>, scope?: any): T {\n\treturn doReduceArray(eachArray, array, accumulator, callback, scope)\n}\n\n/**\n * revice reduce array\n * - will stop reduce on callback return STOP\n * @param array\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n */\nexport function rreduceArray<T>(array: IArray, accumulator: T, callback: ReduceArrayCallback<T>, scope?: any): T {\n\treturn doReduceArray(reachArray, array, accumulator, callback, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        reduce                                        *\n *                                                                                      */\n//========================================================================================\n\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T>,\n\tscope?: any\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T> | ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\tif (isArrayLike(obj))\n\t\treturn doReduceArray(eacharray, obj as IArray, accumulator, callback as ReduceArrayCallback<T>, scope)\n\treturn doReduceObj(eachobj, obj as object, accumulator, callback as ReduceObjCallback<T>, scope, own)\n}\n\n/**\n * reduce\n * - will stop reduce on callback return STOP\n * @param obj\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n * @param own\t\t\treduce own properties of reduce object, default: true\n */\nexport function reduce<T>(obj: IArray, accumulator: T, callback: ReduceArrayCallback<T>, scope?: any): T\nexport function reduce<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, own?: boolean): T\nexport function reduce<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, scope?: any, own?: boolean): T\nexport function reduce<T>(\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\town?: boolean\n): T\nexport function reduce<T>(\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function reduce<T>(\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T> | ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\treturn doReduce(eachArray, eachObj, obj, accumulator, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Jul 26 2018 10:47:47 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:59:31 GMT+0800 (China Standard Time)\n */\nimport { Control } from './control'\nimport { STOP, eachObj, eachProps } from './each'\nimport { SKIP } from './map'\nimport { isBool, isFn } from '../is'\nimport { bind } from '../fn'\n\n//========================================================================================\n/*                                                                                      *\n *                                         keys                                         *\n *                                                                                      */\n//========================================================================================\n\nexport type ObjKeyHandler<T> = (prop: string, obj: object) => T | Control\n\nfunction defaultObjKeyHandler(prop: string, obj: object): any {\n\treturn prop\n}\nexport function doObjKeys<T>(each: typeof eachProps, obj: object, own?: boolean): T[]\nexport function doObjKeys<T>(each: typeof eachProps, obj: object, callback: ObjKeyHandler<T>, own?: boolean): T[]\nexport function doObjKeys<T>(\n\teach: typeof eachProps,\n\tobj: object,\n\tcallback: ObjKeyHandler<T>,\n\tscope?: any,\n\town?: boolean\n): T[]\nexport function doObjKeys<T>(\n\teach: typeof eachProps,\n\tobj: object,\n\tcallback_own?: ObjKeyHandler<T> | boolean,\n\tscope_own?: any,\n\town?: boolean\n): T[]\nexport function doObjKeys<T>(each: typeof eachProps, obj: object): T[] {\n\tconst rs: T[] = [],\n\t\targs = arguments\n\tlet handler: ObjKeyHandler<T> = defaultObjKeyHandler,\n\t\ti = 2,\n\t\tj = 0\n\tif (isFn(args[i])) {\n\t\thandler = args[i++]\n\t\tif (!isBool(args[i])) handler = bind(handler, args[i++])\n\t}\n\teach(\n\t\tobj,\n\t\t(prop, obj) => {\n\t\t\tconst val = handler(prop, obj)\n\t\t\tif (val === STOP) return STOP\n\t\t\tif (val !== SKIP) rs[j++] = val as T\n\t\t},\n\t\tnull,\n\t\targs[i]\n\t)\n\treturn rs\n}\n\n/**\n * @param obj\t\ttarget\n * @param handler\tkey handler\n * @param scope\t\tscope or handler\n * @param own\t\tis get own properties, default: true\n */\nexport function keys<T>(obj: object, own?: boolean): T[]\nexport function keys<T>(obj: object, callback: ObjKeyHandler<T>, own?: boolean): T[]\nexport function keys<T>(obj: object, callback: ObjKeyHandler<T>, scope?: any, own?: boolean): T[]\nexport function keys<T>(obj: object, callback?: ObjKeyHandler<T> | boolean, scope?: any, own?: boolean): T[] {\n\treturn doObjKeys(eachProps, obj, callback, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        values                                        *\n *                                                                                      */\n//========================================================================================\n\nexport type ObjValueHandler<T> = (value: any, prop: string, obj: object) => T | Control\n\nfunction defaultObjValueHandler(value: any, prop: string, obj: object): any {\n\treturn value\n}\nexport function doObjValues<T>(each: typeof eachObj, obj: object, own?: boolean): T[]\nexport function doObjValues<T>(each: typeof eachObj, obj: object, callback: ObjValueHandler<T>, own?: boolean): T[]\nexport function doObjValues<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: ObjValueHandler<T>,\n\tscope?: any,\n\town?: boolean\n): T[]\nexport function doObjValues<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback_own?: ObjValueHandler<T> | boolean,\n\tscope_own?: any,\n\town?: boolean\n): T[]\nexport function doObjValues<T>(each: typeof eachObj, obj: object): T[] {\n\tconst rs: T[] = [],\n\t\targs = arguments\n\tlet handler: ObjValueHandler<T> = defaultObjValueHandler,\n\t\ti = 1,\n\t\tj = 0\n\tif (isFn(args[i])) {\n\t\thandler = args[i++]\n\t\tif (!isBool(args[i])) handler = bind(handler, args[i++])\n\t}\n\teach(\n\t\tobj,\n\t\tfunction(data, prop, obj) {\n\t\t\tconst val = handler(data, prop, obj)\n\t\t\tif (val === STOP) return STOP\n\t\t\tif (val !== SKIP) rs[j++] = val as T\n\t\t},\n\t\tnull,\n\t\targs[i]\n\t)\n\treturn rs\n}\n\n/**\n * @param obj\t\ttarget\n * @param handler\tvalue handler\n * @param scope\t\tscope or handler\n * @param own\t\tis get own properties, default: true\n */\nexport function values<T>(obj: object, own?: boolean): T[]\nexport function values<T>(obj: object, callback: ObjValueHandler<T>, own?: boolean): T[]\nexport function values<T>(obj: object, callback: ObjValueHandler<T>, scope?: any, own?: boolean): T[]\nexport function values<T>(obj: object, callback?: ObjValueHandler<T> | boolean, scope?: any, own?: boolean): T[] {\n\treturn doObjValues(eachObj, obj, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Fri Nov 16 2018 16:29:04 GMT+0800 (China Standard Time)\n * @modified Fri Nov 30 2018 17:42:28 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './control'\nimport { eachArray } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isFn, isStr, isArray } from '../is'\nimport {create} from '../create'\n\n/**\n * @return STOP or SKIP or [key: string, value: any]\n */\nexport type Arr2ObjCallback = (data: any, index: number, array: IArray) => Control | [string, any]\n\nexport function doArr2Obj(each: typeof eachArray, array: IArray, callback: Arr2ObjCallback, scope?: any): object {\n\tconst obj = create(null)\n\tcallback = bind(callback, scope)\n\teach(array, (data, index, array) => {\n\t\tconst r: Control | [string, any] = callback(data, index, array)\n\t\tif (isArray(r)) {\n\t\t\tobj[r[0]] = r[1]\n\t\t} else {\n\t\t\treturn r as Control\n\t\t}\n\t})\n\treturn obj\n}\n\n/**\n * convert array to object\n */\nexport function arr2obj(array: IArray, callback: Arr2ObjCallback, scope?: any): object {\n\treturn doArr2Obj(eachArray, array, callback, scope)\n}\n\n/**\n * convert array or string to object\n * @param array\n * @param val\tvalue or callback\n * @param split\tsplit char on string\n */\nexport function makeMap(array: IArray, val: Arr2ObjCallback, split?: string): object\nexport function makeMap(array: IArray, val?: any, split?: string): object\nexport function makeMap(array: IArray, val?: any, split?: string): object {\n\tif (isStr(array)) array = (array as string).split(isStr(split) ? split : ',')\n\treturn arr2obj(array, isFn(val) ? val : data => [data, val])\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Nov 15 2018 12:13:54 GMT+0800 (China Standard Time)\n * @modified Tue Dec 04 2018 20:10:32 GMT+0800 (China Standard Time)\n */\n\nexport { STOP, eachProps, eachArray, eachObj, each } from './each'\nexport { SKIP, mapArray, mapObj, map } from './map'\nexport { idxOfArray, idxOfObj, idxOf } from './idxOf'\nexport { reduceArray, reduceObj, reduce } from './reduce'\nexport { keys, values } from './obj2arr'\nexport { arr2obj, makeMap } from './arr2obj'\nexport function makeArray<T>(len: number, callback: (index: number) => T): T[] {\n\tconst array = new Array(len)\n\tlet i = len\n\twhile (i--) array[i] = callback(i)\n\treturn array\n}\n","/**\n * @module utility/prop\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Fri Nov 30 2018 14:41:02 GMT+0800 (China Standard Time)\n * @modified Mon Dec 10 2018 16:59:08 GMT+0800 (China Standard Time)\n */\n\nimport {create} from './create'\nimport { isArray } from './is'\nimport { mapArray } from './collection'\n\nconst pathCache: { [key: string]: string[] } = create(null)\n\n// prop | [index | \"string prop\" | 'string prop']\nconst pathReg = /(?:^|\\.)([a-zA-Z$_][\\w$]*)|\\[\\s*(?:(\\d+)|\"((?:[^\\\\\"]|\\\\.)*)\"|'((?:[^\\\\']|\\\\.)*)')\\s*\\]/g\n\nexport function parsePath(path: string | string[], cacheable?: boolean): string[]\nexport function parsePath(path, cacheable) {\n\tif (isArray(path)) return path\n\n\tlet array = pathCache[path]\n\tif (!array) {\n\t\tarray = []\n\t\tvar match,\n\t\t\tidx = 0,\n\t\t\tcidx,\n\t\t\ti = 0\n\t\twhile ((match = pathReg.exec(path))) {\n\t\t\tcidx = pathReg.lastIndex\n\t\t\tif (cidx !== idx + match[0].length) {\n\t\t\t\tthrow new SyntaxError(`Invalid Path: \"${path}\", unkown character[${path.charAt(idx)}] at offset:${idx}`)\n\t\t\t}\n\t\t\tarray[i++] = match[1] || match[2] || match[3] || match[4]\n\t\t\tidx = cidx\n\t\t}\n\t\tif (cacheable === false) return array\n\t\tpathCache[path] = array\n\t}\n\treturn array.slice()\n}\n\nexport function formatPath(path: string | string[]): string {\n\treturn isArray(path) ? mapArray(path, formatPathHandler).join('') : (path as string)\n}\n\nfunction formatPathHandler(prop: string): string {\n\treturn `[\"${String(prop).replace(\"'\", '\\\\\"')}\"]`\n}\n\nexport function get(obj, path) {\n\tpath = parsePath(path)\n\tconst l = path.length - 1\n\tif (l === -1) return obj\n\tlet i = 0\n\tfor (; i < l; i++) {\n\t\tobj = obj[path[i]]\n\t\tif (obj === null || obj === undefined) return undefined\n\t}\n\treturn obj ? obj[path[i]] : undefined\n}\n\nexport function set(obj, path, value) {\n\tpath = parsePath(path)\n\tconst l = path.length - 1\n\tif (l === -1) return\n\tlet attr,\n\t\tv,\n\t\ti = 0\n\tfor (; i < l; i++) {\n\t\tattr = path[i]\n\t\tv = obj[attr]\n\t\tif (!v) obj[attr] = v = {}\n\t\tobj = v\n\t}\n\tattr = path[i]\n\tobj[attr] = value\n}\n","/**\n * String utilities\n * @module utility/string\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Sat Dec 08 2018 16:16:42 GMT+0800 (China Standard Time)\n */\nimport { createFn } from './fn'\nimport { isNil, isFn, isNum } from './is'\nimport { get } from './propPath'\nimport {create} from './create'\n\n//========================================================================================\n/*                                                                                      *\n *                                       char code                                      *\n *                                                                                      */\n//========================================================================================\n\n/**\n * get char code\n * > string.charCodeAt\n */\nexport function charCode(str: string, index?: number): number {\n\treturn str.charCodeAt(index || 0)\n}\n\n/**\n * get char by char code\n * > String.fromCharCode\n */\nexport function char(code: number): string {\n\treturn String.fromCharCode(code)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         trim                                         *\n *                                                                                      */\n//========================================================================================\n\nconst TRIM_REG = /(^\\s+)|(\\s+$)/g\n\n/**\n * trim\n */\nexport function trim(str: string): string {\n\treturn str.replace(TRIM_REG, '')\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         case                                         *\n *                                                                                      */\n//========================================================================================\n\nconst FIRST_LOWER_LETTER_REG = /^[a-z]/\n\n/**\n * upper first char\n */\nexport function upperFirst(str: string): string {\n\treturn str.replace(FIRST_LOWER_LETTER_REG, upper)\n}\n\nexport function upper(m: string): string {\n\treturn m.toUpperCase()\n}\n\nexport function lower(m: string): string {\n\treturn m.toLowerCase()\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                  parse string value                                  *\n *                                                                                      */\n//========================================================================================\n\n/**\n * convert any value to string\n * - undefined | null: ''\n * - NaN:\n * - Infinity:\n * - other: String(value)\n * TODO support NaN, Infinity\n */\nexport function strval(obj: any): string {\n\treturn isNil(obj) ? '' : String(obj)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        escape                                        *\n *                                                                                      */\n//========================================================================================\n\nconst STR_ESCAPE_MAP = {\n\t\t'\\n': '\\\\n',\n\t\t'\\t': '\\\\t',\n\t\t'\\f': '\\\\f',\n\t\t'\"': '\\\\\"',\n\t\t\"'\": \"\\\\'\"\n\t},\n\tSTR_ESCAPE = /[\\n\\t\\f\"']/g\n\nexport function escapeStr(str: string): string {\n\treturn str.replace(STR_ESCAPE, str => STR_ESCAPE_MAP[str])\n}\n","/**\n * @module utility/format\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 03 2018 19:46:41 GMT+0800 (China Standard Time)\n * @modified Mon Dec 10 2018 16:26:23 GMT+0800 (China Standard Time)\n */\n\nimport { createFn } from './fn'\nimport { isFn } from './is'\nimport { get, parsePath } from './propPath'\nimport { create } from './create'\nimport { charCode, upper, escapeStr } from './string'\n\n//========================================================================================\n/*                                                                                      *\n *                                       pad & cut                                      *\n *                                                                                      */\n//========================================================================================\n\nexport function pad(str: string, len: number, chr?: string, leftAlign?: boolean | number): string {\n\treturn len > str.length ? __pad(str, len, chr, leftAlign) : str\n}\n\nexport function cut(str: string, len: number, suffix?: string): string {\n\treturn len < str.length ? ((suffix = suffix || ''), str.substr(0, len - suffix.length) + suffix) : str\n}\n\nfunction __pad(str: string, len: number, chr: string, leftAlign: boolean | number): string {\n\tconst padding = new Array(len - str.length + 1).join(chr || ' ')\n\treturn leftAlign ? str + padding : padding + str\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       Separator                                      *\n *                                                                                      */\n//========================================================================================\n\nexport const thousandSeparate = mkSeparator(3),\n\tbinarySeparate = mkSeparator(8, '01'),\n\toctalSeparate = mkSeparator(4, '0-7'),\n\thexSeparate = mkSeparator(4, '\\\\da-fA-F')\n\nfunction mkSeparator(group: number, valReg?: string): (numStr: string) => string {\n\tvalReg = valReg || '\\\\d'\n\tconst reg = new RegExp(\n\t\t`^(?:[+-]|\\\\s+|0[xXbBoO])|([${valReg}])(?=([${valReg}]{${group}})+(?![${valReg}]))|[^${valReg}].*`,\n\t\t'g'\n\t)\n\treturn numStr => numStr.replace(reg, separatorHandler)\n}\nfunction separatorHandler(m, d) {\n\treturn d ? d + ',' : m\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                   plural & singular                                  *\n *                                                                                      */\n//========================================================================================\n\nconst PLURAL_REG = /([a-zA-Z]+)([^aeiou])y$|([sxzh])$|([aeiou]y)$|([^sxzhy])$/\nexport function plural(str: string): string {\n\treturn str.replace(PLURAL_REG, pluralHandler)\n}\nfunction pluralHandler(m, v, ies, es, ys, s) {\n\treturn v + (ies ? ies + 'ies' : es ? es + 'es' : (ys || s) + 's')\n}\n\nconst SINGULAR_REG = /([a-zA-Z]+)([^aeiou])ies$|([sxzh])es$|([aeiou]y)s$|([^sxzhy])s$/\nexport function singular(str: string): string {\n\treturn str.replace(SINGULAR_REG, singularHandler)\n}\nfunction singularHandler(m, v, ies, es, ys, s) {\n\treturn v + (ies ? ies + 'y' : es || ys || s)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     format flags                                     *\n *                                                                                      */\n//========================================================================================\n\ntype FormatFlags = number\n\nexport const FORMAT_XPREFIX: FormatFlags = 0x1\nexport const FORMAT_PLUS: FormatFlags = 0x2\nexport const FORMAT_ZERO: FormatFlags = 0x4\nexport const FORMAT_SPACE: FormatFlags = 0x8\nexport const FORMAT_SEPARATOR: FormatFlags = 0x10\nexport const FORMAT_LEFT: FormatFlags = 0x20\n\nconst FLAG_MAPPING = {\n\t'#': FORMAT_XPREFIX,\n\t'+': FORMAT_PLUS,\n\t'0': FORMAT_ZERO,\n\t' ': FORMAT_SPACE,\n\t',': FORMAT_SEPARATOR,\n\t'-': FORMAT_LEFT\n}\nfunction parseFlags(f: string): FormatFlags {\n\tlet flags: FormatFlags = 0\n\tif (f) {\n\t\tvar i = f.length\n\t\twhile (i--) flags |= FLAG_MAPPING[f.charAt(i)]\n\t}\n\treturn flags\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      format Rule                                     *\n *                                                                                      */\n//========================================================================================\n\n//   0      1      2     3     4       5       6           7         8      9           10             11             12        13\n// [match, expr, index, prop, flags, width, width-idx, width-prop, fill, precision, precision-idx, precision-prop, cut-suffix, type]\nconst paramIdxR = `(\\\\d+|\\\\$|@)`,\n\tparamPropR = `(?:\\\\{((?:[a-zA-Z$_][\\\\w$_]*|\\\\[(?:\\\\d+|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)*\"|'(?:[^\\\\\\\\']|\\\\\\\\.)*')\\\\])(?:\\\\.[a-zA-Z$_][\\\\w$_]*|\\\\[(?:\\\\d+|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)*\"|'(?:[^\\\\\\\\']|\\\\\\\\.)*')\\\\])*)\\\\})`,\n\twidthR = `(?:([1-9]\\\\d*)|&${paramIdxR}${paramPropR})`,\n\tfillR = `(?:=(.))`,\n\tcutSuffixR = `(?:=\"((?:[^\\\\\\\\\"]|\\\\\\\\.)*)\")`,\n\tformatReg = new RegExp(\n\t\t`\\\\\\\\.|(\\\\{${paramIdxR}?${paramPropR}?(?::([#,+\\\\- 0]*)(?:${widthR}${fillR}?)?(?:\\\\.${widthR}${cutSuffixR}?)?)?([a-zA-Z_][a-zA-Z0-9_$]*)?\\\\})`,\n\t\t'g'\n\t)\n\n//========================================================================================\n/*                                                                                      *\n *                                      Formatters                                      *\n *                                                                                      */\n//========================================================================================\n\ntype FormatCallback = (\n\tval: any,\n\tflags: FormatFlags,\n\twidth: number,\n\tfill: string,\n\tprecision: number,\n\tcutSuffix: string\n) => string\n\nconst formatters: {\n\t[k: string]: FormatCallback\n} = create(null)\n\nexport function extendFormatter(obj: { [key: string]: FormatCallback }) {\n\tvar fmt, name\n\tfor (name in obj) {\n\t\tfmt = obj[name]\n\t\tisFn(fmt) && (formatters[name] = fmt)\n\t}\n}\n\nexport function getFormatter(name: string): FormatCallback {\n\tconst f = formatters[name || 's']\n\tif (f) return f\n\tthrow new Error(`Invalid Formatter: ${name}`)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                           format by every parameter object                           *\n *                                                                                      */\n//========================================================================================\n\n/**\n * Syntax:\n * @example\n * \t'{'\n * \t\t(<parameter>)?\n * \t\t(\n * \t\t\t':'\n * \t\t\t(<flags>)?\n * \t\t\t(\n * \t\t\t\t<width> ('=' <fill-char>)?\n * \t\t\t)?\n * \t\t\t(\n * \t\t\t\t'.'\n * \t\t\t\t<precision> ('=' '\"' <cut-suffix> '\"')?\n * \t\t\t)?\n * \t\t)?\n * \t\t(<type>)?\n * \t'}'\n *\n * - parameter\n * \t\t- {}\t\t\t\t\tformat by next unused argument\n * \t\t- {<number>}\t\t\tformat by arguments[number]\n * \t\t- {@}\t\t\t\t\tformat by current used argument\n * \t\t- {$}\t\t\t\t\tformat by next unused argument\n * \t\t- {{name}}\t\t\t\tformat by \"name\" property on next unused argument\n * \t\t- {<number>{name}}\t\tformat by \"name\" property on arguments[number]\n * \t\t- {@{name}}\t\t\t\tformat by \"name\" property on current used argument\n * \t\t- {${name}}\t\t\t\tformat by \"name\" property on next unused argument\n * @example\n * \t\tformat('<{} {}>', 'abc')\t\t\t\t// return \"<abc undefined>\"\n * \t\tformat('<{$} {$}>', 'abc')\t\t\t\t// return \"<abc undefined>\"\n * \t\tformat('<{@} {} {@}>', 'abc')\t\t\t// return \"<abc abc abc>\"\n * \t\tformat('<{0} {} {0}>', 'abc')\t\t\t// return \"<abc abc abc>\"\n * \t\tformat('<{0{value}} {${value}} {@{value}} {{value.a}}>', {value: 'abc'}, {value: {a: 'cbd'}})\n * \t\t// return \"<abc abc abc bcd>\"\n * \t\tformat('<{0{[0]}} {${[0]}} {@{[0]}} {{[0].a}}>', ['abc'], [{a: 'cbd'}])\n * \t\t// return \"<abc abc abc bcd>\"\n *\n * - flags\n * \t\t- {:#}    \tFORMAT_XPREFIX\n * \t\t\t\t\tensure the leading \"0\" for any octal\n * \t\t\t\t\tprefix non-zero hexadecimal with \"0x\" or \"0X\"\n * \t\t\t\t\tprefix non-zero binary with \"0b\" or \"0B\"\n * \t\t- {:+}    \tFORMAT_PLUS\n * \t\t\t\t\tForces to preceed the result with a plus or minus sign (+ or -) even for positive numbers.\n * \t\t\t\t\tBy default, only negative numbers are preceded with a - sign\n * \t\t- {:0}\t\tFORMAT_ZERO\n * \t\t\t\t\tLeft-pads the number with zeroes (0) instead of spaces when padding is specified\n * \t\t- {: }   \tFORMAT_SPACE\n * \t\t\t\t\tIf no sign is going to be written, a blank space is inserted before the value\n * \t\t- {:,}\t\tFORMAT_SEPARATOR\n * \t\t\t\t\tuse thousand separator on decimal number\n * \t\t\t\t\thexadecimal number: FFFFFFFF => FFFF,FFFF\n * \t\t\t\t\toctal number: 77777777 => 7777,7777\n * \t\t\t\t\tbinary number: 1111111111111111 => 11111111,11111111\n * \t\t{:-}    \tFORMAT_LEFT\n * \t\t\t\t\tLeft-justify within the given field width; Right justification is the default\n * @example\n * \t\tformat('<{: d}>',  12);\t\t// return \"< 12>\"\n *\t\tformat('<{: d}>',   0);\t\t// return \"< 0>\"\n *\t\tformat('<{: d}>', -12);\t\t// return \"<-12>\"\n *\t\tformat('<{:+d}>',  12);\t\t// return \"<+12>\"\n *\t\tformat('<{:+d}>',   0);\t\t// return \"<+0>\"\n *\t\tformat('<{:+d}>', -12);\t\t// return \"<-12>\"\n *\t\tformat('<{:6s}>',  12);\t\t// return \"<    12>\"\n *\t\tformat('<{:-6s}>', 12);\t\t// return \"<12    >\"\n *\t\tformat('<{:#o}>',  12);\t\t// return \"<014>\"\n *\t\tformat('<{:#x}>',  12);\t\t// return \"<0xc>\"\n *\t\tformat('<{:#X}>',  12);\t\t// return \"<0XC>\"\n *\t\tformat('<{:#b}>',  12);\t\t// return \"<0b1100>\"\n *\t\tformat('<{:#B}>',  12);\t\t// return \"<0B1100>\"\n\n * - width\n * \t\tMinimum number of characters to be printed.\n * \t\tIf the value to be printed is shorter than this number, the result is padded with pad char(default is space).\n * \t\tThe value is not truncated even if the result is larger.\n *\t\t- width value\n * \t\t\t{:<number>}\n * \t\t\t{:&@}\n * \t\t\t{:&$}\n * \t\t\t{:&<number>}\n * \t\t\t{:&@{<prop>}}\n * \t\t\t{:&${<prop>}}\n * \t\t\t{:&<number>{<prop>}}\n *\t\t- pad char\n * \t\t\t{:&@=<pad-char>}\n * \t\t\t{:&$=<pad-char>}\n * \t\t\t{:&<number>=<pad-char>}\n * \t\t\t{:&@{<prop>}=<pad-char>}\n * \t\t\t{:&${<prop>}=<pad-char>}\n * \t\t\t{:&<number>{<prop>}=<pad-char>}\n * @example\n *\n * - precision\n * \t\tFor integer specifiers (d,  o, u, x, X): precision specifies the minimum number of digits to be written.\n * \t\tIf the value to be written is shorter than this number, the result is padded with leading zeros.\n * \t\tThe value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0.\n * \t\tFor a, A, e, E, f and F specifiers: this is the number of digits to be printed after the decimal point (by default, this is 6).\n * \t\tFor g and G specifiers: This is the maximum number of significant digits to be printed.\n * \t\tFor s: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered.\n * \t\tIf the period is specified without an explicit value for precision, 0 is assumed.\n * \t\t- precision value\n * \t\t\t{:.<number>}\n * \t\t\t{:.&@}\n * \t\t\t{:.&$}\n * \t\t\t{:.&<number>}\n * \t\t\t{:.&@{<prop>}}\n * \t\t\t{:.&${<prop>}}\n * \t\t\t{:.&<number>{<prop>}}\n * \t\t- cut suffix\n * \t\t\t{:.&@=\"<suffix>\"}\n * \t\t\t{:.&$=\"<suffix>\"}\n * \t\t\t{:.&<number>=\"<suffix>\"}\n * \t\t\t{:.&@{<prop>}=\"<suffix>\"}\n * \t\t\t{:.&${<prop>}=\"<suffix>\"}\n * \t\t\t{:.&<number>{<prop>}=\"<suffix>\"}\n * - type\n * \t\t- default types\n *\t\t\t- {c}\t\tCharacter\n * \t\t\t- {s}\t\tString\n * \t\t\t- {j}\t\tJSON String\n * \t\t\t- {y}\t\tDate Year\n * \t\t\t- {m}\t\tDate Month\n * \t\t\t- {w}\t\tDate Weekly\n * \t\t\t- {W}\t\tDate Weekly\n * \t\t\t- {D}\t\tDate\n * \t\t\t- {H}\t\tDate\n * \t\t\t- {M}\t\tDate\n * \t\t\t- {S}\t\tDate\n * \t\t\t- {d} \t\tSigned decimal integer\n *\t\t\t- {u}\t\tUnsigned decimal integer\n *\t\t\t- {o}\t\tUnsigned octal\n *\t\t\t- {x}\t\tUnsigned hexadecimal integer\n *\t\t\t- {X}\t\tUnsigned hexadecimal integer (uppercase)\n *\t\t\t- {f}\t\tDecimal floating point, lowercase,\n *\t\t\t- {e}\t\tScientific notation (mantissa/exponent), lowercase\n *\t\t\t- {E}\t\tScientific notation (mantissa/exponent), uppercase\n *\t\t\t- {g}\t\tUse the shortest representation: %e or %f\n *\t\t\t- {G}\t\tUse the shortest representation: %E or %F\n * - Rules\n * \t\t- property-path\n * \t\t\t\t(\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t[a-zA-Z$_][\\w$_]*|\n * \t\t\t\t\t\t\\[\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\\d+|\n * \t\t\t\t\t\t\t\"(?:[^\\\\\"]|\\\\.)*\"|\n * \t\t\t\t\t\t\t'(?:[^\\\\']|\\\\.)*'\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t\\]\n * \t\t\t\t\t)\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t\\.[a-zA-Z$_][\\w$_]*|\n * \t\t\t\t\t\t\\[\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\\d+|\n * \t\t\t\t\t\t\t\"(?:[^\\\\\"]|\\\\.)*\"|\n * \t\t\t\t\t\t\t'(?:[^\\\\']|\\\\.)*'\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t\\]\n * \t\t\t\t\t)*\n * \t\t\t\t)\n * \t\t- expression\n * \t\t\t/\\\\.|\t\t\t\t\t\t\t\t\t\t\t\t// escape\n * \t\t\t(\t\t\t\t\t\t\t\t\t\t\t\t\t// 1: expression\n * \t\t\t\t\\{\n * \t\t\t\t(\\d+|\\$|@)?\t\t\t\t\t\t\t\t\t\t// 2: parameter index\n * \t\t\t\t(?:\\{<property-path>\\})?\t\t\t\t\t\t// 3: property path of parameter\n * \t\t\t\t(?:\n * \t\t\t\t\t:\n * \t\t\t\t\t([#,+\\- ]*)\t\t\t\t\t\t\t\t\t// 4: flags\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t(\\d+)|\t\t\t\t\t\t\t\t// 5: width\n * \t\t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\t&\n * \t\t\t\t\t\t\t\t(\\d+|\\$|@)\t\t\t\t\t\t// 6: parameter index of width\n * \t\t\t\t\t\t\t\t(?:\\{<property-path>\\})?\t\t// 7: property path of width parameter\n * \t\t\t\t\t\t\t)\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t(?:=(.))?\t\t\t\t\t\t\t\t// 8: pad fill\n * \t\t\t\t\t)?\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t\\.\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t(\\d+)|\t\t\t\t\t\t\t\t// 9: width\n * \t\t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\t&\n * \t\t\t\t\t\t\t\t(\\d+|\\$|@)\t\t\t\t\t\t// 10: parameter index of width\n * \t\t\t\t\t\t\t\t(?:\\{<property-path>\\})?\t\t// 11: property path of width parameter\n * \t\t\t\t\t\t\t)\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t=\n * \t\t\t\t\t\t\t\"\n * \t\t\t\t\t\t\t((?:[^\\\\\"]|\\\\.)*)\t\t\t\t\t// 12: cut su\n * \t\t\t\t\t\t\t\"\n * \t\t\t\t\t\t)\n * \t\t\t\t\t)?\n * \t\t\t\t)?\n * \t\t\t\t([a-zA-Z_][a-zA-Z0-9_$]*)?\t\t\t\t\t\t// 13: data type\n * \t\t\t\t\\}\n * \t\t\t)/\n * @param fmt \t\tformat String\n * @param args\t\tformat arguments\n * @param offset\tstart offset of arguments\n * @param getParam\tget parameter on arguments callback\n */\nexport function vformat<T>(fmt: string, args: T, offset?: number, getParam?: (args: T, idx: number) => any): string {\n\toffset = offset || 0\n\tconst start = offset\n\tgetParam = getParam || defaultGetParam\n\treturn fmt.replace(formatReg, function(\n\t\ts,\n\t\tm,\n\t\tparam,\n\t\tparamProp,\n\t\tflags,\n\t\twidth,\n\t\twidx,\n\t\twprop,\n\t\tfill,\n\t\tprecision,\n\t\tpidx,\n\t\tpprop,\n\t\tcutSuffix,\n\t\ttype\n\t) {\n\t\tif (!m) return s.charAt(1)\n\t\treturn getFormatter(type)(\n\t\t\tparseParam(param || '$', paramProp),\n\t\t\tparseFlags(flags),\n\t\t\tparseWidth(width, widx, wprop) || 0,\n\t\t\tfill,\n\t\t\tparseWidth(precision, pidx, pprop),\n\t\t\tcutSuffix\n\t\t)\n\t})\n\n\tfunction parseWidth<T>(width: string, idx: string, prop: string): number {\n\t\tif (width) return (width as any) >> 0\n\t\tif (idx) {\n\t\t\tconst w = parseParam(idx, prop) >> 0\n\t\t\tif (isFinite(w)) return w\n\t\t}\n\t}\n\n\tfunction parseParam<T>(paramIdx: string, prop: string): any {\n\t\tlet param = getParam(\n\t\t\targs,\n\t\t\tparamIdx === '$'\n\t\t\t\t? offset++\n\t\t\t\t: paramIdx === '@'\n\t\t\t\t? offset === start\n\t\t\t\t\t? offset\n\t\t\t\t\t: offset - 1\n\t\t\t\t: (paramIdx as any) >> 0\n\t\t)\n\t\treturn prop ? get(param, prop) : param\n\t}\n}\n\nfunction defaultGetParam(args: any, idx: number) {\n\treturn args[idx]\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        format                                        *\n *                                                                                      */\n//========================================================================================\n\n/**\n * @see vformat\n * @param fmt\tformat string\n * @param args\tformat arguments\n */\nexport function format(fmt: string, ...args: any): string\nexport function format(fmt: string): string {\n\treturn vformat(fmt, arguments, 0, getFormatParam)\n}\n\nfunction getFormatParam(args: IArguments, idx: number) {\n\treturn args[idx + 1]\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       formatter                                      *\n *                                                                                      */\n//========================================================================================\n\nconst GET_PARAM_VAR = 'getp',\n\tGET_PROP_VAR = 'get',\n\tSTATE_VAR = 'state'\nfunction createFormatter(m: string[], getParam?: (args: IArguments, idx: number) => any) {\n\treturn createFn(\n\t\t`return function(args, ${STATE_VAR}){\nreturn fmt(${getParamCode(m[2] || '$', m[3])},\n\"${parseFlags(m[4])}\",\n${getWidthCode(m[5], m[6], m[7], '0')},\n\"${m[8] ? escapeStr(m[8]) : ' '}\",\n${getWidthCode(m[9], m[10], m[11], 'void 0')},\n\"${m[12] ? escapeStr(m[12]) : ''}\");\n}`,\n\t\t['fmt', GET_PROP_VAR, GET_PARAM_VAR]\n\t)(getFormatter(m[13]), get, getParam)\n}\n\nfunction getWidthCode(width: string, idx: string, prop: string, def: string): string {\n\treturn width ? width : idx ? getParamCode(idx, prop) : def\n}\n\nfunction getParamCode(idx: string, prop: string): string {\n\tlet code = `${GET_PARAM_VAR}(args, ${\n\t\tidx === '$'\n\t\t\t? `${STATE_VAR}[0]++`\n\t\t\t: idx === '@'\n\t\t\t? `${STATE_VAR}[0] === ${STATE_VAR}[1] ? ${STATE_VAR}[0] : ${STATE_VAR}[0] - 1`\n\t\t\t: idx\n\t})`\n\tif (prop) {\n\t\tconst path = parsePath(prop)\n\t\tvar i = path.length\n\t\twhile (i--) path[i] = `\"${escapeStr(path[i])}\"`\n\t\treturn `${GET_PROP_VAR}(${code}, [${path.join(', ')}])`\n\t}\n\treturn code\n}\n/**\n * @see vformat\n * @param fmt\t\tformat string\n * @param offset\tstart offset of arguments\n * @param getParam\tget parameter on arguments callback\n */\nexport function formatter(\n\tfmt: string,\n\toffset?: number,\n\tgetParam?: (args: IArguments, idx: number) => any\n): (...args: any[]) => string {\n\tlet m,\n\t\tlastIdx = 0,\n\t\tmStart,\n\t\tmEnd,\n\t\tarr = [],\n\t\tcodes = [],\n\t\ti = 0\n\toffset = offset || 0\n\twhile ((m = formatReg.exec(fmt))) {\n\t\tmEnd = formatReg.lastIndex\n\t\tmStart = mEnd - m[0].length\n\t\tlastIdx < mStart && pushStr(fmt.substring(lastIdx, mStart), 0)\n\t\tif (m[1]) {\n\t\t\tcodes[i] = `arr[${i}](arguments, ${STATE_VAR})`\n\t\t\tarr[i++] = createFormatter(m, getParam || defaultGetParam)\n\t\t} else {\n\t\t\tpushStr(m[0].charAt(1), i)\n\t\t}\n\t\tlastIdx = mEnd\n\t}\n\tlastIdx < fmt.length && pushStr(fmt.substring(lastIdx), i)\n\treturn createFn(`return function(){var ${STATE_VAR} = [${offset}, ${offset}]; return ${codes.join(' + ')}}`, [\n\t\t'arr'\n\t])(arr)\n\n\tfunction pushStr(str, append) {\n\t\tif (append && arr[i - 1].match) {\n\t\t\tarr[i - 1] += str\n\t\t} else {\n\t\t\tcodes[i] = `arr[${i}]`\n\t\t\tarr[i++] = str\n\t\t}\n\t}\n}\n/*\nsetTimeout(() => {\n\tvar f,\n\t\tn = 100000\n\tconsole.time()\n\tfor (var i = 0; i < n; i++) {\n\t\tf = formatter(`{:.10=\"...\"}`)\n\t}\n\tconsole.timeEnd()\n\tconsole.time()\n\tfor (var i = 0; i < n; i++) {\n\t\tf('abbdddded')\n\t}\n\tconsole.timeEnd()\n\tconsole.time()\n\tfor (var i = 0; i < n; i++) {\n\t\tformat(`{:.10=\"...\"}`, 'abbdddded')\n\t}\n\tconsole.timeEnd()\n\tconsole.log(formatter(`{:.10=\"...\"}`).toString())\n}) */\n//========================================================================================\n/*                                                                                      *\n *                                  default formatters                                  *\n *                                                                                      */\n//========================================================================================\n\nfunction strFormatter(toStr: (num: number, flags: FormatFlags) => string): FormatCallback {\n\treturn function(val, flags, width, fill, precision, cutSuffix) {\n\t\tconst str = toStr(val, flags)\n\t\treturn width > str.length ? __pad(str, width, fill, flags & FORMAT_LEFT) : cut(str, precision, cutSuffix)\n\t}\n}\n\nfunction numFormatter(\n\tparseNum: (val: any) => number,\n\tgetPrefix: (num: number, flags: FormatFlags) => string,\n\ttoStr: (num: number, flags: FormatFlags, precision: number) => string,\n\tseparator: (numStr: string) => string\n): FormatCallback {\n\treturn function(val, flags, width, fill, precision) {\n\t\tconst num = parseNum(val)\n\t\tif (!isFinite(num)) return String(num)\n\n\t\tconst prefix = getPrefix(num, flags),\n\t\t\tplen = prefix.length\n\t\tlet str = toStr(num < 0 ? -num : num, flags, precision)\n\n\t\treturn flags & FORMAT_ZERO\n\t\t\t? ((str = prefix + pad(str, width - plen, '0')), flags & FORMAT_SEPARATOR ? separator(str) : str)\n\t\t\t: (flags & FORMAT_SEPARATOR && (str = separator(str)), pad(prefix + str, width, fill, flags & FORMAT_LEFT))\n\t}\n}\n\nfunction decimalPrefix(num: number, flags: FormatFlags): string {\n\treturn num < 0 ? '-' : flags & FORMAT_PLUS ? '+' : flags & FORMAT_SPACE ? ' ' : ''\n}\n\n// base formatter \nconst BASE_RADIXS = {\n\tb: [2, binarySeparate],\n\to: [8, octalSeparate],\n\tu: [10, thousandSeparate],\n\tx: [16, hexSeparate]\n}\nconst BASE_PREFIXS = ['0b', '0o', '0x']\nfunction baseFormatter(type: string): FormatCallback {\n\tconst base = BASE_RADIXS[type.toLowerCase()],\n\t\tn = base[0],\n\t\t__toStr = num => num.toString(n),\n\t\ttoStr = type === 'X' ? num => upper(__toStr(num)) : __toStr\n\tlet xprefix = n === 10 ? '' : BASE_PREFIXS[n >> 3]\n\tcharCode(type) < 96 && (xprefix = upper(xprefix))\n\treturn numFormatter(v => v >>> 0, (num, flags) => (flags & FORMAT_XPREFIX ? xprefix : ''), toStr, base[1])\n}\n\n// float formatter \nfunction floatFormatter(type: string): FormatCallback {\n\tconst ____toStr = upper(type) === 'E' ? toExponential : type === 'f' ? toFixed : toPrecision,\n\t\t__toStr = (num, flags, precision) => ____toStr(num, precision) || String(num),\n\t\ttoStr = charCode(type) > 96 ? __toStr : (num, flags, precision) => upper(__toStr(num, flags, precision))\n\treturn numFormatter(parseFloat, decimalPrefix, toStr, thousandSeparate)\n}\n\nfunction toExponential(num: number, precision: number): string {\n\treturn num.toExponential(precision)\n}\nfunction toPrecision(num: number, precision: number): string {\n\treturn precision && num.toPrecision(precision)\n}\nfunction toFixed(num: number, precision: number): string {\n\treturn precision >= 0 && num.toFixed(precision)\n}\n\n// register formatters \nextendFormatter({\n\ts: strFormatter(toStr),\n\tj: strFormatter(v => (v === undefined ? 'undefined' : JSON.stringify(v))),\n\tc(val: any) {\n\t\tconst num = val >> 0\n\t\treturn num > 0 ? String.fromCharCode(num) : ''\n\t},\n\td: numFormatter(val => val >> 0, decimalPrefix, toStr, thousandSeparate),\n\te: floatFormatter('e'),\n\tE: floatFormatter('E'),\n\tf: floatFormatter('f'),\n\tg: floatFormatter('g'),\n\tG: floatFormatter('G'),\n\tb: baseFormatter('b'),\n\tB: baseFormatter('B'),\n\to: baseFormatter('o'),\n\tO: baseFormatter('O'),\n\tu: baseFormatter('u'),\n\tx: baseFormatter('x'),\n\tX: baseFormatter('X')\n})\n\nfunction toStr(v: any): string {\n\treturn String(v)\n}\n","/**\n * Object.assign shim\n * @module utility/assign\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:22:13 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 14:03:59 GMT+0800 (China Standard Time)\n */\nimport { hasOwnProp } from './prop'\n\n/**\n * @param prop\n * @param target\n * @param override\n * @return is assign\n */\nexport type AssignFilter = (prop: string, target: any, override: any) => boolean\n\n/**\n *\n * @param target\n * @param overrides\n * @param filter\n * @param startOffset \tstart offset in overrides, default: 0\n * @param endOffset \tend offset in overrides, default: overrides.length-1\n */\nexport function doAssign(\n\ttarget: any,\n\toverrides: object[] | IArguments,\n\tfilter: AssignFilter,\n\tstartOffset?: number,\n\tendOffset?: number\n): any {\n\tif (!target) {\n\t\ttarget = {}\n\t}\n\tconst l = endOffset || overrides.length - 1\n\tlet i = startOffset || 0,\n\t\toverride,\n\t\tprop\n\tfor (; i < l; i++) {\n\t\tif ((override = overrides[i])) {\n\t\t\tfor (prop in override) {\n\t\t\t\tif (filter(prop, target, override)) {\n\t\t\t\t\ttarget[prop] = override[prop]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn target\n}\n\n/**\n * assign properties\n * > Object.assign shim\n */\nexport function assign(target: any, ...args: any[]): any\nexport function assign(target: any): any {\n\treturn doAssign(target, arguments, defaultAssignFilter, 1)\n}\n\n/**\n * assign un-exist properties\n */\nexport function assignIf(target: any, ...args: any[]): any\nexport function assignIf(target: any): any {\n\treturn doAssign(target, arguments, assignIfFilter, 1)\n}\n\n/**\n * default assign filter\n * - property is owner in override\n * @see {AssignFilter}\n */\nexport function defaultAssignFilter(prop: string, target: any, override: any): boolean {\n\treturn hasOwnProp(override, prop)\n}\n\n/**\n * assign if filter\n * - property is owner in override\n * - property not in target object\n * @see {AssignFilter}\n */\nexport function assignIfFilter(prop: string, target: any, override: any): boolean {\n\treturn hasOwnProp(override, prop) && !(prop in target)\n}\n","/**\n * @module utility/assert\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Nov 28 2018 11:01:45 GMT+0800 (China Standard Time)\n * @modified Sat Dec 15 2018 16:33:50 GMT+0800 (China Standard Time)\n */\n\nimport {\n\teq,\n\tisBool,\n\tisNum,\n\tisStr,\n\tisBoolean,\n\tisNumber,\n\tisString,\n\tisDate,\n\tisNull,\n\tisUndef,\n\tisNil,\n\tisFn,\n\tisInt,\n\tisPrimitive,\n\tisReg,\n\tisArray,\n\tisArrayLike,\n\tisTypedArray,\n\tisObj,\n\tisBlank\n} from '../utility/is'\nimport { create } from './create'\nimport { upperFirst, escapeStr } from '../utility/string'\nimport { createFn } from '../utility/fn'\nimport { eachObj, makeArray } from '../utility/collection'\nimport { formatter } from './format'\nimport { isError } from 'util'\n\nconst formatters = [],\n\tformatArgHandlers: ((args: any[] | IArguments, offset: number) => any)[] = []\nfunction parseMessage(msg: string, args: any[] | IArguments, msgIdx: number): string {\n\tconst fs =\n\t\tformatters[msgIdx] ||\n\t\t((formatArgHandlers[msgIdx] = (args, offset) => {\n\t\t\treturn args[0][offset >= msgIdx ? offset + 1 : offset]\n\t\t}),\n\t\t(formatters[msgIdx] = create(null)))\n\treturn (fs[msg] || (fs[msg] = formatter(msg, msgIdx, formatArgHandlers[msgIdx])))(args)\n}\n\nexport interface assert {\n\t(msg?: string, ...args: any[]): never\n\tis(actual: any, msg?: string, ...args: any[]): assert\n\tnot(actual: any, msg?: string, ...args: any[]): assert\n\teq(actual: any, expect: any, msg?: string, ...args: any[]): assert\n\tblank(actual: any, msg?: string, ...args: any[]): assert\n\tnul(actual: any, msg?: string, ...args: any[]): assert\n\tnil(actual: any, msg?: string, ...args: any[]): assert\n\tundef(actual: any, msg?: string, ...args: any[]): assert\n\tbool(actual: any, msg?: string, ...args: any[]): assert\n\tnum(actual: any, msg?: string, ...args: any[]): assert\n\tint(actual: any, msg?: string, ...args: any[]): assert\n\tstr(actual: any, msg?: string, ...args: any[]): assert\n\tfn(actual: any, msg?: string, ...args: any[]): assert\n\tprimitive(actual: any, msg?: string, ...args: any[]): assert\n\tboolean(actual: any, msg?: string, ...args: any[]): assert\n\tnumber(actual: any, msg?: string, ...args: any[]): assert\n\tstring(actual: any, msg?: string, ...args: any[]): assert\n\tdate(actual: any, msg?: string, ...args: any[]): assert\n\treg(actual: any, msg?: string, ...args: any[]): assert\n\tarray(actual: any, msg?: string, ...args: any[]): assert\n\ttypedArray(actual: any, msg?: string, ...args: any[]): assert\n\tarrayLike(actual: any, msg?: string, ...args: any[]): assert\n\tobj(actual: any, msg?: string, ...args: any[]): assert\n\tnan(actual: any, msg?: string, ...args: any[]): assert\n\tfinite(actual: number | string, msg?: string, ...args: any[]): assert\n\tless(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\tgreater(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\tmatch(actual: string, expect: any, msg?: string, ...args: any[]): assert\n\trange(actual: number, start: number, end: number, msg?: string, ...args: any[]): assert\n\n\tnotEq(actual: any, expect: any, msg?: string, ...args: any[]): assert\n\tnotBlank(actual: any, msg?: string, ...args: any[]): assert\n\tnotNul(actual: any, msg?: string, ...args: any[]): assert\n\tnotNil(actual: any, msg?: string, ...args: any[]): assert\n\tnotUndef(actual: any, msg?: string, ...args: any[]): assert\n\tnotBool(actual: any, msg?: string, ...args: any[]): assert\n\tnotNum(actual: any, msg?: string, ...args: any[]): assert\n\tnotInt(actual: any, msg?: string, ...args: any[]): assert\n\tnotStr(actual: any, msg?: string, ...args: any[]): assert\n\tnotFn(actual: any, msg?: string, ...args: any[]): assert\n\tnotPrimitive(actual: any, msg?: string, ...args: any[]): assert\n\tnotBoolean(actual: any, msg?: string, ...args: any[]): assert\n\tnotNumber(actual: any, msg?: string, ...args: any[]): assert\n\tnotString(actual: any, msg?: string, ...args: any[]): assert\n\tnotDate(actual: any, msg?: string, ...args: any[]): assert\n\tnotReg(actual: any, msg?: string, ...args: any[]): assert\n\tnotArray(actual: any, msg?: string, ...args: any[]): assert\n\tnotTypedArray(actual: any, msg?: string, ...args: any[]): assert\n\tnotArrayLike(actual: any, msg?: string, ...args: any[]): assert\n\tnotObj(actual: any, msg?: string, ...args: any[]): assert\n\tnotNan(actual: any, msg?: string, ...args: any[]): assert\n\tnotFinite(actual: any, msg?: string, ...args: any[]): assert\n\tthrow(fn: () => any, err: Error | string, msg?: string, ...args: any[]): assert\n\tnotThrow(fn: () => any, err: Error | string, msg?: string, ...args: any[]): assert\n\tnotLess(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\tnotGreater(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\tnotMatch(actual: string, expect: any, msg?: string, ...args: any[]): assert\n\tnotRange(actual: number, start: number, end: number, msg?: string, ...args: any[]): assert\n}\n\nexport const assert = <assert>function assert(msg?: string): never {\n\tthrow new Error(parseMessage(msg || 'Error', arguments, 0))\n}\n\nfunction catchErr(fn): Error {\n\ttry {\n\t\tfn()\n\t} catch (e) {\n\t\treturn e\n\t}\n}\n\nfunction checkErr(expect: Error | string, err: Error): boolean {\n\tlet msg = isStr(expect) ? (expect as string) : (expect as Error).message\n\treturn msg === err.message\n}\nconst ERROR = new Error()\nconst throwMsg = mkMsg(objFormatter(1), 'throw')\nassert.throw = function(fn: () => any, expect: Error | string, msg?: string): assert {\n\tconst err = catchErr(fn)\n\tif (!err || (expect && !checkErr(expect, err))) {\n\t\targuments[0] = err\n\t\t!expect && (arguments[2] = ERROR)\n\t\tthrow new Error(parseMessage(msg || throwMsg[0], arguments, 2))\n\t}\n\treturn assert\n}\n\nassert.notThrow = function(fn: () => any, expect: Error | string, msg?: string): assert {\n\tconst err = catchErr(fn)\n\tif (err && (!expect || !checkErr(expect, err))) {\n\t\targuments[0] = err\n\t\t!expect && (arguments[2] = ERROR)\n\t\tthrow new Error(parseMessage(msg || throwMsg[0], arguments, 2))\n\t}\n\treturn assert\n}\n\nfunction extendAssert<T extends Function>(\n\tname: string,\n\tcondition: string | ((...args: any) => boolean) | [string | ((...args: any) => boolean), string?],\n\targs: string | number | string[],\n\tdmsg: string,\n\tErr?: typeof Error | typeof TypeError | typeof SyntaxError\n): T {\n\tconst params: string[] = isStr(args)\n\t\t\t? (args as string).split(/,/g)\n\t\t\t: isNum(args)\n\t\t\t? makeArray(args as number, i => `arg${i + 1}`)\n\t\t\t: (args as string[]),\n\t\tparamStr = params.join(', '),\n\t\tcond = isArray(condition) ? condition[0] : condition,\n\t\texpr = (isArray(condition) ? condition[1] : '') + (isStr(cond) ? `(${cond})` : `cond(${paramStr})`)\n\n\treturn (assert[name] = createFn(\n\t\t`return function assert${upperFirst(name)}(${paramStr}, msg){\n\tif (${expr})\n\t\tthrow new Err(parseMsg(msg || dmsg, arguments, ${params.length}));\n\treturn assert;\n}`,\n\t\t['Err', 'parseMsg', 'dmsg', 'cond', 'assert']\n\t)(Err || Error, parseMessage, dmsg, cond, assert))\n}\n\ntype APIDescriptor = [\n\tstring | ((...args: any) => boolean), // condition\n\tstring | number | string[], // arguments\n\t[string, string], // expect or [err msg, not err msg]\n\t(typeof Error | typeof TypeError | typeof SyntaxError)?\n]\n\n// [condition, argcount?, [msg, not msg], Error]\nfunction extendAsserts(apis: { [method: string]: APIDescriptor }) {\n\teachObj(apis, (desc: APIDescriptor, name) => {\n\t\tconst condition = desc[0],\n\t\t\targs = desc[1],\n\t\t\tmsg = desc[2],\n\t\t\tErr = desc[3] || TypeError\n\n\t\tmsg[0] && extendAssert(name, [condition, '!'], args, msg[0], Err)\n\t\tmsg[1] && extendAssert('not' + upperFirst(name), condition, args, msg[1], Err)\n\t})\n}\n\nconst NULL = 'null'\nconst UNDEFINED = 'undefined'\nconst BOOLEAN = 'boolean'\nconst NUMBER = 'number'\nconst INTEGER = 'integer'\nconst STRING = 'string'\nconst FUNCTION = 'function'\nconst ARRAY = 'Array'\nconst TYPED_ARRAY = 'TypedArray'\n\nextendAssert('is', '!o', 'o', expectMsg('Exist'))\nextendAssert('not', 'o', 'o', expectMsg('Not Exist'))\nextendAsserts({\n\teq: [eq, 2, mkMsg(objFormatter(1))],\n\tnul: [isNull, 1, mkMsg(NULL)],\n\tnil: [isNil, 1, mkMsg(typeExpect(NULL, UNDEFINED))],\n\tundef: [isUndef, 1, mkMsg(UNDEFINED)],\n\tbool: [isBool, 1, mkMsg(BOOLEAN)],\n\tnum: [isNum, 1, mkMsg(NUMBER)],\n\tint: [isInt, 1, mkMsg(INTEGER)],\n\tstr: [isStr, 1, mkMsg(STRING)],\n\tfn: [isFn, 1, mkMsg(FUNCTION)],\n\tprimitive: [\n\t\tisPrimitive,\n\t\t1,\n\t\tmkMsg(`Primitive type(${typeExpect(NULL, UNDEFINED, BOOLEAN, NUMBER, INTEGER, STRING, FUNCTION)})`)\n\t],\n\tboolean: [isBoolean, 1, mkMsg(packTypeExpect(BOOLEAN))],\n\tnumber: [isNumber, 1, mkMsg(packTypeExpect(NUMBER))],\n\tstring: [isString, 1, mkMsg(packTypeExpect(STRING))],\n\tdate: [isDate, 1, mkMsg('Date')],\n\treg: [isReg, 1, mkMsg('RegExp')],\n\tarray: [isArray, 1, mkMsg(ARRAY)],\n\ttypedArray: [isTypedArray, 1, mkMsg('TypedArray')],\n\tarrayLike: [\n\t\tisArrayLike,\n\t\t1,\n\t\tmkMsg(typeExpect(ARRAY, packTypeExpect(STRING), 'Arguments', TYPED_ARRAY, 'NodeList', 'HTMLCollection'))\n\t],\n\tobj: [isObj, 1, mkMsg('Object')],\n\tnan: [isNaN, 1, mkMsg('NaN')],\n\tfinite: [isFinite, 1, mkMsg('Finite')],\n\tblank: [isBlank, 1, mkMsg('Blank')],\n\tless: ['o<t', 'o,t', mkMsg(objFormatter(1), 'less than')],\n\tgreater: ['o>t', 'o,t', mkMsg(objFormatter(1), 'greater than')],\n\tmatch: ['reg.test(str)', 'str,reg', mkMsg(objFormatter(1), 'match')],\n\trange: ['o>=s&&o<e', 'o,s,e', mkMsg(`[{1} - {2})`)]\n})\n\nfunction mkMsg(expect: string, to?: string): [string, string] {\n\treturn [expectMsg(expect, false, to), expectMsg(expect, true, to)]\n}\nfunction expectMsg(expect: string, not?: boolean, to?: string): string {\n\treturn `Expected ${objFormatter(0)} ${not ? 'not ' : ''}${to || 'to'} ${expect}`\n}\n\nfunction objFormatter(idx) {\n\treturn `{${idx}:.20=\"...\"j}`\n}\n\nfunction packTypeExpect(base: string, all?: boolean): string {\n\treturn all ? typeExpect(base, upperFirst(base)) : upperFirst(base)\n}\nfunction typeExpect(...types: string[]): string\nfunction typeExpect(): string {\n\treturn Array.prototype.join.call(arguments, ' | ')\n}\n","/**\n * Double Linked List\n * @module utility/List\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Mon Dec 10 2018 19:07:47 GMT+0800 (China Standard Time)\n */\n\nimport { bind } from '../fn'\nimport { defPropValue } from '../prop'\nimport { assert } from '../assert'\n\nconst DEFAULT_BINDING = '__this__'\n\ninterface ListNode<T> extends Array<any> {\n\t0: T\n\t1?: ListNode<T>\n\t2?: ListNode<T>\n\t3?: List<T>\n}\n//type ListNode = [ListElement, IListNode, IListNode, List]\n\nexport class List<T> {\n\tstatic readonly binding: string = DEFAULT_BINDING\n\n\treadonly binding: string\n\tprotected head?: ListNode<T>\n\tprotected tail?: ListNode<T>\n\tprotected length: number = 0\n\tprotected scaning: boolean = false\n\tprotected lazyRemoves?: ListNode<T>[]\n\tconstructor(binding?: string) {\n\t\tthis.binding = binding || DEFAULT_BINDING\n\t}\n\tsize(): number {\n\t\treturn this.length\n\t}\n\thas(obj: T): boolean {\n\t\tconst node: ListNode<T> = obj[this.binding]\n\t\treturn node ? node[0] === obj && node[3] === this : false\n\t}\n\tadd(obj: T): number {\n\t\treturn this.__insert(obj, this.tail)\n\t}\n\taddFirst(obj: T): number {\n\t\treturn this.__insert(obj)\n\t}\n\tinsertAfter(obj: T, target?: T): number {\n\t\treturn this.__insert(obj, target && this.__getNode(target))\n\t}\n\tinsertBefore(obj: T, target?: T): number {\n\t\treturn this.__insert(obj, target && this.__getNode(target)[1])\n\t}\n\taddAll(objs: T[]): number {\n\t\treturn this.__insertAll(objs, this.tail)\n\t}\n\taddFirstAll(objs: T[]): number {\n\t\treturn this.__insertAll(objs)\n\t}\n\tinsertAfterAll(objs: T[], target?: T): number {\n\t\treturn this.__insertAll(objs, target && this.__getNode(target))\n\t}\n\tinsertBeforeAll(objs: T[], target?: T): number {\n\t\treturn this.__insertAll(objs, target && this.__getNode(target)[1])\n\t}\n\tprev(obj: T): T {\n\t\treturn this.__siblingObj(obj, 1)\n\t}\n\tnext(obj: T): T {\n\t\treturn this.__siblingObj(obj, 2)\n\t}\n\tfirst(): T {\n\t\tconst node: ListNode<T> = this.head\n\t\treturn node && node[0]\n\t}\n\tlast(): T {\n\t\tconst node: ListNode<T> = this.tail\n\t\treturn node && node[0]\n\t}\n\teach(cb: (obj: T) => boolean | void, scope?: any) {\n\t\tif (this.length) {\n\t\t\tassert.not(this.scaning, 'Recursive calls are not allowed.')\n\t\t\tthis.scaning = true\n\t\t\tcb = bind(cb, scope)\n\t\t\tvar node = this.head\n\t\t\twhile (node) {\n\t\t\t\tif (node[3] === this && cb(node[0]) === false) break\n\t\t\t\tnode = node[2]\n\t\t\t}\n\t\t\tthis.__doLazyRemove()\n\t\t\tthis.scaning = false\n\t\t}\n\t}\n\ttoArray(): T[] {\n\t\tconst array: T[] = new Array(this.length)\n\t\tlet node = this.head,\n\t\t\ti = 0\n\t\twhile (node) {\n\t\t\tif (node[3] === this) array[i++] = node[0]\n\t\t\tnode = node[2]\n\t\t}\n\t\treturn array\n\t}\n\tremove(obj: T): number {\n\t\treturn this.__remove(this.__getNode(obj))\n\t}\n\tpop(){\n\n\t}\n\tclean() {\n\t\tif (this.length) {\n\t\t\tif (this.scaning) {\n\t\t\t\tvar node = this.head\n\t\t\t\twhile (node) {\n\t\t\t\t\tnode[3] === this && this.__lazyRemove(node)\n\t\t\t\t\tnode = node[2]\n\t\t\t\t}\n\t\t\t\tthis.length = 0\n\t\t\t} else {\n\t\t\t\tthis.__clean()\n\t\t\t}\n\t\t}\n\t}\n\ttoJSON(){}\n\n\tprotected __initNode(obj: T): ListNode<T> {\n\t\tconst { binding } = this\n\t\tlet node: ListNode<T> = obj[binding]\n\t\tif (node && node[0] === obj) {\n\t\t\tif (node[3] === this) {\n\t\t\t\tthis.__remove(node)\n\t\t\t\treturn this.__initNode(obj)\n\t\t\t} else if (node[3]) {\n\t\t\t\tassert('Object is still in some List')\n\t\t\t}\n\t\t} else {\n\t\t\tnode = [obj]\n\t\t\tdefPropValue(obj, binding, node, false)\n\t\t}\n\t\tnode[3] = this\n\t\treturn node\n\t}\n\n\tprotected __getNode(obj: T): ListNode<T> {\n\t\tconst node: ListNode<T> = obj[this.binding]\n\t\tassert.is(node && node[3] === this, 'Object is not in this List')\n\t\treturn node\n\t}\n\n\tprotected __siblingObj(obj: T, siblingIdx: number): T {\n\t\tconst node: ListNode<T> = this.__getNode(obj)\n\t\tlet sibling: ListNode<T> = node[siblingIdx]\n\t\tif (sibling) {\n\t\t\twhile (!sibling[3]) {\n\t\t\t\tsibling = sibling[siblingIdx]\n\t\t\t\tif (!sibling) return\n\t\t\t}\n\t\t\treturn sibling[0]\n\t\t}\n\t}\n\n\tprivate __doInsert(nodeHead: ListNode<T>, nodeTail: ListNode<T>, len: number, prev?: ListNode<T>): number {\n\t\tlet next\n\t\tnodeHead[1] = prev\n\t\tif (prev) {\n\t\t\tnodeTail[2] = next = prev[2]\n\t\t\tprev[2] = nodeHead\n\t\t} else {\n\t\t\tnodeTail[2] = next = this.head\n\t\t\tthis.head = nodeHead\n\t\t}\n\t\tif (next) next[1] = nodeTail\n\t\telse this.tail = nodeTail\n\t\treturn (this.length += len)\n\t}\n\n\tprotected __insert(obj: T, prev?: ListNode<T>): number {\n\t\tconst node = this.__initNode(obj)\n\t\treturn this.__doInsert(node, node, 1, prev)\n\t}\n\n\tprotected __insertAll(objs: T[], prev?: ListNode<T>): number {\n\t\tlet l = objs.length\n\t\tif (l) {\n\t\t\tconst head = this.__initNode(objs[0])\n\t\t\tvar __prev = head,\n\t\t\t\ttail = head,\n\t\t\t\ti = 1\n\t\t\tfor (; i < l; i++) {\n\t\t\t\ttail = this.__initNode(objs[i])\n\t\t\t\ttail[1] = __prev\n\t\t\t\t__prev[2] = tail\n\t\t\t\t__prev = tail\n\t\t\t}\n\t\t\treturn this.__doInsert(head, tail, l, prev)\n\t\t}\n\t\treturn -1\n\t}\n\n\tprotected __remove(node: ListNode<T>): number {\n\t\tthis.scaning ? this.__lazyRemove(node) : this.__doRemove(node)\n\t\treturn --this.length\n\t}\n\n\tprotected __lazyRemove(node: ListNode<T>): void {\n\t\tconst { lazyRemoves } = this\n\t\tnode[0][this.binding] = undefined // unbind this node\n\t\tnode[3] = null\n\t\tif (lazyRemoves) {\n\t\t\tlazyRemoves.push(node)\n\t\t} else {\n\t\t\tthis.lazyRemoves = [node]\n\t\t}\n\t}\n\n\tprotected __doLazyRemove() {\n\t\tconst { lazyRemoves } = this\n\t\tif (lazyRemoves) {\n\t\t\tvar len = lazyRemoves.length\n\t\t\tif (len) {\n\t\t\t\tif (this.length) {\n\t\t\t\t\twhile (len--) this.__doRemove(lazyRemoves[len])\n\t\t\t\t} else {\n\t\t\t\t\tthis.__clean()\n\t\t\t\t}\n\t\t\t\tlazyRemoves.length = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected __doRemove(node: ListNode<T>) {\n\t\tconst prev = node[1],\n\t\t\tnext = node[2]\n\t\tif (prev) {\n\t\t\tprev[2] = next\n\t\t} else {\n\t\t\tthis.head = next\n\t\t}\n\t\tif (next) {\n\t\t\tnext[1] = prev\n\t\t} else {\n\t\t\tthis.tail = prev\n\t\t}\n\t\tnode[1] = node[2] = node[3] = null\n\t}\n\n\tprotected __clean() {\n\t\tlet node,\n\t\t\tnext = this.head\n\t\twhile ((node = next)) {\n\t\t\tnext = node[2]\n\t\t\tnode.length = 1\n\t\t}\n\t\tthis.head = undefined\n\t\tthis.tail = undefined\n\t\tthis.length = 0\n\t}\n}\n","/**\n * Function List\n * @module utility/List\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Mon Dec 10 2018 18:48:02 GMT+0800 (China Standard Time)\n */\n\nimport { List } from './List'\nimport { create } from '../create'\nimport { defPropValue } from '../prop'\n\nconst DEFAULT_FN_BINDING = '__id__'\nconst DEFAULT_SCOPE_BINDING = '__id__'\n\ntype FnNode<T extends Function> = [string, T, any, any]\nexport class FnList<T extends Function> {\n\tstatic readonly fnBinding: string = DEFAULT_FN_BINDING\n\tstatic readonly scopeBinding: string = DEFAULT_SCOPE_BINDING\n\n\treadonly fnBinding: string\n\treadonly scopeBinding: string\n\tprivate readonly list: List<FnNode<T>>\n\tprivate nodeMap: { [key: string]: FnNode<T> }\n\n\tconstructor(fnBinding?: string, scopeBinding?: string) {\n\t\tthis.nodeMap = create(null)\n\t\tthis.list = new List()\n\t\tthis.fnBinding = fnBinding || DEFAULT_FN_BINDING\n\t\tthis.scopeBinding = scopeBinding || DEFAULT_SCOPE_BINDING\n\t}\n\tadd(fn: T, scope?: any, data?: any): number {\n\t\tscope = parseScope(scope)\n\t\tconst { list, nodeMap } = this\n\t\tconst id = nodeId(this, fn, scope)\n\t\tlet node = nodeMap[id]\n\t\tif (!node) {\n\t\t\tnode = [id, fn, scope, data]\n\t\t\tvar ret = list.add(node)\n\t\t\tif (ret) nodeMap[id] = node\n\t\t\treturn ret\n\t\t}\n\t\treturn -1\n\t}\n\tremove(fn: T, scope?: any): number {\n\t\tconst { list, nodeMap } = this\n\t\tconst id = nodeId(this, fn, parseScope(scope))\n\t\tconst node = nodeMap[id]\n\t\tif (node) {\n\t\t\tnodeMap[id] = undefined\n\t\t\treturn list.remove(node)\n\t\t}\n\t\treturn -1\n\t}\n\thas(fn: T, scope?: any): boolean {\n\t\treturn !!this.nodeMap[nodeId(this, fn, parseScope(scope))]\n\t}\n\tsize(): number {\n\t\treturn this.list.size()\n\t}\n\tclean() {\n\t\tthis.nodeMap = create(null)\n\t\tthis.list.clean()\n\t}\n\teach(cb: (fn: T, scope: any, data: any) => boolean | void, scope?: any) {\n\t\tcb = cb.bind(scope)\n\t\tthis.list.each(node => cb(node[1], node[2], node[3]))\n\t}\n\ttoJSON(){}\n}\n\nconst DEFAULT_SCOPE_ID = 1\nlet scopeIdGenerator = 1,\n\tfnIdGenerator = 0\n\nfunction nodeId<T extends Function>(list: FnList<T>, fn: T, scope?: any): string {\n\tconst { fnBinding, scopeBinding } = list\n\n\tlet fnId = fn[fnBinding],\n\t\tscopeId = scope ? scope[scopeBinding] : DEFAULT_SCOPE_ID\n\tif (!fnId) fnId = defPropValue(fn, fnBinding, ++fnIdGenerator, false, false, false)\n\tif (!scopeId) scopeId = defPropValue(scope, scopeBinding, ++scopeIdGenerator, false, false, false)\n\treturn `${fnId}&${scopeId}`\n}\n\nfunction parseScope(scope: any): any {\n\treturn !scope ? undefined : scope\n}\n","/**\n * String format\n * @module utility/nextTick\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Mon Dec 10 2018 16:59:56 GMT+0800 (China Standard Time)\n */\nimport { FnList } from './List'\nimport { isFn } from './is'\n\nconst ticks = new FnList()\nlet pending = false\nlet next\n\nfunction executeTick(fn: Function, scope?: any) {\n\tscope ? fn.call(scope) : fn()\n}\n\nfunction flush() {\n\tticks.each(executeTick)\n\tticks.clean()\n\tpending = false\n}\n\nif (isFn(MutationObserver)) {\n\t// chrome18+, safari6+, firefox14+,ie11+,opera15\n\tvar counter = 0,\n\t\tobserver = new MutationObserver(flush),\n\t\ttextNode = document.createTextNode(counter + '')\n\tobserver.observe(textNode, {\n\t\tcharacterData: true\n\t})\n\tnext = function() {\n\t\ttextNode.data = counter + ''\n\t\tcounter = counter ? 0 : 1\n\t}\n} else {\n\tnext = function() {\n\t\tsetTimeout(flush, 0)\n\t}\n}\n\nexport function nextTick(fn: Function, scope?: any) {\n\tticks.add(fn, scope)\n\tif (!pending) {\n\t\tpending = true\n\t\tnext()\n\t}\n}\n\nexport function clearTick(fn: Function, scope?: any) {\n\tticks.remove(fn, scope)\n}\n","/**\n * utilities for ast builder\n *\n * @module utility/AST\n * @author Tao Zeng (tao.zeng.zt@qq.com)\n * @created 2018-11-09 13:22:51\n * @modified 2018-11-09 13:22:51 by Tao Zeng (tao.zeng.zt@qq.com)\n */\nimport { isStr, isArray, isInt } from '../is'\n\n/**\n * each char codes\n */\nexport function eachCharCodes(codes: number | string | any[], ignoreCase: boolean, cb: (code: number) => void) {\n\tif (isStr(codes)) {\n\t\tvar i = (codes as any).length\n\t\twhile (i--) eachCharCode((codes as any).charCodeAt(i), ignoreCase, cb)\n\t} else if (isArray(codes)) {\n\t\tvar i = (codes as any).length\n\t\twhile (i--) eachCharCodes((codes as any)[i], ignoreCase, cb)\n\t} else if (isInt(codes)) {\n\t\teachCharCode(codes as any, ignoreCase, cb)\n\t}\n}\nfunction eachCharCode(code: number, ignoreCase: boolean, cb: (code: number) => void): void {\n\tcb(code)\n\tif (ignoreCase) {\n\t\tif (code <= 90) {\n\t\t\tif (code >= 65) cb(code + 32)\n\t\t} else if (code <= 122) {\n\t\t\tcb(code - 32)\n\t\t}\n\t}\n}\n","/**\n * @module common/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:06:22 GMT+0800 (China Standard Time)\n * @modified Sat Dec 15 2018 16:34:01 GMT+0800 (China Standard Time)\n */\nimport { MatchContext } from './MatchContext'\nimport { eachCharCodes } from './util'\nimport { assert } from '../assert'\nimport { isStr, isBool } from '../is'\nimport { PROTOTYPE, CONSTRUCTOR } from '../consts'\n\nexport class MatchError {\n\treadonly $ruleErr: boolean = true\n\treadonly rule: Rule\n\treadonly context: MatchContext\n\tsource: MatchError\n\treadonly capturable: boolean\n\tmsg: string\n\tpos: number\n\tconstructor(msg: string, capturable: boolean, source: MatchError, context: MatchContext, rule: Rule) {\n\t\t!isBool(capturable) && (capturable = rule.capturable)\n\t\tthis.capturable = capturable && source ? source.capturable : capturable\n\t\tthis.msg = msg\n\t\tthis.source = source\n\t\tthis.context = context\n\t\tthis.rule = rule\n\t\tthis.pos = context.currPos()\n\t}\n}\n\nexport type onMatchCallback = (data: any, len: number, context: MatchContext, rule: Rule) => MatchError | string | void\nexport type onErrorCallback = (err: MatchError, context: MatchContext, rule: Rule) => MatchError | string | void\n\nfunction defaultErr(err: MatchError) {\n\treturn err\n}\n\nfunction defaultMatch(data: any, len: number, context: MatchContext) {\n\tcontext.add(data)\n}\n\nlet idGen = 0\n/**\n * Abstract Rule\n */\nexport class Rule {\n\treadonly $rule: boolean = true\n\t// rule type (for debug)\n\tprotected type: string\n\t// rule id\n\treadonly id: number\n\t// rule expression (for debug)\n\tprotected expr: string\n\t// rule EXPECT content (for debug)\n\tprotected EXPECT: string\n\t// matched callback\n\treadonly onMatch: onMatchCallback\n\t// error callback\n\treadonly onErr: onErrorCallback\n\t// index of start codes\n\tprotected startCodeIdx: any[]\n\t// start codes\n\tprotected startCodes: number[]\n\n\t/**\n\t * @param name\t\t\trule name\n\t * @param capturable\terror is capturable\n\t * @param onMatch\t\tcallback on matched, allow modify the match result or return an error\n\t * @param onErr\t\t\tcallback on Error, allow to ignore error or modify error message or return new error\n\t */\n\tconstructor(\n\t\tpublic readonly name: string,\n\t\tpublic readonly capturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\t) {\n\t\tthis.id = idGen++\n\t\tthis.onMatch = onMatch || defaultMatch\n\t\tthis.onErr = onErr || defaultErr\n\t}\n\n\t/**\n\t * create Error\n\t * @param msg \t\t\terror message\n\t * @param context \t\tmatch context\n\t * @param capturable \tis capturable error\n\t * @param src \t\t\tsource error\n\t */\n\tmkErr(msg: string, context: MatchContext, source?: MatchError, capturable?: boolean): MatchError {\n\t\treturn new MatchError(msg, capturable, source, context, this)\n\t}\n\n\t/**\n\t * match fail\n\t * @param msg \t\t\terror message\n\t * @param context \t\tmatch context\n\t * @param capturable \tis capturable error\n\t * @param src \t\t\tsource error\n\t * @return Error|void: may ignore Error in the error callback\n\t */\n\tprotected error(msg: string, context: MatchContext, src?: MatchError, capturable?: boolean): MatchError {\n\t\tconst err = this.mkErr(msg, context, src, capturable)\n\t\tconst userErr = this.onErr(err, context, this)\n\t\tif (userErr) return isStr(userErr) ? ((err[0] = userErr as string), err) : (userErr as MatchError)\n\t}\n\n\t/**\n\t * match success\n\t * > attach the matched result by match callback\n\t * @param data \t\tmatched data\n\t * @param len  \t\tmatched data length\n\t * @param context \tmatch context\n\t * @return Error|void: may return Error in the match callback\n\t */\n\tprotected matched(data: any, len: number, context: MatchContext): MatchError {\n\t\tconst err = this.onMatch(data, len, context, this)\n\t\tif (err) return (err as any).$ruleErr ? (err as MatchError) : this.mkErr(String(err), context, null, false)\n\t}\n\n\t/**\n\t * match\n\t * @param context match context\n\t */\n\tmatch(context: MatchContext): MatchError {\n\t\treturn assert()\n\t}\n\n\t/**\n\t * get start char codes\n\t */\n\tgetStart(stack?: number[]): number[] {\n\t\treturn this.startCodes\n\t}\n\n\t/**\n\t * prepare test before match\n\t */\n\ttest(context: MatchContext): boolean {\n\t\treturn context.nextCode() !== 0\n\t}\n\n\tprotected startCodeTest(context: MatchContext): boolean {\n\t\tconst code = context.nextCode()\n\t\treturn code !== 0 && !!this.startCodeIdx[code]\n\t}\n\n\tprotected setStartCodes(start: number | string | any[], ignoreCase?: boolean) {\n\t\tconst codes: number[] = [],\n\t\t\tindex: number[] = []\n\t\teachCharCodes(start, ignoreCase, code => {\n\t\t\tif (!index[code]) {\n\t\t\t\tcodes.push(code)\n\t\t\t\tindex[code] = code\n\t\t\t}\n\t\t})\n\t\tthis.startCodes = codes\n\t\tthis.setCodeIdx(index)\n\t}\n\n\tprotected setCodeIdx(index: any[]) {\n\t\tthis.startCodeIdx = index\n\t\tthis.test = index && index.length > 1 ? this.startCodeTest : Rule[PROTOTYPE].test\n\t}\n\n\t// for debug \n\t/**\n\t * make rule expression\n\t * @param expr expression text\n\t */\n\tprotected mkExpr(expr: string): string {\n\t\treturn `<${this.type}: ${expr}>`\n\t}\n\n\t/**\n\t * set rule expression\n\t * \t\t1. make rule expression\n\t * \t\t2. make Expect text\n\t */\n\tprotected setExpr(expr: string) {\n\t\tthis.expr = this.mkExpr(expr)\n\t\tthis.EXPECT = `Expect: ${expr}`\n\t}\n\n\tgetExpr(stack?: number[]): string {\n\t\treturn this.name || this.expr\n\t}\n\n\t/**\n\t * toString by name or expression\n\t */\n\ttoString(): string {\n\t\treturn this.getExpr()\n\t}\n}\n","/**\n * @module common/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:06:22 GMT+0800 (China Standard Time)\n * @modified Sat Dec 15 2018 18:43:41 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, MatchError, onMatchCallback, onErrorCallback } from './Rule'\nimport { MatchContext } from './MatchContext'\n\n/**\n * Match Rule Interface\n */\nexport class MatchRule extends Rule {\n\tprotected readonly start: number[]\n\tprotected readonly index: number[]\n\tprotected readonly ignoreCase: boolean\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param start \t\tstart char codes, prepare test by start char codes before match\n\t * @param ignoreCase\tignore case for the start char codes\n\t * @param capturable\terror is capturable\n\t * @param onMatch\t\tmatch callback\n\t * @param onErr\t\t\terror callback\n\t */\n\tconstructor(\n\t\tname: string,\n\t\tstart: number | string | any[],\n\t\tignoreCase: boolean,\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\t) {\n\t\tsuper(name, capturable, onMatch, onErr)\n\t\tthis.ignoreCase = ignoreCase\n\t\tthis.setStartCodes(start, ignoreCase)\n\t}\n\n\t/**\n\t * consume matched result\n\t * @param data \t\tmatched result\n\t * @param len \t\tmatched chars\n\t * @param context \tmatch context\n\t */\n\tcomsume(data: string | string[], len: number, context: MatchContext): MatchError {\n\t\tcontext.advance(len)\n\t\treturn this.matched(data, len, context)\n\t}\n}\n","/**\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 11 2018 15:36:42 GMT+0800 (China Standard Time)\n * @modified Sat Dec 15 2018 14:19:44 GMT+0800 (China Standard Time)\n */\n\nimport { onMatchCallback, onErrorCallback } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { MatchRule } from './MatchRule'\nimport { char } from '../string'\n\n/**\n * match a character in the allowed list\n * > well match any character if the allowed list is empty\n *\n * > must call test() before match\n */\nexport class CharMatchRule extends MatchRule {\n\ttype: string = 'Character'\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param allows \t\tallowed character codes for match\n\t * \t\t\t\t\t\twell match any character if the allowed list is empty\n\t * @param ignoreCase\tignore case for the allowed character codes\n\t * @param capturable\terror is capturable\n\t * @param onMatch\t\tmatch callback\n\t * @param onErr\t\t\terror callback\n\t */\n\tconstructor(\n\t\tname: string,\n\t\tallows: number | string | any[],\n\t\tignoreCase: boolean,\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\t) {\n\t\tsuper(name, allows, ignoreCase, capturable, onMatch, onErr)\n\t\tconst codes = this.start\n\n\t\tlet i = codes.length,\n\t\t\texpr = '*'\n\t\tif (i) {\n\t\t\tconst chars = []\n\t\t\twhile (i--) chars[i] = char(codes[i])\n\t\t\texpr = `\"${chars.join('\" | \"')}\"`\n\t\t}\n\t\tthis.setExpr(expr)\n\t}\n\tmatch(context: MatchContext) {\n\t\treturn this.comsume(context.nextChar(), 1, context)\n\t}\n}\n","/**\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 11 2018 15:36:42 GMT+0800 (China Standard Time)\n * @modified Sat Dec 15 2018 11:53:49 GMT+0800 (China Standard Time)\n */\n\nimport { MatchError, onMatchCallback, onErrorCallback } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { MatchRule } from './MatchRule'\nimport { regStickySupport } from '../reg'\nimport { isInt } from '../is'\nimport { createFn } from '../fn'\nimport { map, mapArray } from '../collection'\n\n/**\n * match string by RegExp\n *\n * optimization:\n * - Priority use sticky mode {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky}\n\n */\nexport class RegMatchRule extends MatchRule {\n\treadonly regexp: RegExp\n\treadonly pick: boolean | number\n\tprivate picker: (m: string[]) => string | string[]\n\tprivate spicker: (buff: string, start: number, end: number) => string\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param regexp\t\tregular\n\t * @param pick\t\t\tpick regular matching results\n\t * \t\t\t\t\t\t    0: pick results[0] (optimize: test and substring in sticky mode)\n\t * \t\t\t\t\t\t  > 0: pick results[{pick}]\n\t * \t\t\t\t\t\t  < 0: pick first non-blank string from 1 to -{pick} index on results\n\t * \t\t\t\t\t\t true: pick results\n\t * \t\t\t\t\t\tfalse: not pick result, result is null (optimize: just test string in sticky mode)\n\t * @param start\t\t\tstart character codes in the regular, optimize performance by start character codes\n\t * @param capturable\terror is capturable\n\t * @param onMatch\t\tmatch callback\n\t * @param onErr\t\t\terror callback\n\t */\n\tconstructor(\n\t\tname: string,\n\t\tregexp: RegExp,\n\t\tpick: boolean | number,\n\t\tstart: number | string | any[],\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\t) {\n\t\tpick = pick === false || isInt(pick) ? pick : !!pick || 0\n\n\t\tconst sticky = regStickySupport && !pick, // use exec mode when need pick match group data\n\t\t\tpattern = regexp.source,\n\t\t\tignoreCase = regexp.ignoreCase\n\n\t\t// always wrapping in a none capturing group preceded by '^' to make sure\n\t\t// matching can only work on start of input. duplicate/redundant start of\n\t\t// input markers have no meaning (/^^^^A/ === /^A/)\n\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky\n\t\t// When the y flag is used with a pattern, ^ always matches only at the\n\t\t// beginning of the input, or (if multiline is true) at the beginning of a\n\t\t// line.\n\t\tregexp = new RegExp(\n\t\t\tsticky ? pattern : `^(?:${pattern})`,\n\t\t\t(ignoreCase ? 'i' : '') + (regexp.multiline ? 'm' : '') + (sticky ? 'y' : '')\n\t\t)\n\n\t\tsuper(name, start, ignoreCase, capturable, onMatch, onErr)\n\t\tthis.type = 'RegExp'\n\t\tthis.regexp = regexp\n\t\tthis.pick = pick\n\t\tthis.match = sticky ? this.stickyMatch : this.execMatch\n\n\t\tsticky ? (this.spicker = pick === false ? pickNone : pickTestStr) : (this.picker = mkPicker(pick))\n\n\t\tthis.setExpr(pattern)\n\t}\n\tmatch(context: MatchContext) {\n\t\treturn this.comsume(context.nextChar(), 1, context)\n\t}\n\t/**\n\t * match on sticky mode\n\t */\n\tstickyMatch(context: MatchContext): MatchError {\n\t\tconst reg = this.regexp,\n\t\t\tbuff = context.getBuff(),\n\t\t\tstart = context.getOffset()\n\t\treg.lastIndex = start\n\t\treturn reg.test(buff)\n\t\t\t? this.comsume(this.spicker(buff, start, reg.lastIndex), reg.lastIndex - start, context)\n\t\t\t: this.error(this.EXPECT, context)\n\t}\n\t/**\n\t * match on exec mode\n\t */\n\texecMatch(context: MatchContext): MatchError {\n\t\tconst m = this.regexp.exec(context.getBuff(true))\n\t\tif (m) {\n\t\t\treturn this.comsume(this.picker(m), m[0].length, context)\n\t\t}\n\t\treturn this.error(this.EXPECT, context)\n\t}\n}\n\nfunction mkPicker(pick: number | boolean): (m: string[]) => string | string[] {\n\treturn pick === false\n\t\t? pickNone\n\t\t: pick === true\n\t\t? pickAll\n\t\t: pick >= 0\n\t\t? (m: string[]): string => m[pick as number]\n\t\t: createFn(`return ${mapArray(new Array(-pick), (v, i) => `m[${i + 1}]`).join(' || ')}`, ['m'])\n}\n\nfunction pickNone(): string {\n\treturn null\n}\n\nfunction pickAll(m: string[]): string[] {\n\treturn m\n}\n\nfunction pickTestStr(buff: string, start: number, end: number): string {\n\treturn buff.substring(start, end)\n}\n","/**\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 11 2018 15:36:42 GMT+0800 (China Standard Time)\n * @modified Sat Dec 15 2018 18:14:27 GMT+0800 (China Standard Time)\n */\n\nimport { onMatchCallback, onErrorCallback } from './Rule'\nimport { RegMatchRule } from './RegMatchRule'\nimport { reEscape } from '../reg'\n\nexport class StringMatchRule extends RegMatchRule {\n\ttype: string = 'String'\n\tconstructor(\n\t\tname: string,\n\t\tstr: string,\n\t\tignoreCase: boolean,\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\t) {\n\t\tsuper(name, new RegExp(reEscape(str), ignoreCase ? 'i' : ''), 0, str.charCodeAt(0), capturable, onMatch, onErr)\n\t\tthis.setExpr(str)\n\t}\n}\n","/**\n * @module common/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:06:22 GMT+0800 (China Standard Time)\n * @modified Sat Dec 15 2018 19:43:41 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, MatchError, onMatchCallback, onErrorCallback } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { assert } from '../assert'\nimport { idxOfArray } from '../collection'\nimport { PROTOTYPE } from '../consts'\n\nexport type ruleBuilder = (rule: Rule) => Rule[]\n\n/**\n * complex rule interface\n *\n */\nexport class ComplexRule extends Rule {\n\tprotected split: string\n\tprotected EXPECTS: string[]\n\tprivate builder: ruleBuilder\n\tprotected rules: Rule[]\n\tprotected readonly repeat: [number, number]\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param builder \t\tcallback of build rules\n\t * @param capturable\terror is capturable\n\t * @param onMatch\t\tmatch callback\n\t * @param onErr\t\t\terror callback\n\t */\n\tconstructor(\n\t\tname: string,\n\t\ttype: string,\n\t\trepeat: [number, number],\n\t\tbuilder: ruleBuilder,\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\t) {\n\t\tsuper(name, capturable, onMatch, onErr)\n\t\tthis.builder = builder\n\n\t\tif (!(repeat[0] >= 0)) repeat[0] = 0\n\t\tif (!(repeat[1] > 0)) repeat[1] = 1e5\n\t\tassert.notGreater(repeat[0], repeat[1])\n\t\tthis.repeat = [repeat[0], repeat[1]]\n\t\tif (repeat[0] === repeat[1] && repeat[0] === 1) {\n\t\t\tthis.match = this.repeatMatch\n\t\t} else {\n\t\t\ttype = `${type}[${repeat[0]}${\n\t\t\t\trepeat[0] === repeat[1] ? '' : ` - ${repeat[1] === 1e5 ? 'MAX' : repeat[1]}`\n\t\t\t}]`\n\t\t}\n\t\tthis.type = type\n\t}\n\tprotected repeatMatch(context: MatchContext): MatchError {\n\t\treturn assert()\n\t}\n\tinit(): Rule[] {\n\t\tconst rules = this.builder(this)\n\t\tlet i = rules && rules.length\n\n\t\tassert.is(i, `Require Complex Rules`)\n\n\t\tthis.rules = rules\n\t\tthis.builder = null\n\n\t\tconst names = this.rnames(rules)\n\n\t\tthis.setExpr(names.join(this.split))\n\n\t\twhile (i--) names[i] = `Expect[${i}]: ${names[i]}`\n\t\tthis.EXPECTS = names\n\n\t\treturn rules\n\t}\n\n\tgetRules(): Rule[] {\n\t\treturn this.rules || this.init()\n\t}\n\n\tgetStart(stack?: number[]): number[] {\n\t\tconst { id, startCodes } = this\n\t\treturn startCodes\n\t\t\t? startCodes\n\t\t\t: (stack && ~idxOfArray(stack, id)) || this.rules\n\t\t\t? []\n\t\t\t: (this.init(), this.startCodes)\n\t}\n\n\tconsume(context: MatchContext): MatchError {\n\t\tconst err = this.matched(context.data, context.len(), context)\n\t\t!err && context.commit()\n\t\treturn err\n\t}\n\n\tprivate rnames(rules: Rule[], stack?: number[]): string[] {\n\t\tlet i = rules.length\n\t\tconst names: string[] = new Array(i),\n\t\t\tid = this.id\n\t\twhile (i--) names[i] = rules[i].getExpr(stack ? stack.concat(id) : [id])\n\t\treturn names\n\t}\n\n\tgetExpr(stack?: number[]): string {\n\t\tconst { id, name } = this\n\t\tlet i: number\n\n\t\treturn name\n\t\t\t? name\n\t\t\t: stack\n\t\t\t? ((i = idxOfArray(stack, id)), ~i)\n\t\t\t\t? `<${this.type} -> $${stack[i]}>`\n\t\t\t\t: this.mkExpr(this.rnames(this.getRules(), stack).join(this.split))\n\t\t\t: this.expr\n\t}\n}\n","/**\n *\n * @module common/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 27 2018 19:05:48 GMT+0800 (China Standard Time)\n * @modified Sat Dec 15 2018 18:03:08 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, onMatchCallback, onErrorCallback, MatchError } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { ComplexRule, ruleBuilder } from './ComplexRule'\n\n/**\n * and complex rule interface\n *\n */\nexport class AndRule extends ComplexRule {\n\ttype: 'And'\n\tsplit: ' '\n\tconstructor(\n\t\tname: string,\n\t\trepeat: [number, number],\n\t\tbuilder: ruleBuilder,\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\t) {\n\t\tsuper(name, 'And', repeat, builder, capturable, onMatch, onErr)\n\t}\n\tinit(): Rule[] {\n\t\tconst rules = super.init()\n\t\tthis.setStartCodes(rules[0].getStart([this.id]))\n\t\treturn rules\n\t}\n\tmatch(context: MatchContext): MatchError {\n\t\tconst rules = this.getRules(),\n\t\t\tlen = rules.length,\n\t\t\tctx = context.create()\n\t\tlet err: MatchError,\n\t\t\ti: number = 0\n\t\tfor (; i < len; i++) if ((err = this.testRule(rules[i], i, ctx))) return err\n\t\treturn this.consume(ctx)\n\t}\n\tprotected repeatMatch(context: MatchContext): MatchError {\n\t\tconst rules = this.getRules(),\n\t\t\tlen = rules.length,\n\t\t\t[min, max] = this.repeat,\n\t\t\tctx = context.create()\n\n\t\tlet err: MatchError,\n\t\t\trepeat: number = 0,\n\t\t\ti: number,\n\t\t\tmlen: number,\n\t\t\tdlen: number\n\n\t\tout: for (; repeat < max; repeat++) {\n\t\t\tdlen = ctx.dataLen()\n\t\t\tmlen = ctx.len()\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tif ((err = this.testRule(rules[i], i, ctx))) {\n\t\t\t\t\tif (repeat < min) return err\n\t\t\t\t\tctx.reset(mlen, dlen)\n\t\t\t\t\tbreak out\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.consume(ctx)\n\t}\n\ttestRule(rule: Rule, i: number, ctx: MatchContext): MatchError {\n\t\tlet err\n\t\treturn (!rule.test(ctx) || (err = rule.match(ctx))) && (err = this.error(this.EXPECTS[i], ctx, err))\n\t}\n}\n","/**\n *\n * @module common/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 27 2018 19:05:48 GMT+0800 (China Standard Time)\n * @modified Sat Dec 15 2018 18:03:34 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, onMatchCallback, onErrorCallback, MatchError } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { ComplexRule, ruleBuilder } from './ComplexRule'\nimport { eachCharCodes } from './util'\n\n/**\n * and complex rule interface\n *\n */\nexport class OrRule extends ComplexRule {\n\tstartCodeIdx: Rule[][]\n\ttype: 'Or'\n\tsplit: ' | '\n\tindex: Rule[][]\n\tconstructor(\n\t\tname: string,\n\t\trepeat: [number, number],\n\t\tbuilder: ruleBuilder,\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\t) {\n\t\tsuper(name, 'And', repeat, builder, capturable, onMatch, onErr)\n\t}\n\tinit(): Rule[] {\n\t\tconst rules = super.init(),\n\t\t\tlen = rules.length,\n\t\t\tid = this.id,\n\t\t\tstarts: number[] = [], // all distinct start codes\n\t\t\trStarts: number[][] = [], // start codes per rule\n\t\t\tindex: Rule[][] = [\n\t\t\t\t[] // rules which without start code\n\t\t\t]\n\n\t\tlet i: number, j: number, k: Rule[] & { idx: number }, codes: number[]\n\n\t\t// get start codes of all rules\n\t\tfor (i = 0; i < len; i++) {\n\t\t\trStarts[i] = [] // init rule start codes\n\t\t\teachCharCodes(rules[i].getStart([id]), false, code => {\n\t\t\t\trStarts[i].push(code) // append to rule start codes\n\t\t\t\tif (!index[code]) {\n\t\t\t\t\tindex[code] = [] // init start code index\n\t\t\t\t\tstarts.push(code) // append to all start codes\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\t// fill index\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tcodes = rStarts[i] // append rule to start code index by rule start codes\n\t\t\tif (!codes.length) {\n\t\t\t\t// rule without start code\n\t\t\t\tindex[0].push(rules[i]) // append rule to index[0]\n\t\t\t\tcodes = starts // append rule to start code index by all start codes\n\t\t\t}\n\n\t\t\t// append rule to start code index (by rule start codes or all start codes)\n\t\t\tj = codes.length\n\t\t\twhile (j--) {\n\t\t\t\tk = index[codes[j]] as Rule[] & { idx: number }\n\t\t\t\tif (k.idx !== i) {\n\t\t\t\t\t// deduplication\n\t\t\t\t\tk.push(rules[i]) // append rules[i] to start code index[codes[j]]\n\t\t\t\t\tk.idx = i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// rule have unkown start code when got unkown start code from any rules\n\t\tthis.startCodes = index[0].length ? [] : starts\n\n\t\tthis.index = starts.length && index\n\t\tstarts.length && !index[0].length && this.setCodeIdx(index)\n\t\treturn rules\n\t}\n\tmatch(context: MatchContext): MatchError {\n\t\tconst { index } = this\n\t\tconst rules: Rule[] = index ? index[context.nextCode()] || index[0] : this.getRules(),\n\t\t\tlen = rules.length,\n\t\t\tctx = context.create()\n\t\tlet err: MatchError,\n\t\t\tupErr: MatchError,\n\t\t\ti = 0\n\t\tfor (; i < len; i++) {\n\t\t\terr = rules[i].match(ctx) || this.consume(ctx)\n\t\t\tif (!err) return\n\t\t\tif (!err.capturable) {\n\t\t\t\tupErr = err\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif (!upErr || err.pos >= upErr.pos) upErr = err\n\t\t\tctx.reset(0, 0)\n\t\t}\n\t\treturn this.error(this.EXPECT, ctx, upErr)\n\t}\n\tprotected repeatMatch(context: MatchContext): MatchError {\n\t\tconst { index } = this\n\t\tconst [min, max] = this.repeat,\n\t\t\tctx = context.create()\n\n\t\tlet rules: Rule[],\n\t\t\tlen: number,\n\t\t\terr: MatchError,\n\t\t\tupErr: MatchError,\n\t\t\trepeat: number = 0,\n\t\t\ti: number,\n\t\t\tmlen: number,\n\t\t\tdlen: number\n\n\t\tif (!index) {\n\t\t\trules = this.getRules()\n\t\t\tlen = rules.length\n\t\t}\n\n\t\tout: for (; repeat < max; repeat++) {\n\t\t\tif (index) {\n\t\t\t\trules = index[ctx.nextCode()] || index[0]\n\t\t\t\tlen = rules.length\n\t\t\t}\n\t\t\tif (len) {\n\t\t\t\tdlen = ctx.dataLen()\n\t\t\t\tmlen = ctx.len()\n\t\t\t\tupErr = null\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\terr = rules[i].match(ctx)\n\t\t\t\t\tif (!err) continue out\n\t\t\t\t\tif (!err.capturable) {\n\t\t\t\t\t\tupErr = err\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tif (!upErr || err.pos >= upErr.pos) upErr = err\n\t\t\t\t\tctx.reset(mlen, dlen)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (repeat < min) return this.error(this.EXPECT, ctx, upErr)\n\t\t}\n\t\treturn this.consume(ctx)\n\t}\n}\n","/**\n *\n * @module common/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:58:52 GMT+0800 (China Standard Time)\n * @modified Sat Dec 15 2018 20:18:48 GMT+0800 (China Standard Time)\n */\nexport * from './Rule'\nexport * from './MatchRule'\nexport * from './CharMatchRule'\nexport * from './RegMatchRule'\nexport * from './StringMatchRule'\nexport * from './ComplexRule'\nexport * from './AndRule'\nexport * from './OrRule'\n\nimport { ruleBuilder } from './ComplexRule'\nimport { isObj, isReg, isStr, isBool, isNum, isInt, isArray, isArrayLike, isFn } from '../is'\nimport { makeMap, mapArray, SKIP } from '../collection'\nimport { CharMatchRule } from './CharMatchRule'\nimport { StringMatchRule } from './StringMatchRule'\nimport { RegMatchRule } from './RegMatchRule'\nimport { onMatchCallback, onErrorCallback, Rule } from './Rule'\nimport { MatchRule } from './MatchRule'\nimport { AndRule } from './AndRule'\nimport { OrRule } from './OrRule'\nimport { assert } from '../assert'\n\n//========================================================================================\n/*                                                                                      *\n *                                  match rule builder                                  *\n *                                                                                      */\n//========================================================================================\n\n// named regexp match api \nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tpick?: boolean | number,\n\tstartCodes?: number | string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tstartCodes?: number | string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(name: string, pattern: RegExp, onMatch?: onMatchCallback, onErr?: onErrorCallback): MatchRule\n\n// regexp match api \nexport function match(\n\tpattern: RegExp,\n\tpick?: boolean | number,\n\tstartCodes?: number | string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tstartCodes?: number | string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(pattern: RegExp, onMatch?: onMatchCallback, onErr?: onErrorCallback): MatchRule\n\n// named string match api \nexport function match(\n\tname: string,\n\tpattern: number | string | any[],\n\tignoreCase?: boolean,\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(\n\tname: string,\n\tpattern: number | string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(\n\tname: string,\n\tpattern: number | string | any[],\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\n// string match api \nexport function match(\n\tpattern: number | string | any[],\n\tignoreCase?: boolean,\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(\n\tpattern: number | string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(pattern: number | string | any[], onMatch?: onMatchCallback, onErr?: onErrorCallback): MatchRule\n\nexport function match(desc: MatchRuleDescriptor): MatchRule\n\nexport function match(o): MatchRule {\n\treturn mkMatch(isObj(o) ? o : arguments)\n}\n\ntype MatchRuleDescriptor = {\n\tname: string\n\tpattern: RegExp | number | string | any[]\n\tpick: boolean | number\n\tstartCodes: number | string | any[]\n\tignoreCase: boolean\n\tcapturable: boolean\n\tonMatch: onMatchCallback\n\tonErr: onErrorCallback\n}\nfunction mkMatch(args: IArguments | any[] | MatchRuleDescriptor): MatchRule {\n\tlet name: string,\n\t\tpattern: number | string | any[],\n\t\tregexp: RegExp,\n\t\tpick: boolean | number = 0,\n\t\tstartCodes: number | string | any[],\n\t\tignoreCase: boolean = false,\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\tif (isArrayLike(args)) {\n\t\tvar i = 2\n\n\t\tif (isMatchPattern(args[1])) {\n\t\t\tname = args[0]\n\t\t\tisReg(args[1]) ? (regexp = args[1]) : (pattern = args[1])\n\t\t} else if (isMatchPattern(args[0])) {\n\t\t\ti = 1\n\t\t\tisReg(args[0]) ? (regexp = args[0]) : (pattern = args[0])\n\t\t}\n\n\t\tif (regexp) {\n\t\t\tif (isBool(args[i]) || isInt(args[i])) pick = args[i++]\n\t\t\tif (isStrOrCodes(pattern)) startCodes = args[i++]\n\t\t} else {\n\t\t\tif (isBool(args[i])) ignoreCase = args[i++]\n\t\t}\n\t\tif (isBool(args[i])) capturable = args[i++]\n\t\tonMatch = args[i++]\n\t\tonErr = args[i++]\n\t} else if (isObj(args)) {\n\t\tconst desc = args as MatchRuleDescriptor,\n\t\t\tp = desc.pattern\n\t\tif (isReg(p)) {\n\t\t\tregexp = p as RegExp\n\t\t\tpick = desc.pick\n\t\t\tstartCodes = desc.startCodes\n\t\t} else if (isMatchPattern(p)) {\n\t\t\tpattern = p as number | string | any[]\n\t\t\tignoreCase = desc.ignoreCase\n\t\t}\n\t\tname = desc.name\n\t\tcapturable = desc.capturable\n\t\tonMatch = desc.onMatch\n\t\tonErr = desc.onErr\n\t}\n\n\treturn regexp\n\t\t? regMatch(name, regexp, pick, startCodes, capturable, onMatch, onErr)\n\t\t: pattern\n\t\t? strMatch(name, pattern, ignoreCase, capturable, onMatch, onErr)\n\t\t: null\n}\n\nfunction isStrOrCodes(pattern): boolean {\n\treturn isStr(pattern) || isNum(pattern) || isArray(pattern)\n}\nfunction isMatchPattern(pattern): boolean {\n\treturn isReg(pattern) || isStrOrCodes(pattern)\n}\n\nfunction strMatch(\n\tname: string,\n\tpattern: string | number | any[],\n\tignoreCase: boolean,\n\tcapturable: boolean,\n\tonMatch: onMatchCallback,\n\tonErr: onErrorCallback\n) {\n\tconst C = isStr(pattern) && (pattern as string).length <= 1 ? StringMatchRule : CharMatchRule\n\treturn new C(name, pattern, ignoreCase, capturable, onMatch, onErr)\n}\n\nconst REG_ESPEC_CHARS = makeMap('dDsStrnt0cbBfvwW', 1, '')\n\nfunction regMatch(\n\tname: string,\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tstartCodes: number | string | any[],\n\tcapturable: boolean,\n\tonMatch: onMatchCallback,\n\tonErr: onErrorCallback\n) {\n\tconst source = pattern.source\n\tif (!pick) {\n\t\tvar c: string | 0 = 0\n\t\tif (source.length == 1 && source !== '^' && source !== '$') {\n\t\t\tc = source === '.' ? '' : source\n\t\t} else if (source.length == 2 && source[0] === '\\\\' && REG_ESPEC_CHARS[source[1]]) {\n\t\t\tc = source[1]\n\t\t}\n\t\tif (c != 0) return strMatch(name, c as string, pattern.ignoreCase, capturable, onMatch, onErr)\n\t}\n\treturn new RegMatchRule(name, pattern, pick, startCodes, capturable, onMatch, onErr)\n}\n//========================================================================================\n/*                                                                                      *\n *                                   and rule builder                                   *\n *                                                                                      */\n//========================================================================================\n\nexport function and(\n\tname: string,\n\trules: ruleBuilder | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(\n\tname: string,\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(\n\tname: string,\n\trules: ruleBuilder | any[],\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\n\nexport function and(\n\trules: ruleBuilder | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(rules: ruleBuilder | any[], onMatch?: onMatchCallback, onErr?: onErrorCallback): AndRule\nexport function and(desc: ComplexRuleDescriptor): AndRule\n\nexport function and(o): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [1, 1])\n}\n\nexport function any(\n\tname: string,\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function any(\n\tname: string,\n\trules: ruleBuilder | any[],\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\n\nexport function any(\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function any(rules: ruleBuilder | any[], onMatch?: onMatchCallback, onErr?: onErrorCallback): AndRule\nexport function any(desc: ComplexRuleDescriptor): AndRule\nexport function any(o): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [1, -1])\n}\n\nexport function many(\n\tname: string,\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function many(\n\tname: string,\n\trules: ruleBuilder | any[],\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\n\nexport function many(\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function many(rules: ruleBuilder | any[], onMatch?: onMatchCallback, onErr?: onErrorCallback): AndRule\nexport function many(desc: ComplexRuleDescriptor): AndRule\nexport function many(o): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [0, -1])\n}\n\nexport function option(\n\tname: string,\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function option(\n\tname: string,\n\trules: ruleBuilder | any[],\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\n\nexport function option(\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function option(rules: ruleBuilder | any[], onMatch?: onMatchCallback, onErr?: onErrorCallback): AndRule\nexport function option(desc: ComplexRuleDescriptor): AndRule\nexport function option(o): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [0, 1])\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                   OR Rule Builders                                   *\n *                                                                                      */\n//========================================================================================\n\nexport function or(\n\tname: string,\n\trules: ruleBuilder | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(\n\tname: string,\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(name: string, rules: ruleBuilder | any[], onMatch?: onMatchCallback, onErr?: onErrorCallback): OrRule\n\nexport function or(\n\trules: ruleBuilder | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(rules: ruleBuilder | any[], onMatch?: onMatchCallback, onErr?: onErrorCallback): OrRule\nexport function or(desc: ComplexRuleDescriptor): OrRule\n\nexport function or(o): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [1, 1])\n}\n\nexport function anyOne(\n\tname: string,\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function anyOne(\n\tname: string,\n\trules: ruleBuilder | any[],\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\n\nexport function anyOne(\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function anyOne(rules: ruleBuilder | any[], onMatch?: onMatchCallback, onErr?: onErrorCallback): OrRule\nexport function anyOne(desc: ComplexRuleDescriptor): OrRule\nexport function anyOne(o): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [1, -1])\n}\n\nexport function manyOne(\n\tname: string,\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function manyOne(\n\tname: string,\n\trules: ruleBuilder | any[],\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\n\nexport function manyOne(\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function manyOne(rules: ruleBuilder | any[], onMatch?: onMatchCallback, onErr?: onErrorCallback): OrRule\nexport function manyOne(desc: ComplexRuleDescriptor): OrRule\nexport function manyOne(o): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [0, -1])\n}\n\nexport function optionOne(\n\tname: string,\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function optionOne(\n\tname: string,\n\trules: ruleBuilder | any[],\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\n\nexport function optionOne(\n\trules: ruleBuilder | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function optionOne(rules: ruleBuilder | any[], onMatch?: onMatchCallback, onErr?: onErrorCallback): OrRule\nexport function optionOne(desc: ComplexRuleDescriptor): OrRule\nexport function optionOne(o): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [0, 1])\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                 complex rule builder                                 *\n *                                                                                      */\n//========================================================================================\n\ntype ComplexRuleDescriptor = {\n\tname: string\n\trules: ruleBuilder | any[]\n\trepeat: [number, number]\n\tcapturable: boolean\n\tonMatch: onMatchCallback\n\tonErr: onErrorCallback\n}\nfunction mkComplexRule<T extends AndRule | OrRule>(\n\targs: IArguments,\n\tRule: typeof AndRule | typeof OrRule,\n\tdefaultRepeat: [number, number]\n): T {\n\tlet name: string,\n\t\tbuilder: ruleBuilder,\n\t\trules: any[],\n\t\trepeat: [number, number],\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\tif (isObj(args[0])) {\n\t\tconst desc = args[0] as ComplexRuleDescriptor,\n\t\t\tr = desc.rules\n\t\tif (isArray(r)) rules = r as any[]\n\t\telse if (isFn(r)) builder = r as ruleBuilder\n\t\trepeat = desc.repeat\n\t\tname = desc.name\n\t\tcapturable = desc.capturable\n\t\tonMatch = desc.onMatch\n\t\tonErr = desc.onErr\n\t} else if (isArrayLike(args)) {\n\t\tvar i = 0\n\t\tif (isStr(args[i])) name = args[i++]\n\t\tif (isArray(args[i])) rules = args[i++]\n\t\telse if (isFn(args[i])) builder = args[i++]\n\t\tif (isArray(args[i])) repeat = args[i++]\n\n\t\tif (isBool(args[i])) capturable = args[i++]\n\t\tonMatch = args[i++]\n\t\tonErr = args[i++]\n\t}\n\tif (!repeat) repeat = defaultRepeat\n\tif (!builder && rules) {\n\t\tbuilder = rulesBuilder(rules)\n\t}\n\n\tif (builder) if (isBool(args[i])) capturable = args[i++]\n\treturn new Rule(name, repeat, builder, capturable, onMatch, onErr) as T\n}\n\nfunction rulesBuilder(rules: any[]): () => Rule[] {\n\treturn function() {\n\t\treturn mapArray(rules, (r, i) => {\n\t\t\tif (!r) return SKIP\n\t\t\tlet rule: Rule = isArray(r) || isObj(r) ? mkMatch(r) : r.$rule ? r : null\n\t\t\tassert.is(rule, 'Invalid Rule Configuration on index {d}: {:.20=\"...\"j}', i, r)\n\t\t\treturn rule\n\t\t})\n\t}\n}\n"],"names":["CONSTRUCTOR","PROTOTYPE","PROTO","TYPE_BOOL","TYPE_FN","TYPE_NUM","TYPE_STRING","TYPE_UNDEF","GLOBAL","window","global","self","eq","o1","o2","isNull","o","isUndef","undefined","isNil","isBool","mkIsPrimitive","isNum","isStr","isFn","isInt","isPrimitive","type","isBoolean","mkIs","Boolean","isNumber","Number","isString","String","isDate","Date","isReg","RegExp","isArray","Array","isTypedArray","ArrayBuffer","isView","isArrayLike","NodeList","HTMLCollection","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","len","length","isObj","C","Object","Type","blankStrReg","isBlank","test","createFn","body","args","name","Function","join","applyScope","concat","applyBuilder","maxArgs","scope","offset","cases","i","slice","applyNoScope","applyScopeN","applyNoScopeN","apply","fn","applyN","varGenReg","funcProto","bind","arguments","argLen","bindPolyfill","this","bindArgs","argOffset","params","regStickySupport","sticky","regUnicodeSupport","unicode","REG_ESCAPE","reEscape","str","replace","__hasOwn","hasOwnProperty","__getProto","getPrototypeOf","____setProto","setPrototypeOf","prototypeOfSupport","protoPropSupport","__proto__","protoOf","obj","call","__setProto","proto","setProto","p","hasOwnProp","prop","__defProp","defineProperty","defPropSupport","val","get","set","value","s","e","desc","Error","defProp","defPropValue","configurable","writable","enumerable","__","doCreate","props","k","create","Control","toString","STOP","eachProps","callback","own","eachObj","eachArray","array","l","SKIP","doMapObj","each","copy","v","doMapArray","j","data","index","mapArray","parseCallback","doIdxOfObj","idx","r","doIdxOfArray","idxOfArray","doReduceObj","accumulator","rs","doReduceArray","defaultObjKeyHandler","defaultObjValueHandler","arr2obj","doArr2Obj","makeMap","split","makeArray","pathCache","pathReg","parsePath","path","cacheable","match","cidx","exec","lastIndex","SyntaxError","charAt","formatPathHandler","charCode","charCodeAt","char","code","fromCharCode","TRIM_REG","FIRST_LOWER_LETTER_REG","upperFirst","upper","m","toUpperCase","STR_ESCAPE_MAP","STR_ESCAPE","escapeStr","pad","chr","leftAlign","__pad","cut","suffix","substr","padding","thousandSeparate","mkSeparator","binarySeparate","octalSeparate","hexSeparate","group","valReg","reg","numStr","separatorHandler","d","PLURAL_REG","pluralHandler","ies","es","ys","SINGULAR_REG","singularHandler","FORMAT_PLUS","FORMAT_ZERO","FORMAT_SPACE","FORMAT_SEPARATOR","FORMAT_LEFT","FLAG_MAPPING","parseFlags","f","flags","paramIdxR","paramPropR","widthR","formatReg","formatters","extendFormatter","fmt","getFormatter","vformat","getParam","start","defaultGetParam","param","paramProp","width","widx","wprop","fill","precision","pidx","pprop","cutSuffix","parseParam","parseWidth","w","isFinite","paramIdx","getFormatParam","GET_PARAM_VAR","GET_PROP_VAR","STATE_VAR","getWidthCode","def","getParamCode","formatter","mStart","mEnd","lastIdx","arr","codes","pushStr","substring","append","strFormatter","toStr","numFormatter","parseNum","getPrefix","separator","num","prefix","plen","decimalPrefix","BASE_RADIXS","b","u","x","BASE_PREFIXS","baseFormatter","base","toLowerCase","n","__toStr","xprefix","floatFormatter","____toStr","toExponential","toFixed","toPrecision","parseFloat","doAssign","target","overrides","filter","startOffset","endOffset","override","defaultAssignFilter","assignIfFilter","JSON","stringify","c","E","g","G","B","O","X","formatArgHandlers","parseMessage","msg","msgIdx","fs","assert","catchErr","checkErr","expect","err","message","ERROR","throwMsg","mkMsg","objFormatter","extendAssert","condition","dmsg","Err","paramStr","cond","expr","notThrow","NULL","UNDEFINED","BOOLEAN","NUMBER","INTEGER","STRING","FUNCTION","to","expectMsg","not","packTypeExpect","all","typeExpect","prototype","extendAsserts","apis","TypeError","nul","nil","undef","bool","int","primitive","boolean","number","string","date","typedArray","arrayLike","nan","isNaN","finite","blank","less","greater","range","DEFAULT_BINDING","List","binding","head","tail","scaning","lazyRemoves","size","has","node","add","__insert","addFirst","insertAfter","__getNode","insertBefore","addAll","objs","__insertAll","addFirstAll","insertAfterAll","insertBeforeAll","prev","__siblingObj","next","first","last","cb","__doLazyRemove","toArray","remove","__remove","pop","clean","__lazyRemove","__clean","toJSON","__initNode","is","siblingIdx","sibling","__doInsert","nodeHead","nodeTail","__prev","__doRemove","push","FnList","fnBinding","scopeBinding","list","nodeMap","parseScope","id","nodeId","ret","DEFAULT_SCOPE_ID","scopeIdGenerator","fnIdGenerator","fnId","scopeId","ticks","pending","executeTick","flush","MutationObserver","counter","observer","textNode","document","createTextNode","observe","characterData","setTimeout","eachCharCodes","ignoreCase","eachCharCode","MatchError","capturable","source","context","rule","$ruleErr","pos","currPos","defaultErr","defaultMatch","idGen","Rule","onMatch","onErr","$rule","EXPECT","startCodeIdx","startCodes","mkErr","error","src","userErr","matched","getStart","nextCode","startCodeTest","setStartCodes","setCodeIdx","mkExpr","setExpr","getExpr","MatchRule","_Rule","comsume","advance","CharMatchRule","allows","_MatchRule","_this","chars","nextChar","RegMatchRule","regexp","pick","pattern","multiline","picker","spicker","stickyMatch","execMatch","pickNone","pickTestStr","mkPicker","pickAll","buff","getBuff","getOffset","end","StringMatchRule","_RegMatchRule","ComplexRule","repeat","builder","EXPECTS","rules","notGreater","repeatMatch","init","names","rnames","getRules","stack","consume","commit","AndRule","_ComplexRule","ctx","testRule","mlen","dlen","min","max","out","dataLen","reset","OrRule","starts","rStarts","upErr","mkMatch","isMatchPattern","isStrOrCodes","regMatch","REG_ESPEC_CHARS","strMatch","mkComplexRule","defaultRepeat","rulesBuilder","fnName","instOf","Cls","getOwnProp","defaultVal","formatPath","attr","trim","lower","strval","plural","singular","format","assign","assignIf","doEach","_eachArray","_eachObj","mapObj","map","doMap","eacharray","eachobj","idxOfObj","idxOf","doIdxOf","reduceArray","reduceObj","reduce","doReduce","keys","doObjKeys","handler","values","doObjValues","nextTick","clearTick","and","any","many","option","or","anyOne","manyOne","optionOne"],"mappings":"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"}