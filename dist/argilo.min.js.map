{"version":3,"file":"argilo.min.js","sources":["/argilo/src/util/consts.ts","/argilo/src/util/dkeys.ts","/argilo/src/util/ctor.ts","/argilo/src/util/toStr.ts","/argilo/src/util/is.ts","/argilo/src/util/fn.ts","/argilo/src/util/reg.ts","/argilo/src/util/proto/polyfill.ts","/argilo/src/util/defProp/polyfill.ts","/argilo/src/util/defProp/index.ts","/argilo/src/util/ownProp.ts","/argilo/src/util/create/polyfill.ts","/argilo/src/util/deepEq.ts","/argilo/src/util/string.ts","/argilo/src/util/assign.ts","/argilo/src/util/collection/Control.ts","/argilo/src/util/collection/each.ts","/argilo/src/util/collection/map.ts","/argilo/src/util/collection/idxOf.ts","/argilo/src/util/collection/reduce.ts","/argilo/src/util/collection/obj2arr.ts","/argilo/src/util/collection/arr2obj.ts","/argilo/src/util/collection/index.ts","/argilo/src/util/mixin.ts","/argilo/src/path/index.ts","/argilo/src/format/index.ts","/argilo/src/assert/index.ts","/argilo/src/list/List.ts","/argilo/src/list/FnList.ts","/argilo/src/nextTick/index.ts","/argilo/src/ast/Source.ts","/argilo/src/ast/util.ts","/argilo/src/ast/Rule.ts","/argilo/src/ast/MatchContext.ts","/argilo/src/ast/ComplexRule.ts","/argilo/src/ast/AndRule.ts","/argilo/src/ast/OrRule.ts","/argilo/src/ast/MatchRule.ts","/argilo/src/ast/CharMatchRule.ts","/argilo/src/ast/RegMatchRule.ts","/argilo/src/ast/StringMatchRule.ts","/argilo/src/ast/api.ts","/argilo/src/observer/IObserver.ts","/argilo/src/observer/arrayHook.ts","/argilo/src/observer/VBPolicy.ts","/argilo/src/observer/Observer.ts","/argilo/src/observer/ProxyPolicy.ts","/argilo/src/observer/AccessorPolicy.ts"],"sourcesContent":["/**\n *\n * @module util\n * @author Tao Zeng (tao.zeng.zt@qq.com)\n * @created 2018-11-09 15:23:35\n * @modified 2018-11-09 15:23:35 by Tao Zeng (tao.zeng.zt@qq.com)\n */\n\nexport const P_CTOR = 'constructor'\n\nexport const P_PROTOTYPE = 'prototype'\n\nexport const P_PROTO = '__proto__'\n\nexport const P_OWNPROP = 'hasOwnProperty'\n\nexport const T_BOOL = 'boolean'\n\nexport const T_FN = 'function'\n\nexport const T_NUM = 'number'\n\nexport const T_STRING = 'string'\n\nexport const T_UNDEF = 'undefined'\n\nexport const GLOBAL: any =\n\ttypeof window !== T_UNDEF ? window : typeof global !== T_UNDEF ? global : typeof self !== T_UNDEF ? self : {}\n\nexport type ObjArray<T> = {\n\tlength: number\n\t[Symbol.iterator](): IterableIterator<T>\n}\nexport type IArray<T> = T[] | string | ObjArray<T>\n\nexport function EMPTY_FN() {}\n\nexport function NULL_CTOR() {}\nNULL_CTOR[P_PROTOTYPE] = null\n","/**\n * @module util/dkeys\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Mar 11 2019 17:22:13 GMT+0800 (China Standard Time)\n * @modified Sat Mar 23 2019 17:42:04 GMT+0800 (China Standard Time)\n */\nimport { NULL_CTOR } from './consts'\n\nexport const DKeyMap = new NULL_CTOR()\n\nexport const DKeys = []\n\nexport function isDKey(key: string) {\n\treturn DKeyMap[key] || false\n}\n\nexport function addDKey(key: string) {\n\tif (!DKeyMap[key]) {\n\t\tDKeyMap[key] = true\n\t\tDKeys.push(key)\n\t}\n\treturn key\n}\n\nexport function addDKeys(...keys: string[]): void\n\nexport function addDKeys() {\n\tconst args = arguments,\n\t\tl = args.length\n\tfor (var i = 0; i < l; i++) {\n\t\taddDKey(args[i] + '')\n\t}\n}\n\nexport function getDKeys() {\n\treturn DKeys\n}\n\nexport function getDKeyMap() {\n\treturn DKeys\n}\n","/**\n * @module util\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 11:50:32 GMT+0800 (China Standard Time)\n */\n\nimport { T_FN, P_CTOR } from './consts'\n\nexport function getCtor(o: any) {\n\tlet C = o[P_CTOR]\n\treturn typeof C === T_FN ? C : Object\n}\n","/**\n * @module util\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 13:26:55 GMT+0800 (China Standard Time)\n */\nconst toString = Object.prototype.toString\nexport function toStr(obj: any): String {\n\treturn toString.call(obj)\n}\n\nexport function toStrType(obj: any) {\n\treturn toString.call(obj).match(/^\\[object ([^\\]]+)\\]$/)[1]\n}\n","/**\n * @module util\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Wed Apr 10 2019 13:55:08 GMT+0800 (China Standard Time)\n */\n\nimport { P_CTOR, GLOBAL, T_BOOL, T_FN, T_NUM, T_STRING, T_UNDEF } from './consts'\nimport { getCtor } from './ctor'\nimport { toStr } from './toStr'\n\n/**\n * is equals\n * > o1 === o2 || NaN === NaN\n */\nexport function eq(o1: any, o2: any): boolean {\n\treturn o1 === o2 || (o1 !== o1 && o2 !== o2)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    primitive type                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * is null\n */\nexport function isNull(o: any): boolean {\n\treturn o === null\n}\n\n/**\n * is undefined\n */\nexport function isUndef(o: any): boolean {\n\treturn o === undefined\n}\n\n/**\n * is null or undefined\n */\nexport function isNil(o: any): boolean {\n\treturn o === null || o === undefined\n}\n\n/**\n * is boolean\n */\nexport const isBool: (o: any) => boolean = mkIsPrimitive(T_BOOL)\n\n/**\n * is a number\n */\nexport const isNum: (o: any) => boolean = mkIsPrimitive(T_NUM)\n\n/**\n * is a string\n */\nexport const isStr: (o: any) => boolean = mkIsPrimitive(T_STRING)\n\n/**\n * is a function\n */\nexport const isFn: (o: any) => boolean = mkIsPrimitive(T_FN)\n\n/**\n * is integer number\n */\nexport function isInt(o: any): boolean {\n\treturn o === 0 || (o ? typeof o === T_NUM && o % 1 === 0 : false)\n}\n\n/**\n * is primitive type\n * - null\n * - undefined\n * - boolean\n * - number\n * - string\n * - function\n */\nexport function isPrimitive(o: any): boolean {\n\tif (o === undefined || o === null) {\n\t\treturn true\n\t}\n\tswitch (typeof o) {\n\t\tcase T_BOOL:\n\t\tcase T_NUM:\n\t\tcase T_STRING:\n\t\tcase T_FN:\n\t\t\treturn true\n\t}\n\treturn false\n}\n\nfunction mkIsPrimitive(type: string): (o: any) => boolean {\n\treturn function is(o: any): boolean {\n\t\treturn typeof o === type\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    reference type                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * is instanceof\n */\nexport function instOf(obj: any, Cls: Function): boolean {\n\treturn obj !== undefined && obj !== null && obj instanceof Cls\n}\n\n/**\n * is child instance of Type\n */\nexport function is(o: any, Type: Function | Function[]): boolean {\n\tif (o !== undefined && o !== null) {\n\t\tconst C = o[P_CTOR] || Object\n\t\tif (Type[P_CTOR] === Array) {\n\t\t\tvar i = Type.length\n\t\t\twhile (i--) {\n\t\t\t\tif (C === (Type as Function[])[i]) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn C === Type\n\t\t}\n\t}\n\treturn false\n}\n\n/**\n * is boolean or Boolean\n */\nexport const isBoolean: (o: any) => boolean = mkIs(Boolean)\n\n/**\n * is number or Number\n */\nexport const isNumber: (o: any) => boolean = mkIs(Number)\n\n/**\n * is string or String\n */\nexport const isString: (o: any) => boolean = mkIs(String)\n\n/**\n * is Date\n */\nexport const isDate: (o: any) => boolean = mkIs(Date)\n\n/**\n * is RegExp\n */\nexport const isReg: (o: any) => boolean = mkIs(RegExp)\n\n/**\n * is Array\n */\nexport const isArray: (o: any) => boolean = Array.isArray || mkIs(Array)\n\n/**\n * is Typed Array\n */\nexport const isTypedArray: (o: any) => boolean = typeof ArrayBuffer === T_FN ? ArrayBuffer.isView : () => false\n\n/**\n * is Array or pseudo-array\n * - Array\n * - String\n * - IArguments\n * - NodeList\n * - HTMLCollection\n * - Typed Array\n * - {length: int, [length-1]: any}\n */\nexport function isArrayLike(o: any): boolean {\n\tif (o && o[P_CTOR]) {\n\t\tswitch (o[P_CTOR]) {\n\t\t\tcase Array:\n\t\t\tcase String:\n\t\t\tcase GLOBAL.NodeList:\n\t\t\tcase GLOBAL.HTMLCollection:\n\t\t\tcase GLOBAL.Int8Array:\n\t\t\tcase GLOBAL.Uint8Array:\n\t\t\tcase GLOBAL.Int16Array:\n\t\t\tcase GLOBAL.Uint16Array:\n\t\t\tcase GLOBAL.Int32Array:\n\t\t\tcase GLOBAL.Uint32Array:\n\t\t\tcase GLOBAL.Float32Array:\n\t\t\tcase GLOBAL.Float64Array:\n\t\t\t\treturn true\n\t\t}\n\t\tconst len = o.length\n\t\treturn typeof len === T_NUM && (len === 0 || (len > 0 && len % 1 === 0 && len - 1 in o))\n\t}\n\treturn o === ''\n}\n\n/**\n * is simple Object\n * TODO object may has constructor property\n */\nexport function isObj(o: any): boolean {\n\treturn o !== undefined && o !== null && getCtor(o) === Object\n}\n\n/**\n * is simple Object\n * TODO object may has constructor property\n */\nexport function isObject(o: any): boolean {\n\treturn toStr(o) === '[object Object]'\n}\n\nfunction mkIs(Type: Function): (o: any) => boolean {\n\treturn function is(o: any): boolean {\n\t\treturn o !== undefined && o !== null && o[P_CTOR] === Type\n\t}\n}\n\nconst blankStrReg = /^\\s*$/\n/**\n * is empty\n * - string: trim(string).length === 0\n * - array: array.length === 0\n * - pseudo-array: pseudo-array.length === 0\n */\nexport function isBlank(o: any): boolean {\n\tif (o) {\n\t\tif (o[P_CTOR] === String) {\n\t\t\treturn blankStrReg.test(o)\n\t\t}\n\t\treturn o.length === 0\n\t}\n\treturn true\n}\n","/**\n * @module util\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 13:26:23 GMT+0800 (China Standard Time)\n */\n\nimport { GLOBAL, P_PROTOTYPE } from './consts'\nimport { isNil } from './is'\n\n// ========================================================================================\n/*                                                                                      *\n *                                    create function                                   *\n *                                                                                      */\n// ========================================================================================\n\n/**\n * create function by code string\n * @param body\tfunction body\n * @param args\tfunction argument names\n * @param name\tfunction name\n */\nexport function createFn<T extends (...args: any[]) => any>(body: string, args?: string[], name?: string): T {\n\treturn name\n\t\t? Function(`return function ${name}(${args ? args.join(', ') : ''}){${body}}`)()\n\t\t: applyScope(Function, Function, args && args.length ? args.concat(body) : [body])\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                    function apply                                    *\n *                                                                                      */\n// ========================================================================================\n\n/**\n * generate apply function\n */\nfunction applyBuilder<T extends (...args: any[]) => any>(maxArgs: number, scope: any, offset: any): T {\n\tscope = scope ? 'scope' : ''\n\toffset = offset ? 'offset' : ''\n\tconst args = new Array(maxArgs + 1)\n\tconst cases = new Array(maxArgs + 1)\n\tfor (let i = 0; i <= maxArgs; i++) {\n\t\targs[i] = `${i || scope ? ', ' : ''}args[${offset ? `offset${i ? ' + ' + i : ''}` : i}]`\n\t\tcases[i] = `case ${i}: return fn${scope && '.call'}(${scope}${args.slice(0, i).join('')});`\n\t}\n\treturn Function(`return function(fn, ${scope && scope + ', '}args${offset && ', offset, len'}){\nswitch(${offset ? 'len' : 'args.length'}){\n${cases.join('\\n')}\n}\n${offset &&\n\t`var arr = new Array(len);\nfor(var i=0; i<len; i++) arr[i] = arr[offset + i];`}\nreturn fn.apply(${scope || 'null'}, ${offset ? 'arr' : 'args'});\n}`)()\n}\n\n/**\n * apply function with scope\n * @param fn\ttarget function\n * @param scope\tscope of function\n * @param args\targuments of function\n */\nexport const applyScope: (fn: (...args: any[]) => any, scope: any, args: any[] | IArguments) => any = applyBuilder(\n\t8,\n\t1,\n\t0\n)\n\n/**\n * apply function without scope\n * @param fn\t\ttarget function\n * @param args\targuments of function\n */\nexport const applyNoScope: (fn: (...args: any[]) => any, args: any[] | IArguments) => any = applyBuilder(8, 0, 0)\n\n/**\n * apply function with scope\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport const applyScopeN: (\n\tfn: (...args: any[]) => any,\n\tscope: any,\n\targs: any[] | IArguments,\n\toffset: number,\n\tlen: number\n) => any = applyBuilder(8, 1, 1)\n\n/**\n * apply function without scope\n * @param fn\t\ttarget function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport const applyNoScopeN: (\n\tfn: (...args: any[]) => any,\n\targs: any[] | IArguments,\n\toffset: number,\n\tlen: number\n) => any = applyBuilder(8, 0, 1)\n\n/**\n * apply function\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n */\nexport function apply(fn: (...args: any[]) => any, scope: any, args: any[] | IArguments): any {\n\tif (scope === undefined || scope === null || scope === GLOBAL) {\n\t\treturn applyNoScope(fn, args || [])\n\t}\n\treturn applyScope(fn, scope, args || [])\n}\n\n/**\n * apply function\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport function applyN(\n\tfn: (...args: any[]) => any,\n\tscope: any,\n\targs: any[] | IArguments,\n\toffset: number,\n\tlen: number\n): any {\n\tif (scope === undefined || scope === null || scope === GLOBAL) {\n\t\treturn applyNoScopeN(fn, args, offset, len)\n\t}\n\treturn applyScopeN(fn, scope, args, offset, len)\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                     function name                                    *\n *                                                                                      */\n// ========================================================================================\n\nconst varGenReg = /\\$\\d+$/\n\n/**\n * get function name\n */\nexport function fnName(fn: (...args: any[]) => any): string {\n\tconst name: string = (fn as any).name\n\treturn name ? name.replace(varGenReg, '') : 'anonymous'\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                         bind                                         *\n *                                                                                      */\n// ========================================================================================\n\nlet _bind: <T extends (...args: any[]) => any>(fn: T, scope: any, ...args: any[]) => T\n\nconst funcProto = Function[P_PROTOTYPE]\nif (funcProto.bind) {\n\t_bind = function bind<T extends (...args: any[]) => any>(fn: T, scope: any): T {\n\t\tconst args = arguments,\n\t\t\targLen = args.length\n\t\tif (isNil(scope)) {\n\t\t\treturn argLen > 2 ? bindPolyfill(fn, scope, args, 2) : fn\n\t\t}\n\t\treturn applyScopeN(fn.bind, fn, args, 1, argLen - 1)\n\t}\n} else {\n\tfuncProto.bind = function bind(scope) {\n\t\treturn bindPolyfill(this as any, scope, arguments, 1)\n\t}\n\t_bind = function bind<T extends (...args: any[]) => any>(fn: T, scope: any): T {\n\t\treturn bindPolyfill(fn, scope, arguments, 2)\n\t}\n}\n\n/**\n * bind scope or arguments on function\n * - return source function when without arguments and scope is undefined or null\n * - only bind arguments when scope is undefined or null, well can call the new function proxy with some scope\n *\n * @example\n * \t\tfunction example() {\n * \t\t\tconsole.log(this, arguments);\n * \t\t}\n * \t\tvar proxy = bind(example, null) \t// proxy === example\n * \t\tproxy() \t\t\t\t\t\t\t// log: window | undefined, []\n * \t\tproxy.call(1) \t\t\t\t\t\t// log: 1, []\n *\n * \t\tproxy = bind(example, null, 1) \t\t// proxy !== example\n * \t\tproxy() \t\t\t\t\t\t\t// log: window | undefined, [1]\n * \t\tproxy(2) \t\t\t\t\t\t\t// log: window | undefined, [1, 2]\n * \t\tproxy.call(1, 2) \t\t\t\t\t// log: 1, [1, 2]\n *\n * \t\tproxy = bind(example, {}, 1, 2)\t\t// proxy !== example\n * \t\tproxy() \t\t\t\t\t\t\t// log: {}, [1]\n * \t\tproxy(2) \t\t\t\t\t\t\t// log: {}, [1, 2, 2]\n * \t\tproxy.call(1, 2) \t\t\t\t\t// log: {}, [1, 2, 2]\n *\n * @param fn\tsource function\n * @param scope\tbind scope\n * @param args\tbind arguments\n * @return function proxy\n */\nexport const bind: <T extends (...args: any[]) => any>(fn: T, scope: any, ...args: any[]) => T = _bind\n\n/**\n * bind\n * > not bind scope when scope is null or undefined\n * @param fn\t\tsource function\n * @param scope\t\tbind scope\n * @param args\t\tbind arguments\n * @param argOffset\toffset of args\n * @return function proxy\n */\nfunction bindPolyfill<T extends (...args: any[]) => any>(\n\tfn: T,\n\tscope: any,\n\tbindArgs: any[] | IArguments,\n\targOffset: number\n): T {\n\tconst argLen = bindArgs.length - argOffset\n\tif (scope === undefined) {\n\t\tscope = null\n\t}\n\tif (argLen > 0) {\n\t\t// bind with arguments\n\t\treturn function bindProxy() {\n\t\t\tconst args = arguments\n\t\t\tlet i = args.length\n\t\t\tif (i) {\n\t\t\t\tconst params = new Array(argLen + i)\n\t\t\t\twhile (i--) {\n\t\t\t\t\tparams[argLen + i] = args[i]\n\t\t\t\t}\n\t\t\t\ti = argLen\n\t\t\t\twhile (i--) {\n\t\t\t\t\tparams[i] = bindArgs[i + argOffset]\n\t\t\t\t}\n\t\t\t\treturn apply(fn, scope === null ? this : scope, params) // call with scope or this\n\t\t\t}\n\t\t\treturn applyN(fn, scope === null ? this : scope, bindArgs, argOffset, argLen) // call with scope or this\n\t\t} as any\n\t}\n\tif (scope === null) {\n\t\treturn fn\n\t}\n\tif (scope === GLOBAL) {\n\t\t// bind on GLOBAL\n\t\treturn function bindProxy() {\n\t\t\treturn applyNoScope(fn, arguments)\n\t\t} as any\n\t}\n\treturn function bindProxy() {\n\t\treturn applyScope(fn, scope, arguments)\n\t} as any\n}\n","/**\n * @module util\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Sep 06 2018 18:27:51 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 13:25:13 GMT+0800 (China Standard Time)\n */\n\nimport { isBool } from './is'\n\n/**\n * whether to support sticky on RegExp\n */\nexport const stickyReg = isBool(/(?:)/.sticky)\n\n/**\n * whether to support unicode on RegExp\n */\nexport const unicodeReg = isBool(/(?:)/.unicode)\n\nconst REG_ESCAPE = /[-\\/\\\\^$*+?.()|[\\]{}]/g\n\n/**\n * escape string for RegExp\n */\nexport function reEscape(str: string): string {\n\treturn str.replace(REG_ESCAPE, '\\\\$&')\n}\n","/**\n * @module util\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:23:56 GMT+0800 (China Standard Time)\n * @modified Wed Apr 10 2019 11:38:30 GMT+0800 (China Standard Time)\n */\nimport { P_CTOR, P_PROTO, P_PROTOTYPE } from '../consts'\nimport { addDKey } from '../dkeys'\n\nconst $getProto = Object.getPrototypeOf,\n\t$setProto = Object.setPrototypeOf\n\n/**\n * whether to support Object.getPrototypeOf and Object.setPrototypeOf\n */\nexport const prototypeOf = !!$setProto\n\n/**\n * whether to support `__proto__`\n */\nexport const protoProp = { [P_PROTO]: [] } instanceof Array\n\n!protoProp && addDKey(P_PROTO)\n\n/**\n * get prototype\n */\nexport const protoOf: typeof Object.getPrototypeOf = $setProto\n\t? $getProto\n\t: $getProto\n\t? function getPrototypeOf(obj) {\n\t\t\treturn obj[P_PROTO] || $getProto(obj)\n\t  }\n\t: function getPrototypeOf(obj) {\n\t\t\treturn obj[P_PROTO] || obj[P_CTOR][P_PROTOTYPE]\n\t  }\n\n/**\n * set prototype\n * > properties on the prototype are not inherited on older browsers\n */\nexport const __setProto: typeof Object.setPrototypeOf =\n\t$setProto ||\n\tfunction setPrototypeOf(obj, proto) {\n\t\tobj[P_PROTO] = proto\n\t\treturn obj\n\t}\n\n/**\n * set prototype\n * > the properties on the prototype will be copied on the older browser\n */\nexport const setProto: typeof Object.setPrototypeOf =\n\t$setProto ||\n\t(protoProp\n\t\t? __setProto\n\t\t: function setPrototypeOf(obj, proto) {\n\t\t\t\tfor (let p in proto) {\n\t\t\t\t\tif (!(p in obj)) obj[p] = proto[p]\n\t\t\t\t}\n\t\t\t\treturn __setProto(obj, proto)\n\t\t  })\n","/**\n * @module util\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:22:57 GMT+0800 (China Standard Time)\n * @modified Wed Apr 10 2019 11:43:27 GMT+0800 (China Standard Time)\n */\nimport { P_PROTOTYPE } from '../consts'\n\nconst { __defineGetter__, __defineSetter__ } = Object[P_PROTOTYPE] as any\nconst $defProp = Object.defineProperty\n\n/**\n * whether to support Object.defineProperty\n * @constant\n */\nexport let propDescriptor: boolean = false\nif ($defProp) {\n\ttry {\n\t\tvar val: number,\n\t\t\tobj: { s?: number } = {}\n\t\t$defProp(obj, 's', {\n\t\t\tget() {\n\t\t\t\treturn val\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tval = value\n\t\t\t}\n\t\t})\n\t\tobj.s = 1\n\t\tpropDescriptor = obj.s === val\n\t} catch (e) {}\n}\n\n/**\n * whether to support `__defineGetter__` and `__defineSetter__`\n */\nexport const propAccessor: boolean = propDescriptor || !!__defineSetter__\n\n/**\n * define property\n */\nexport const defProp: typeof Object.defineProperty = propDescriptor\n\t? $defProp\n\t: __defineSetter__\n\t? function defineProperty(obj, prop, desc) {\n\t\t\tconst { get, set } = desc\n\t\t\tif ('value' in desc || !(prop in obj)) obj[prop] = desc.value\n\t\t\tget && __defineGetter__.call(obj, prop, get)\n\t\t\tset && __defineSetter__.call(obj, prop, set)\n\t\t\treturn obj\n\t  }\n\t: function defineProperty(obj, prop, desc) {\n\t\t\tif (desc.get || desc.set) throw new TypeError('property accessors are not supported.')\n\t\t\tif ('value' in desc || !(prop in obj)) obj[prop] = desc.value\n\t\t\treturn obj\n\t  }\n","/**\n * @module util\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:24:47 GMT+0800 (China Standard Time)\n * @modified Wed Apr 10 2019 11:47:32 GMT+0800 (China Standard Time)\n */\n\n//#if _TARGET === 'es3'\n\nimport { defProp } from './polyfill'\nexport { propDescriptor, propAccessor, defProp } from './polyfill'\n\n/*#else\n\nimport { defProp } from './polyfill'\nexport { propDescriptor, propAccessor, defProp } from './main'\n\n//#endif */\n\nexport function defValue<V>(\n\tobj: any,\n\tprop: string,\n\tvalue: V,\n\tenumerable?: boolean,\n\tconfigurable?: boolean,\n\twritable?: boolean\n): V {\n\tdefProp(obj, prop, {\n\t\tvalue,\n\t\tenumerable: enumerable !== false,\n\t\tconfigurable: configurable !== false,\n\t\twritable: writable !== false\n\t})\n\treturn value\n}\n\nexport function defAccessor(\n\tobj: any,\n\tprop: string,\n\tget: () => any,\n\tset: (v: any) => void,\n\tenumerable?: boolean,\n\tconfigurable?: boolean\n) {\n\tdefProp(obj, prop, {\n\t\tget,\n\t\tset,\n\t\tenumerable: enumerable !== false,\n\t\tconfigurable: configurable !== false\n\t})\n}\n","/**\n * @module util\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:22:57 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 12:42:51 GMT+0800 (China Standard Time)\n */\n\nimport { P_PROTOTYPE, P_OWNPROP } from './consts'\n\nconst __hasOwn = Object[P_PROTOTYPE][P_OWNPROP]\n\n/**\n * has own property\n */\nexport const hasOwnProp: (obj: any, prop: string) => boolean = (obj: any, prop: string): boolean => {\n\treturn __hasOwn.call(obj, prop)\n}\n\n/**\n * get owner property value\n * @param prop \t\t\tproperty name\n * @param defaultVal \tdefault value\n */\nexport function getOwnProp(obj: any, prop: string, defaultVal?: any): any {\n\treturn hasOwnProp(obj, prop) ? obj[prop] : defaultVal\n}\n","/**\n * Object.create polyfill\n * @module util\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:24:47 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 14:11:37 GMT+0800 (China Standard Time)\n */\n\nimport { P_PROTOTYPE } from '../consts'\nimport { defProp } from '../defProp'\nimport { hasOwnProp } from '../ownProp'\nimport { __setProto } from '../proto'\n\nfunction __() {}\n\n/**\n * create shim\n */\nfunction doCreate(o: object | null, props?: PropertyDescriptorMap & ThisType<any>): any {\n\t__[P_PROTOTYPE] = o\n\tconst obj = new __()\n\t__[P_PROTOTYPE] = null\n\tif (props) {\n\t\tfor (var k in props) {\n\t\t\tif (hasOwnProp(props, k)) {\n\t\t\t\tdefProp(obj, k, props[k])\n\t\t\t}\n\t\t}\n\t}\n\treturn obj\n}\n\n/**\n * create object\n */\nexport const create =\n\tObject.create ||\n\t(Object.create = Object.getPrototypeOf\n\t\t? doCreate\n\t\t: function create(o: object | null, props?: PropertyDescriptorMap & ThisType<any>): any {\n\t\t\t\tconst obj = doCreate(o, props)\n\t\t\t\t__setProto(obj, o)\n\t\t\t\treturn obj\n\t\t  })\n","/**\n * @module util\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:24:47 GMT+0800 (China Standard Time)\n * @modified Wed Apr 10 2019 11:19:57 GMT+0800 (China Standard Time)\n */\nimport { eq, isReg, isTypedArray, isDate, isArray, isPrimitive } from './is'\nimport { hasOwnProp } from './ownProp'\nimport { create } from './create'\nimport { getCtor } from './ctor'\nimport { DKeyMap } from './dkeys'\n\nconst REG_PROPS = ['source', 'global', 'ignoreCase', 'multiline']\n\nexport function deepEq(actual: any, expected: any): boolean {\n\treturn doDeepEq(actual, expected, eq, doDeepEqObj)\n}\n\nexport function doDeepEq(\n\tactual: any,\n\texpected: any,\n\teq: (actual: any, expected: any) => boolean,\n\teqObj: (actual: any, expected: any) => boolean\n) {\n\tif (eq(actual, expected)) return true\n\tif (actual && expected && getCtor(actual) === getCtor(expected)) {\n\t\tif (isPrimitive(actual)) return String(actual) === String(expected)\n\t\tif (isDate(actual)) return actual.getTime() === expected.getTime()\n\t\tif (isReg(actual)) return eqProps(actual, expected, REG_PROPS)\n\t\tif (isArray(actual)) return eqArray(actual, expected, eq, eqObj)\n\t\tif (isTypedArray(actual)) return eqTypeArray(actual, expected)\n\t\treturn eqObj(actual, expected)\n\t}\n\treturn false\n}\n\nexport function doDeepEqObj(actual: any, expected: any): boolean {\n\tconst cache = create(null)\n\tlet k: string\n\tfor (k in actual) {\n\t\tif (!DKeyMap[k] && (!(k in expected) || !deepEq(actual[k], expected[k]))) {\n\t\t\treturn false\n\t\t}\n\t\tcache[k] = true\n\t}\n\tfor (k in expected) {\n\t\tif (!cache[k] && !DKeyMap[k] && (!(k in actual) || !deepEq(actual[k], expected[k]))) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunction eqProps(actual: any, expected: any, props: string[]): boolean {\n\tlet i = props.length\n\twhile (i--)\n\t\tif (actual[props[i]] !== expected[props[i]]) {\n\t\t\treturn false\n\t\t}\n\treturn true\n}\n\nfunction eqTypeArray(actual: any, expected: any) {\n\tlet i = actual.length\n\tif (i !== expected.length) {\n\t\treturn false\n\t}\n\twhile (i--)\n\t\tif (actual[i] !== expected[i]) {\n\t\t\treturn false\n\t\t}\n\treturn true\n}\n\nfunction eqArray(\n\tactual: any,\n\texpected: any,\n\teq: (actual: any, expected: any) => boolean,\n\teqObj: (actual: any, expected: any) => boolean\n) {\n\tlet i = actual.length\n\tif (i !== expected.length) {\n\t\treturn false\n\t}\n\twhile (i--)\n\t\tif (!doDeepEq(actual[i], expected[i], eq, eqObj)) {\n\t\t\treturn false\n\t\t}\n\treturn true\n}\n","/**\n * @module util\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 14:10:44 GMT+0800 (China Standard Time)\n */\n\n//========================================================================================\n/*                                                                                      *\n *                                       char code                                      *\n *                                                                                      */\n//========================================================================================\n\n/**\n * get char code\n * > string.charCodeAt\n */\nexport function charCode(str: string, index?: number): number {\n\treturn str.charCodeAt(index || 0)\n}\n\n/**\n * get char by char code\n * > String.fromCharCode\n */\nexport function char(code: number): string {\n\treturn String.fromCharCode(code)\n}\n\nexport function cutStr(str: string, start: number, end?: number) {\n\treturn str.substring(start, end)\n}\n\nexport function cutLStr(str: string, start: number, len?: number) {\n\treturn str.substr(start, len)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         trim                                         *\n *                                                                                      */\n//========================================================================================\n\nconst TRIM_REG = /(^\\s+)|(\\s+$)/g\n\n/**\n * trim\n */\nexport function trim(str: string): string {\n\treturn str.replace(TRIM_REG, '')\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         case                                         *\n *                                                                                      */\n//========================================================================================\n\nconst FIRST_LOWER_LETTER_REG = /^[a-z]/,\n\tFIRST_UPPER_LETTER_REG = /^[A-Z]/\n\nexport function upper(str: string): string {\n\treturn str.toUpperCase()\n}\n\nexport function lower(str: string): string {\n\treturn str.toLowerCase()\n}\n\nexport function upperFirst(str: string): string {\n\treturn str.replace(FIRST_LOWER_LETTER_REG, upper)\n}\n\nexport function lowerFirst(str: string): string {\n\treturn str.replace(FIRST_UPPER_LETTER_REG, lower)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        escape                                        *\n *                                                                                      */\n//========================================================================================\n\nconst STR_ESCAPE_MAP = {\n\t\t'\\n': '\\\\n',\n\t\t'\\t': '\\\\t',\n\t\t'\\f': '\\\\f',\n\t\t'\"': '\\\\\"',\n\t\t\"'\": \"\\\\'\"\n\t},\n\tSTR_ESCAPE = /[\\n\\t\\f\"']/g\n\nexport function escapeStr(str: string): string {\n\treturn str.replace(STR_ESCAPE, str => STR_ESCAPE_MAP[str])\n}\n","/**\n * Object.assign shim\n * @module util\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:22:13 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 14:11:20 GMT+0800 (China Standard Time)\n */\nimport { hasOwnProp } from './ownProp'\nimport { DKeyMap } from './dkeys'\n\n/**\n * @param prop\n * @param target\n * @param source\n * @return is assign\n */\nexport type AssignFilter<T, O> = (prop: string, target: T, source: O) => boolean\n\n/**\n *\n * @param target\n * @param sources\n * @param filter\n * @param startOffset \tstart offset in sources, default: 0\n * @param endOffset \tend offset in sources, default: sources.length-1\n */\nexport function doAssign<T extends object, U>(target: T, sources: [U], filter: AssignFilter<T, U>): T & U\nexport function doAssign<T extends object, U, V>(target: T, sources: [U, V], filter: AssignFilter<T, U | V>): T & U & V\nexport function doAssign<T extends object, U, V, W>(\n\ttarget: T,\n\tsources: [U, V],\n\tfilter: AssignFilter<T, U | V | W>\n): T & U & W\nexport function doAssign<T extends object>(\n\ttarget: T,\n\tsources: any[] | IArguments,\n\tfilter: AssignFilter<T, object>,\n\tstartOffset?: number,\n\tendOffset?: number\n): any\nexport function doAssign<T extends object>(\n\ttarget: T,\n\tsources: any[] | IArguments,\n\tfilter: AssignFilter<T, object>,\n\tstartOffset?: number,\n\tendOffset?: number\n): any {\n\tconst l = endOffset || sources.length\n\tlet i = startOffset || 0,\n\t\tsource: any,\n\t\tprop: string\n\ttarget || (target = {} as T)\n\tfor (; i < l; i++) {\n\t\tif ((source = sources[i])) {\n\t\t\tfor (prop in source) {\n\t\t\t\tif (!DKeyMap[prop] && filter(prop, target, source)) {\n\t\t\t\t\ttarget[prop] = source[prop]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn target\n}\n\n/**\n * assign properties\n * > Object.assign shim\n */\nexport function assign<T, U>(target: T, source: U): T & U\nexport function assign<T, U, V>(target: T, source: U, source2: V): T & U & V\nexport function assign<T, U, V, W>(target: T, source: U, source2: V, source3: W): T & U & W\nexport function assign(target: object, ...args: any[]): any\nexport function assign(target: object): any {\n\treturn doAssign(target, arguments, defaultAssignFilter, 1)\n}\n\n/**\n * assign un-exist properties\n */\nexport function assignIf<T, U>(target: T, source: U): T & U\nexport function assignIf<T, U, V>(target: T, source: U, source2: V): T & U & V\nexport function assignIf<T, U, V, W>(target: T, source: U, source2: V, source3: W): T & U & W\nexport function assignIf(target: object, ...args: any[]): any\nexport function assignIf(target: object): any {\n\treturn doAssign(target, arguments, assignIfFilter, 1)\n}\n\n/**\n * default assign filter\n * - property is owner in source\n * @see {AssignFilter}\n */\nexport function defaultAssignFilter(prop: string, target: object, source: object): boolean {\n\treturn hasOwnProp(source, prop)\n}\n\n/**\n * assign if filter\n * - property is owner in source\n * - property not in target object\n * @see {AssignFilter}\n */\nexport function assignIfFilter(prop: string, target: object, source: object): boolean {\n\treturn hasOwnProp(source, prop) && !(prop in target)\n}\n","/**\n * @module util/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:10:41 GMT+0800 (China Standard Time)\n * @modified Sat Dec 29 2018 19:37:44 GMT+0800 (China Standard Time)\n */\nexport class Control {\n\tprivate __desc: string\n\n\tconstructor(desc: string) {\n\t\tthis.__desc = desc\n\t}\n\n\ttoString() {\n\t\treturn this.__desc\n\t}\n}\n","/**\n * @module util/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:10:41 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 09:49:19 GMT+0800 (China Standard Time)\n */\nimport { Control } from './Control'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { hasOwnProp } from '../ownProp'\nimport { isArrayLike, isBool } from '../is'\nimport { DKeyMap } from '../dkeys'\n\n/**\n * STOP Control\n * > stop each/map/indexOf...\n */\nexport const STOP = new Control('STOP')\n//========================================================================================\n/*                                                                                      *\n *                                each object properties                                *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on object\n * - will stop each on return STOP\n */\nexport type EachPropCallback<T extends {}> = (prop: string, obj: T) => Control | void\n\n/**\n * each properties\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties, default: true\n * @return stoped property name or false\n */\nexport function eachProps<T extends {}>(obj: T, callback: EachPropCallback<T>, own: boolean): false | string\nexport function eachProps<T extends {}>(\n\tobj: T,\n\tcallback: EachPropCallback<T>,\n\tscope?: any,\n\town?: boolean\n): false | string\nexport function eachProps<T extends {}>(\n\tobj: T,\n\tcallback: EachPropCallback<T>,\n\tscope?: any,\n\town?: boolean\n): false | string {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tlet k: string\n\tif (own === false) {\n\t\tfor (k in obj) if (!DKeyMap[k] && callback(k, obj) === STOP) return k\n\t} else {\n\t\tfor (k in obj) if (!DKeyMap[k] && hasOwnProp(obj, k) && callback(k, obj) === STOP) return k\n\t}\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      each object                                     *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on object\n * - will stop each on callback return STOP\n */\nexport type EachObjCallback<E> = (value: E, prop: string, obj: { [key: string]: E }) => Control | void\n\n/**\n * each object\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties, default: true\n * @return stoped property name or false\n */\nexport function eachObj<E>(obj: { [key: string]: E }, callback: EachObjCallback<E>, own: boolean): false | string\nexport function eachObj<E>(\n\tobj: { [key: string]: E },\n\tcallback: EachObjCallback<E>,\n\tscope?: any,\n\town?: boolean\n): false | string\nexport function eachObj<E>(\n\tobj: { [key: string]: E },\n\tcallback: EachObjCallback<E>,\n\tscope?: any,\n\town?: boolean\n): false | string {\n\tconst args = arguments\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tlet k: string\n\tif (own === false) {\n\t\tfor (k in obj) if (!DKeyMap[k] && callback(obj[k], k, obj) === STOP) return k\n\t} else {\n\t\tfor (k in obj) if (!DKeyMap[k] && hasOwnProp(obj, k) && callback(obj[k], k, obj) === STOP) return k\n\t}\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      each array                                      *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on array\n * - will stop each on callback return STOP\n */\nexport type EachArrayCallback<E> = (data: E, index: number, array: IArray<E>) => Control | void\n\n/**\n * each array\n * - will stop each on callback return STOP\n * @param array\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @return stoped index or false\n */\nexport function eachArray<E>(array: IArray<E>, callback: EachArrayCallback<E>, scope?: any): false | number {\n\tcallback = bind(callback, scope)\n\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\tif (callback(array[i], i, array) === STOP) return i\n\t}\n\treturn false\n}\n\n/**\n * reverse each array\n * - will stop each on callback return STOP\n * @param array\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @return stoped index or false\n */\nexport function reachArray<E>(array: IArray<E>, callback: EachArrayCallback<E>, scope?: any): false | number {\n\tcallback = bind(callback, scope)\n\tlet i = array.length\n\twhile (i--) if (callback(array[i], i, array) === STOP) return i\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         each                                         *\n *                                                                                      */\n//========================================================================================\n\nexport function doEach<E>(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: IArray<E>,\n\tcallback: EachArrayCallback<E>,\n\tscope?: any\n): false | number\nexport function doEach<E>(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: { [key: string]: E },\n\tcallback: EachObjCallback<E>,\n\town?: boolean\n): false | string\nexport function doEach<E>(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: { [key: string]: E },\n\tcallback: EachObjCallback<E>,\n\tscope?: any,\n\town?: boolean\n): false | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: any,\n\tcallback: any,\n\tscope?: any,\n\town?: boolean\n): false | number | string {\n\tif (isArrayLike(obj)) return _eachArray(obj, callback, scope)\n\treturn _eachObj(obj, callback, scope, own)\n}\n\n/**\n * each\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties on object, default: true\n * @return stoped index or false\n */\n\nexport function each<E>(obj: IArray<E>, callback: EachArrayCallback<E>, scope?: any): false | number\nexport function each<E>(obj: { [key: string]: E }, callback: EachObjCallback<E>, own?: boolean): false | string\nexport function each<E>(\n\tobj: { [key: string]: E },\n\tcallback: EachObjCallback<E>,\n\tscope?: any,\n\town?: boolean\n): false | string\nexport function each<E>(obj: any, callback: any, scope?: any, own?: boolean): false | number | string {\n\treturn doEach(eachArray, eachObj, obj, callback, scope, own)\n}\n","/**\n * @module util/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Thu Apr 04 2019 19:31:21 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './Control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport { create } from '../create'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool } from '../is'\n\n/**\n * SKIP Control\n * > skip map\n */\nexport const SKIP = new Control('SKIP')\n\n//========================================================================================\n/*                                                                                      *\n *                                    map object                                   *\n *                                                                                      */\n//========================================================================================\n\n/**\n * callback on object\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param value\tproperty value\n * @param prop\tproperty name\n * @param obj\tmap target\n */\nexport type MapObjCallback<T, E> = (data: E, prop: string, obj: { [key: string]: E }) => T | Control\n\nexport function doMapObj<T, E>(\n\teach: typeof eachObj,\n\tobj: { [key: string]: E },\n\tcallback: MapObjCallback<T, E>,\n\town?: boolean\n): { [key: string]: T }\nexport function doMapObj<T, E>(\n\teach: typeof eachObj,\n\tobj: { [key: string]: E },\n\tcallback: MapObjCallback<T, E>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T }\nexport function doMapObj<T, E>(\n\teach: typeof eachObj,\n\tobj: { [key: string]: E },\n\tcallback: MapObjCallback<T, E>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tconst copy: { [key: string]: T } = create(null)\n\teach(\n\t\tobj,\n\t\t(value, prop, obj) => {\n\t\t\tconst v = callback(value, prop, obj)\n\t\t\tif (v === STOP) return STOP\n\t\t\tif (v !== SKIP) copy[prop] = v as T\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn copy\n}\n\n/**\n * object: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param obj\t\tmap target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\tmap own properties, default: true\n */\nexport function mapObj<T, E>(\n\tobj: { [key: string]: E },\n\tcallback: MapObjCallback<T, E>,\n\town?: boolean\n): { [key: string]: T }\nexport function mapObj<T, E>(\n\tobj: { [key: string]: E },\n\tcallback: MapObjCallback<T, E>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T }\nexport function mapObj<T, E>(\n\tobj: { [key: string]: E },\n\tcallback: MapObjCallback<T, E>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } {\n\treturn doMapObj(eachObj, obj, callback, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     indexof Array                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * callback on array\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param data\titem data\n * @param index\titem index\n * @param array\tmap target\n */\nexport type MapArrayCallback<T, E> = (data: E, index: number, array: IArray<E>) => T | Control\n\nexport function doMapArray<T, E>(\n\teach: typeof eachArray,\n\tarray: IArray<E>,\n\tcallback: MapArrayCallback<T, E>,\n\tscope?: any\n): T[] {\n\tcallback = bind(callback, scope)\n\tconst copy: T[] = []\n\tlet j = 0\n\teach(array, (data, index, array) => {\n\t\tconst v = callback(data, index, array)\n\t\tif (v === STOP) return STOP\n\t\tif (v !== SKIP) copy[j++] = v as T\n\t})\n\treturn copy\n}\n\n/**\n * array: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param array\t\tmap target\n * @param value\t\tcallback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function mapArray<T, E>(array: IArray<E>, callback: MapArrayCallback<T, E>, scope?: any): T[] {\n\treturn doMapArray(eachArray, array, callback, scope)\n}\n\n/**\n * revice array: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param array\t\tmap target\n * @param value\t\tmap value of callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function rmapArray<T, E>(array: IArray<E>, callback: MapArrayCallback<T, E>, scope?: any): T[] {\n\treturn doMapArray(reachArray, array, callback, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       map                                       *\n *                                                                                      */\n//========================================================================================\n\nexport function doMap<T, E>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray<E>,\n\tcallback: MapArrayCallback<T, E>,\n\tscope?: any\n): T[]\nexport function doMap<T, E>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: { [key: string]: E },\n\tcallback: MapObjCallback<T, E>,\n\town?: boolean\n): { [key: string]: T }\nexport function doMap<T, E>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: { [key: string]: E },\n\tcallback: MapObjCallback<T, E>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T }\nexport function doMap<T, E>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: any,\n\tcallback: any,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | T[] {\n\tif (isArrayLike(obj)) return doMapArray(eacharray, obj, callback, scope)\n\treturn doMapObj(eachobj, obj, callback, scope, own)\n}\n\n/**\n * map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param obj\t\tmap target\n * @param value\t\tmap value of callback\n * @param scope\t\tscope of callback\n * @param own\t\tmap own properties on object, default: true\n * @return array index or property name or -1\n */\nexport function map<T, E>(obj: IArray<E>, callback: MapArrayCallback<T, E>, scope?: any): T[]\nexport function map<T, E>(\n\tobj: { [key: string]: E },\n\tcallback: MapObjCallback<T, E>,\n\town?: boolean\n): { [key: string]: T }\nexport function map<T, E>(\n\tobj: { [key: string]: E },\n\tcallback: MapObjCallback<T, E>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T }\nexport function map<T, E>(obj: any, callback: any, scope?: any, own?: boolean): { [key: string]: T } | T[] {\n\treturn doMap(eachArray, eachObj, obj, callback, scope, own)\n}\n","/**\n * @module util/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Thu Apr 04 2019 19:32:32 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './Control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool, isFn, eq } from '../is'\n\nfunction parseCallback(value: any, scope: any): any {\n\tif (isFn(value)) return bind(value, scope)\n\treturn function defaultHandler(data: any, idx: any, obj: any) {\n\t\treturn eq(data, value)\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    index of object                                   *\n *                                                                                      */\n//========================================================================================\n\n/**\n * indexOf callback on object\n * - will stop find on callback return STOP\n * @param value\tproperty value\n * @param prop\tproperty name\n * @param obj\t\tindexOf target\n * @return\n * - boolean: is finded\n * - void: find next\n * - STOP: stop find\n */\nexport type IdxOfObjCallback<E> = (value: E, prop: string, obj: { [key: string]: E }) => boolean | Control | void\n\nexport function doIdxOfObj<E>(each: typeof eachObj, obj: { [key: string]: E }, value: E, own?: boolean): -1 | string\nexport function doIdxOfObj<E>(\n\teach: typeof eachObj,\n\tobj: { [key: string]: E },\n\tvalue: IdxOfObjCallback<E>,\n\town?: boolean\n): -1 | string\nexport function doIdxOfObj<E>(\n\teach: typeof eachObj,\n\tobj: { [key: string]: E },\n\tvalue: IdxOfObjCallback<E>,\n\tscope?: any,\n\town?: boolean\n): -1 | string\n\nexport function doIdxOfObj<E>(\n\teach: typeof eachObj,\n\tobj: { [key: string]: E },\n\tvalue: IdxOfObjCallback<E> | E,\n\tscope?: any,\n\town?: boolean\n): -1 | string {\n\tif (isBool(scope)) {\n\t\town = scope\n\t\tscope = null\n\t}\n\tconst callback: IdxOfObjCallback<E> = parseCallback(value, scope)\n\tlet idx: -1 | string = -1\n\teach(\n\t\tobj,\n\t\t(data, prop, obj) => {\n\t\t\tconst r = callback(data, prop, obj)\n\t\t\tif (r === true) {\n\t\t\t\tidx = prop\n\t\t\t\treturn STOP\n\t\t\t} else if (r === STOP) return r\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn idx\n}\n\n/**\n * object: indexOf\n * - will stop find on callback return STOP\n * @param obj\t\tfind target\n * @param callback\tfind value or callback\n * @param scope\t\tscope of callback\n * @param own\t\tfind own properties, default: true\n * @return property name or -1\n */\nexport function idxOfObj<E>(obj: { [key: string]: E }, value: E, own?: boolean): -1 | string\nexport function idxOfObj<E>(obj: { [key: string]: E }, value: IdxOfObjCallback<E>, own?: boolean): -1 | string\nexport function idxOfObj<E>(\n\tobj: { [key: string]: E },\n\tvalue: IdxOfObjCallback<E>,\n\tscope?: any,\n\town?: boolean\n): -1 | string\nexport function idxOfObj<E>(\n\tobj: { [key: string]: E },\n\tvalue: IdxOfObjCallback<E> | E,\n\tscope?: any,\n\town?: boolean\n): -1 | string {\n\treturn doIdxOfObj(eachObj, obj, value as any, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     indexof Array                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * indexOf callback on array\n * - will stop find on callback return STOP\n * @param data\titem data\n * @param index\titem index\n * @param array\tindexOf target\n * @return\n * - boolean: is finded\n * - void: find next\n * - STOP: stop find\n */\nexport type IdxOfArrayCallback<E> = (data: E, index: number, array: IArray<E>) => boolean | Control | void\n\nexport function doIdxOfArray<E>(each: typeof eachArray, array: IArray<E>, value: E): number\nexport function doIdxOfArray<E>(\n\teach: typeof eachArray,\n\tarray: IArray<E>,\n\tvalue: IdxOfArrayCallback<E>,\n\tscope?: any\n): number\nexport function doIdxOfArray<E>(\n\teach: typeof eachArray,\n\tarray: IArray<E>,\n\tvalue: IdxOfArrayCallback<E> | E,\n\tscope?: any\n): number {\n\tconst callback: IdxOfArrayCallback<E> = parseCallback(value, scope)\n\tlet idx = -1\n\teach(array, (data, index, array) => {\n\t\tconst r = callback(data, index, array)\n\t\tif (r === true) {\n\t\t\tidx = index\n\t\t\treturn STOP\n\t\t} else if (r === STOP) return r\n\t})\n\treturn idx\n}\n\n/**\n * array: indexOf\n * - will stop find on callback return STOP\n * @param array\t\tfind target\n * @param value\t\tfind value or callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function idxOfArray<E>(array: IArray<E>, value: E): number\nexport function idxOfArray<E>(array: IArray<E>, value: IdxOfArrayCallback<E>, scope?: any): number\nexport function idxOfArray<E>(array: IArray<E>, value: IdxOfArrayCallback<E> | any, scope?: any): number {\n\treturn doIdxOfArray(eachArray, array, value, scope)\n}\n\n/**\n * revice array: indexOf\n * - will stop find on callback return STOP\n * @param array\t\tfind target\n * @param value\t\tfind value of callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function ridxOfArray<E>(array: IArray<E>, value: E): number\nexport function ridxOfArray<E>(array: IArray<E>, value: IdxOfArrayCallback<E>, scope?: any): number\nexport function ridxOfArray<E>(array: IArray<E>, value: IdxOfArrayCallback<E> | any, scope?: any): number {\n\treturn doIdxOfArray(reachArray, array, value, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       index of                                       *\n *                                                                                      */\n//========================================================================================\n// find by value\nexport function doIdxOf<E>(eacharray: typeof eachArray, eachobj: typeof eachObj, obj: IArray<E>, value: E): number\nexport function doIdxOf<E>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: { [key: string]: E },\n\tvalue: E,\n\town?: boolean\n): string\nexport function doIdxOf<E>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: { [key: string]: E } | IArray<E>,\n\tvalue: E,\n\town?: boolean\n): number | string\n// find by callback\nexport function doIdxOf<E>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray<E>,\n\tvalue: IdxOfArrayCallback<E>,\n\tscope?: any\n): number\nexport function doIdxOf<E>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: { [key: string]: E },\n\tvalue: IdxOfObjCallback<E>,\n\town?: boolean\n): -1 | string\nexport function doIdxOf<E>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: { [key: string]: E },\n\tvalue: IdxOfObjCallback<E>,\n\tscope?: any,\n\town?: boolean\n): -1 | string\nexport function doIdxOf<E>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: any,\n\tvalue: any,\n\tscope?: any,\n\town?: boolean\n): number | string {\n\tif (isArrayLike(obj)) return doIdxOfArray(eacharray, obj, value, scope)\n\treturn doIdxOfObj(eachobj, obj, value, scope, own)\n}\n\n/**\n * indexOf\n * - will stop find on callback return STOP\n * @param obj\t\tfind target\n * @param value\t\tfind value of callback\n * @param scope\t\tscope of callback\n * @param own\t\tfind own properties on object, default: true\n * @return array index or property name or -1\n */\nexport function idxOf<E>(obj: IArray<E>, value: E): number | string\nexport function idxOf<E>(obj: { [key: string]: E }, value: E, own?: boolean): number | string\nexport function idxOf<E>(obj: { [key: string]: E } | IArray<E>, value: E, own?: boolean): number | string\nexport function idxOf<E>(obj: IArray<E>, value: IdxOfArrayCallback<E>, scope?: any): number\nexport function idxOf<E>(obj: { [key: string]: E }, value: IdxOfObjCallback<E>, own?: boolean): -1 | string\nexport function idxOf<E>(obj: { [key: string]: E }, value: IdxOfObjCallback<E>, scope?: any, own?: boolean): -1 | string\nexport function idxOf<E>(obj: any, value: any, scope?: any, own?: boolean): number | string {\n\treturn doIdxOf(eachArray, eachObj, obj, value, scope, own)\n}\n","/**\n * @module util/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Thu Apr 04 2019 19:30:27 GMT+0800 (China Standard Time)\n */\nimport { Control } from './Control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool } from '../is'\n\n//========================================================================================\n/*                                                                                      *\n *                                     reduce object                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * reduce callback on object\n * - will stop reduce on return STOP\n */\nexport type ReduceObjCallback<T, E> = (accumulator: T, value: E, prop: string, obj: { [key: string]: E }) => T | Control\n\nexport function doReduceObj<T, E>(\n\teach: typeof eachObj,\n\tobj: { [key: string]: E },\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T, E>,\n\town?: boolean\n): T\nexport function doReduceObj<T, E>(\n\teach: typeof eachObj,\n\tobj: { [key: string]: E },\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T, E>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduceObj<T, E>(\n\teach: typeof eachObj,\n\tobj: { [key: string]: E },\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T, E>,\n\tscope?: any,\n\town?: boolean\n): T {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\teach(\n\t\tobj,\n\t\t(value, prop, obj) => {\n\t\t\tconst rs = callback(accumulator, value, prop, obj)\n\t\t\tif (rs === STOP) return STOP\n\t\t\taccumulator = rs as T\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn accumulator\n}\n\n/**\n * reduce object\n * - will stop reduce on callback return STOP\n * @param obj\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n * @param own\t\t\treduce own properties, default: true\n */\nexport function reduceObj<T, E>(\n\tobj: { [key: string]: E },\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T, E>,\n\town?: boolean\n)\nexport function reduceObj<T, E>(\n\tobj: { [key: string]: E },\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T, E>,\n\tscope?: any,\n\town?: boolean\n)\nexport function reduceObj<T, E>(\n\tobj: { [key: string]: E },\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T, E>,\n\tscope?: any,\n\town?: boolean\n): T {\n\treturn doReduceObj(eachObj, obj, accumulator, callback, scope, own)\n}\n//========================================================================================\n/*                                                                                      *\n *                                     reduce array                                     *\n *                                                                                      */\n//========================================================================================\n\n/**\n * reduce callback on array\n * - will stop reduce on return STOP\n */\nexport type ReduceArrayCallback<T, E> = (accumulator: T, data: E, index: number, array: IArray<E>) => T | Control\n\nexport function doReduceArray<T, E>(\n\teach: typeof eachArray,\n\tarray: IArray<E>,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T, E>,\n\tscope?: any\n): T {\n\tcallback = bind(callback, scope)\n\teach(array, (data, index, array) => {\n\t\tconst rs = callback(accumulator, data, index, array)\n\t\tif (rs === STOP) return STOP\n\t\taccumulator = rs as T\n\t})\n\treturn accumulator\n}\n\n/**\n * reduce array\n * - will stop reduce on callback return STOP\n * @param array\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n */\nexport function reduceArray<T, E>(\n\tarray: IArray<E>,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T, E>,\n\tscope?: any\n): T {\n\treturn doReduceArray(eachArray, array, accumulator, callback, scope)\n}\n\n/**\n * revice reduce array\n * - will stop reduce on callback return STOP\n * @param array\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n */\nexport function rreduceArray<T, E>(\n\tarray: IArray<E>,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T, E>,\n\tscope?: any\n): T {\n\treturn doReduceArray(reachArray, array, accumulator, callback, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        reduce                                        *\n *                                                                                      */\n//========================================================================================\n\nexport function doReduce<T, E>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray<E>,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T, E>,\n\tscope?: any\n): T\nexport function doReduce<T, E>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: { [key: string]: E },\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T, E>,\n\town?: boolean\n): T\nexport function doReduce<T, E>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: { [key: string]: E },\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T, E>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduce<T, E>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: any,\n\taccumulator: T,\n\tcallback: any,\n\tscope?: any,\n\town?: boolean\n): T {\n\tif (isArrayLike(obj)) return doReduceArray(eacharray, obj as IArray<E>, accumulator, callback, scope)\n\treturn doReduceObj(eachobj, obj, accumulator, callback, scope, own)\n}\n\n/**\n * reduce\n * - will stop reduce on callback return STOP\n * @param obj\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n * @param own\t\t\treduce own properties of reduce object, default: true\n */\nexport function reduce<T, E>(obj: IArray<E>, accumulator: T, callback: ReduceArrayCallback<T, E>, scope?: any): T\nexport function reduce<T, E>(\n\tobj: { [key: string]: E },\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T, E>,\n\town?: boolean\n): T\nexport function reduce<T, E>(\n\tobj: { [key: string]: E },\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T, E>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function reduce<T, E>(obj: any, accumulator: T, callback: any, scope?: any, own?: boolean): T {\n\treturn doReduce(eachArray, eachObj, obj, accumulator, callback, scope, own)\n}\n","/**\n * @module util/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Jul 26 2018 10:47:47 GMT+0800 (China Standard Time)\n * @modified Thu Apr 04 2019 19:49:02 GMT+0800 (China Standard Time)\n */\nimport { Control } from './Control'\nimport { STOP, eachObj, eachProps } from './each'\nimport { SKIP } from './map'\nimport { isBool, isFn } from '../is'\nimport { bind } from '../fn'\n\n//========================================================================================\n/*                                                                                      *\n *                                         keys                                         *\n *                                                                                      */\n//========================================================================================\n\nexport type ObjKeyHandler<T> = (prop: string, obj: object) => T | Control\n\nfunction defaultObjKeyHandler(prop: string, obj: object): any {\n\treturn prop\n}\nexport function doObjKeys<T>(each: typeof eachProps, obj: object, own?: boolean): T[]\nexport function doObjKeys<T>(each: typeof eachProps, obj: object, callback: ObjKeyHandler<T>, own?: boolean): T[]\nexport function doObjKeys<T>(\n\teach: typeof eachProps,\n\tobj: object,\n\tcallback: ObjKeyHandler<T>,\n\tscope?: any,\n\town?: boolean\n): T[]\nexport function doObjKeys<T>(\n\teach: typeof eachProps,\n\tobj: object,\n\tcallback_own?: ObjKeyHandler<T> | boolean,\n\tscope_own?: any,\n\town?: boolean\n): T[]\nexport function doObjKeys<T>(each: typeof eachProps, obj: object): T[] {\n\tconst rs: T[] = [],\n\t\targs = arguments\n\tlet handler: ObjKeyHandler<T> = defaultObjKeyHandler,\n\t\ti = 2,\n\t\tj = 0\n\tif (isFn(args[i])) {\n\t\thandler = args[i++]\n\t\tif (!isBool(args[i])) handler = bind(handler, args[i++])\n\t}\n\teach(\n\t\tobj,\n\t\t(prop, obj) => {\n\t\t\tconst val = handler(prop, obj)\n\t\t\tif (val === STOP) return STOP\n\t\t\tif (val !== SKIP) rs[j++] = val as T\n\t\t},\n\t\tnull,\n\t\targs[i]\n\t)\n\treturn rs\n}\n\n/**\n * @param obj\t\ttarget\n * @param handler\tkey handler\n * @param scope\t\tscope or handler\n * @param own\t\tis get own properties, default: true\n */\nexport function keys<T>(obj: object, own?: boolean): T[]\nexport function keys<T>(obj: object, callback: ObjKeyHandler<T>, own?: boolean): T[]\nexport function keys<T>(obj: object, callback: ObjKeyHandler<T>, scope?: any, own?: boolean): T[]\nexport function keys<T>(obj: object, callback?: ObjKeyHandler<T> | boolean, scope?: any, own?: boolean): T[] {\n\treturn doObjKeys(eachProps, obj, callback, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        values                                        *\n *                                                                                      */\n//========================================================================================\n\nexport type ObjValueHandler<T, E> = (value: E, prop: string, obj: { [key: string]: E }) => T | Control\n\nfunction defaultObjValueHandler<E>(value: any, prop: string, obj: { [key: string]: E }): any {\n\treturn value\n}\nexport function doObjValues<T, E>(each: typeof eachObj, obj: { [key: string]: E }, own?: boolean): T[]\nexport function doObjValues<T, E>(\n\teach: typeof eachObj,\n\tobj: { [key: string]: E },\n\tcallback: ObjValueHandler<T, E>,\n\town?: boolean\n): T[]\nexport function doObjValues<T, E>(\n\teach: typeof eachObj,\n\tobj: { [key: string]: E },\n\tcallback: ObjValueHandler<T, E>,\n\tscope?: any,\n\town?: boolean\n): T[]\nexport function doObjValues<T, E>(\n\teach: typeof eachObj,\n\tobj: { [key: string]: E },\n\tcallback_own?: ObjValueHandler<T, E> | boolean,\n\tscope_own?: any,\n\town?: boolean\n): T[]\nexport function doObjValues<T, E>(each: typeof eachObj, obj: { [key: string]: E }): T[] {\n\tconst rs: T[] = [],\n\t\targs = arguments\n\tlet handler: ObjValueHandler<T, E> = defaultObjValueHandler,\n\t\ti = 1,\n\t\tj = 0\n\tif (isFn(args[i])) {\n\t\thandler = args[i++]\n\t\tif (!isBool(args[i])) handler = bind(handler, args[i++])\n\t}\n\teach(\n\t\tobj,\n\t\tfunction(data, prop, obj) {\n\t\t\tconst val = handler(data, prop, obj)\n\t\t\tif (val === STOP) return STOP\n\t\t\tif (val !== SKIP) rs[j++] = val as T\n\t\t},\n\t\tnull,\n\t\targs[i]\n\t)\n\treturn rs\n}\n\n/**\n * @param obj\t\ttarget\n * @param handler\tvalue handler\n * @param scope\t\tscope or handler\n * @param own\t\tis get own properties, default: true\n */\nexport function values<T, E>(obj: { [key: string]: E }, own?: boolean): T[]\nexport function values<T, E>(obj: { [key: string]: E }, callback: ObjValueHandler<T, E>, own?: boolean): T[]\nexport function values<T, E>(\n\tobj: { [key: string]: E },\n\tcallback: ObjValueHandler<T, E>,\n\tscope?: any,\n\town?: boolean\n): T[]\nexport function values<T, E>(\n\tobj: { [key: string]: E },\n\tcallback?: ObjValueHandler<T, E> | boolean,\n\tscope?: any,\n\town?: boolean\n): T[] {\n\treturn doObjValues(eachObj, obj, callback, scope, own)\n}\n","/**\n * @module util/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Fri Nov 16 2018 16:29:04 GMT+0800 (China Standard Time)\n * @modified Thu Apr 04 2019 19:38:40 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './Control'\nimport { eachArray } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isFn, isStr, isArray } from '../is'\nimport { create } from '../create'\n\n/**\n * @return STOP or SKIP or [key: string, value: any]\n */\nexport type Arr2ObjCallback<E, T> = (data: E, index: number, array: IArray<E>) => Control | [string, T]\n\nexport function doArr2Obj<E, T>(\n\teach: typeof eachArray,\n\tarray: IArray<E>,\n\tcallback: Arr2ObjCallback<E, T>,\n\tscope?: any\n): { [key: string]: T } {\n\tconst obj: { [key: string]: T } = create(null)\n\tcallback = bind(callback, scope)\n\teach(array, (data, index, array) => {\n\t\tconst r: Control | [string, any] = callback(data, index, array)\n\t\tif (isArray(r)) {\n\t\t\tobj[r[0]] = r[1]\n\t\t} else {\n\t\t\treturn r as Control\n\t\t}\n\t})\n\treturn obj\n}\n\n/**\n * convert array to object\n */\nexport function arr2obj<E, T>(array: IArray<E>, callback: Arr2ObjCallback<E, T>, scope?: any): { [key: string]: T } {\n\treturn doArr2Obj(eachArray, array, callback, scope)\n}\n\n/**\n * convert array or string to object\n * @param array\n * @param val\tvalue or callback\n * @param split\tsplit char on string\n */\nexport function makeMap<E, T>(array: IArray<E>, val: Arr2ObjCallback<E, T>, split?: string): { [key: string]: T }\nexport function makeMap<E, T>(array: IArray<E>, val?: T, split?: string): { [key: string]: T }\nexport function makeMap(array: any, val?: any, split?: string) {\n\tif (isStr(array)) array = (array as string).split(isStr(split) ? split : ',')\n\treturn arr2obj(array, isFn(val) ? val : data => [data, val])\n}\n","/**\n * @module util/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Nov 15 2018 12:13:54 GMT+0800 (China Standard Time)\n * @modified Thu Mar 28 2019 19:39:52 GMT+0800 (China Standard Time)\n */\nimport { Control } from './Control'\nexport { STOP, eachProps, eachArray, eachObj, each } from './each'\nexport { SKIP, mapArray, mapObj, map } from './map'\nexport { idxOfArray, idxOfObj, idxOf } from './idxOf'\nexport { reduceArray, reduceObj, reduce } from './reduce'\nexport { keys, values } from './obj2arr'\nexport { arr2obj, makeMap } from './arr2obj'\n\nexport function makeArray<T>(len: number, callback: (index: number) => T): T[] {\n\tconst array = new Array(len)\n\tlet i = len\n\twhile (i--) array[i] = callback(i)\n\treturn array\n}\nexport type EachControl = Control\n","/**\n * @module util\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 18 2018 16:41:03 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 13:25:40 GMT+0800 (China Standard Time)\n */\n\nimport { hasOwnProp } from './ownProp'\n\nexport function mixin<B>(behaviour: B) {\n\treturn function mixin<M extends B, T extends { new (...args: Array<any>): M }>(Class: T) {\n\t\tconst proto = Class.prototype\n\t\tfor (var k in behaviour) if (hasOwnProp(behaviour, k)) proto[k] = behaviour[k]\n\t\treturn Class\n\t}\n}\n","/**\n * @module util/path\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Fri Nov 30 2018 14:41:02 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 13:47:29 GMT+0800 (China Standard Time)\n */\n\nimport { create, mapArray, defValue, addDKey, isArray } from '../util'\n\nexport const PATH_BINDING = addDKey('__path__')\nconst pathCache: { [key: string]: string[] } = create(null)\n\n// (^ | .) prop | (index | \"string prop\" | 'string prop')\nconst pathReg = /(?:^|\\.)([a-zA-Z$_][\\w$]*)|\\[\\s*(?:(\\d+)|\"((?:[^\\\\\"]|\\\\.)*)\"|'((?:[^\\\\']|\\\\.)*)')\\s*\\]/g\n\nexport function parsePath(propPath: string | string[], cacheable?: boolean): string[] {\n\tlet path: string[]\n\tif (isArray(propPath)) {\n\t\tpath = propPath as string[]\n\t} else if ((path = pathCache[propPath as string])) {\n\t\treturn path\n\t} else {\n\t\tpath = []\n\t\tvar match: string[],\n\t\t\tidx = 0,\n\t\t\tcidx: number,\n\t\t\ti = 0\n\t\twhile ((match = pathReg.exec(propPath as string))) {\n\t\t\tcidx = pathReg.lastIndex\n\t\t\tif (cidx !== idx + match[0].length)\n\t\t\t\tthrow new SyntaxError(\n\t\t\t\t\t`Invalid Path: \"${propPath}\", unkown character[${(propPath as string).charAt(\n\t\t\t\t\t\tidx\n\t\t\t\t\t)}] at offset:${idx}`\n\t\t\t\t)\n\t\t\tpath[i++] = match[1] || match[2] || match[3] || match[4]\n\t\t\tidx = cidx\n\t\t}\n\t\tif (propPath.length > idx + 1) {\n\t\t\tthrow new SyntaxError(\n\t\t\t\t`Invalid Path: \"${propPath}\", unkown character[${(propPath as string).charAt(idx)}] at offset:${idx}`\n\t\t\t)\n\t\t}\n\t\tif (cacheable !== false && i) {\n\t\t\tpathCache[propPath as string] = path\n\t\t}\n\t}\n\tif (!path.length) throw new Error(`Empty Path: ${propPath}`)\n\treturn path\n}\n\nexport function formatPath(path: string | (string[] & { path?: string })): string {\n\treturn isArray(path)\n\t\t? (path as string[] & { path?: string }).path ||\n\t\t\t\tdefValue(path, PATH_BINDING, mapArray(path, formatPathHandler).join(''))\n\t\t: (path as string)\n}\n\nfunction formatPathHandler(prop: string): string {\n\treturn `[\"${String(prop).replace(\"'\", '\\\\\"')}\"]`\n}\n\nexport function get<T>(obj: any, path: string | string[]): any {\n\tpath = parsePath(path)\n\tconst l = path.length - 1\n\tlet i = 0\n\tfor (; i < l; i++) {\n\t\tobj = obj[path[i]]\n\t\tif (obj === null || obj === undefined) return\n\t}\n\treturn obj[path[i]]\n}\n\nexport function set(obj: any, path: string | string[], value: any) {\n\tpath = parsePath(path)\n\tconst l = path.length - 1\n\tlet i = 0,\n\t\tv: any\n\tfor (; i < l; i++) {\n\t\tv = obj[path[i]]\n\t\tobj = v === null || v === undefined ? (obj[path[i]] = {}) : v\n\t}\n\tobj[path[i]] = value\n}\n","/**\n * @module format\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 03 2018 19:46:41 GMT+0800 (China Standard Time)\n * @modified Fri Apr 12 2019 14:14:40 GMT+0800 (China Standard Time)\n */\n\nimport { create, createFn, charCode, upper, escapeStr, cutStr, isFn, isNil, lower } from '../util'\nimport { get, parsePath } from '../path'\n\n//========================================================================================\n/*                                                                                      *\n *                                     pad & shorten                                    *\n *                                                                                      */\n//========================================================================================\n\nexport function pad(str: string, len: number, chr?: string, leftAlign?: boolean | number): string {\n\treturn len > str.length ? __pad(str, len, chr, leftAlign) : str\n}\n\nexport function shorten(str: string, len: number, suffix?: string): string {\n\treturn len < str.length ? ((suffix = suffix || ''), str.substr(0, len - suffix.length) + suffix) : str\n}\n\nfunction __pad(str: string, len: number, chr: string, leftAlign: boolean | number): string {\n\tconst pad = new Array(len - str.length + 1).join(chr || ' ')\n\treturn leftAlign ? str + pad : pad + str\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       Separator                                      *\n *                                                                                      */\n//========================================================================================\n\nexport const thousandSeparate = mkSeparator(3),\n\tbinarySeparate = mkSeparator(8, '01'),\n\toctalSeparate = mkSeparator(4, '0-7'),\n\thexSeparate = mkSeparator(4, '\\\\da-fA-F')\n\nfunction mkSeparator(group: number, valReg?: string): (numStr: string) => string {\n\tvalReg = valReg || '\\\\d'\n\tconst reg = new RegExp(\n\t\t`^(?:[+-]|\\\\s+|0[xXbBoO])|([${valReg}])(?=([${valReg}]{${group}})+(?![${valReg}]))|[^${valReg}].*`,\n\t\t'g'\n\t)\n\treturn numStr => numStr.replace(reg, separatorHandler)\n}\nfunction separatorHandler(m: string, d: string) {\n\treturn d ? d + ',' : m\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                   plural & singular                                  *\n *                                                                                      */\n//========================================================================================\n\nconst PLURAL_REG = /([a-zA-Z]+)([^aeiou])y$|([sxzh])$|([aeiou]y)$|([^sxzhy])$/\nexport function plural(str: string): string {\n\treturn str.replace(PLURAL_REG, pluralHandler)\n}\nfunction pluralHandler(m: string, v: string, ies: string, es: string, ys: string, s: string) {\n\treturn v + (ies ? ies + 'ies' : es ? es + 'es' : (ys || s) + 's')\n}\n\nconst SINGULAR_REG = /([a-zA-Z]+)([^aeiou])ies$|([sxzh])es$|([aeiou]y)s$|([^sxzhy])s$/\nexport function singular(str: string): string {\n\treturn str.replace(SINGULAR_REG, singularHandler)\n}\nfunction singularHandler(m: string, v: string, ies: string, es: string, ys: string, s: string) {\n\treturn v + (ies ? ies + 'y' : es || ys || s)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     format flags                                     *\n *                                                                                      */\n//========================================================================================\n\ntype FormatFlags = number\n\nexport const FORMAT_XPREFIX: FormatFlags = 0x1,\n\tFORMAT_PLUS: FormatFlags = 0x2,\n\tFORMAT_ZERO: FormatFlags = 0x4,\n\tFORMAT_SPACE: FormatFlags = 0x8,\n\tFORMAT_SEPARATOR: FormatFlags = 0x10,\n\tFORMAT_LEFT: FormatFlags = 0x20\n\nconst FLAG_MAPPING = {\n\t'#': FORMAT_XPREFIX,\n\t'+': FORMAT_PLUS,\n\t'0': FORMAT_ZERO,\n\t' ': FORMAT_SPACE,\n\t',': FORMAT_SEPARATOR,\n\t'-': FORMAT_LEFT\n}\nfunction parseFlags(f: string): FormatFlags {\n\tlet flags: FormatFlags = 0\n\tif (f) {\n\t\tvar i = f.length\n\t\twhile (i--) flags |= FLAG_MAPPING[f.charAt(i)]\n\t}\n\treturn flags\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      format Rule                                     *\n *                                                                                      */\n//========================================================================================\n\n//   0      1      2     3     4       5       6           7         8      9           10             11             12        13\n// [match, expr, index, prop, flags, width, width-idx, width-prop, fill, precision, precision-idx, precision-prop, shorten-suffix, type]\nconst paramIdxR = `(\\\\d+|\\\\$|@)`,\n\tparamPropR = `(?:\\\\{((?:[a-zA-Z$_][\\\\w$_]*|\\\\[(?:\\\\d+|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)*\"|'(?:[^\\\\\\\\']|\\\\\\\\.)*')\\\\])(?:\\\\.[a-zA-Z$_][\\\\w$_]*|\\\\[(?:\\\\d+|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)*\"|'(?:[^\\\\\\\\']|\\\\\\\\.)*')\\\\])*)\\\\})`,\n\twidthR = `(?:([1-9]\\\\d*)|&${paramIdxR}${paramPropR})`,\n\tfillR = `(?:=(.))`,\n\tshortenSuffixR = `(?:=\"((?:[^\\\\\\\\\"]|\\\\\\\\.)*)\")`,\n\tformatReg = new RegExp(\n\t\t`\\\\\\\\.|(\\\\{${paramIdxR}?${paramPropR}?(?::([#,+\\\\- 0]*)(?:${widthR}${fillR}?)?(?:\\\\.${widthR}${shortenSuffixR}?)?)?([a-zA-Z_][a-zA-Z0-9_$]*)?\\\\})`,\n\t\t'g'\n\t)\n\n//========================================================================================\n/*                                                                                      *\n *                                      Formatters                                      *\n *                                                                                      */\n//========================================================================================\n\nexport type FormatCallback = (\n\tval: any,\n\tflags: FormatFlags,\n\twidth: number,\n\tfill: string,\n\tprecision: number,\n\tshortenSuffix: string\n) => string\n\nconst formatters: {\n\t[k: string]: FormatCallback\n} = create(null)\n\nexport function extendFormatter(obj: { [key: string]: FormatCallback }) {\n\tvar fmt: FormatCallback, name: string\n\tfor (name in obj) {\n\t\tfmt = obj[name]\n\t\tisFn(fmt) && (formatters[name] = fmt)\n\t}\n}\n\nexport function getFormatter(name: string): FormatCallback {\n\tconst f = formatters[name || 's']\n\tif (f) return f\n\tthrow new Error(`Invalid Formatter: ${name}`)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                           format by every parameter object                           *\n *                                                                                      */\n//========================================================================================\n\n/**\n * Syntax:\n * @example\n * \t'{'\n * \t\t(<parameter>)?\n * \t\t(\n * \t\t\t':'\n * \t\t\t(<flags>)?\n * \t\t\t(\n * \t\t\t\t<width> ('=' <fill-char>)?\n * \t\t\t)?\n * \t\t\t(\n * \t\t\t\t'.'\n * \t\t\t\t<precision> ('=' '\"' <shorten-suffix> '\"')?\n * \t\t\t)?\n * \t\t)?\n * \t\t(<type>)?\n * \t'}'\n *\n * - parameter\n * \t\t- {}\t\t\t\t\tformat by next unused argument\n * \t\t- {<number>}\t\t\tformat by arguments[number]\n * \t\t- {@}\t\t\t\t\tformat by current used argument\n * \t\t- {$}\t\t\t\t\tformat by next unused argument\n * \t\t- {{name}}\t\t\t\tformat by \"name\" property on next unused argument\n * \t\t- {<number>{name}}\t\tformat by \"name\" property on arguments[number]\n * \t\t- {@{name}}\t\t\t\tformat by \"name\" property on current used argument\n * \t\t- {${name}}\t\t\t\tformat by \"name\" property on next unused argument\n * @example\n * \t\tformat('<{} {}>', 'abc')\t\t\t\t// return \"<abc undefined>\"\n * \t\tformat('<{$} {$}>', 'abc')\t\t\t\t// return \"<abc undefined>\"\n * \t\tformat('<{@} {} {@}>', 'abc')\t\t\t// return \"<abc abc abc>\"\n * \t\tformat('<{0} {} {0}>', 'abc')\t\t\t// return \"<abc abc abc>\"\n * \t\tformat('<{0{value}} {${value}} {@{value}} {{value.a}}>', {value: 'abc'}, {value: {a: 'cbd'}})\n * \t\t// return \"<abc abc abc bcd>\"\n * \t\tformat('<{0{[0]}} {${[0]}} {@{[0]}} {{[0].a}}>', ['abc'], [{a: 'cbd'}])\n * \t\t// return \"<abc abc abc bcd>\"\n *\n * - flags\n * \t\t- {:#}    \tFORMAT_XPREFIX\n * \t\t\t\t\tensure the leading \"0\" for any octal\n * \t\t\t\t\tprefix non-zero hexadecimal with \"0x\" or \"0X\"\n * \t\t\t\t\tprefix non-zero binary with \"0b\" or \"0B\"\n * \t\t- {:+}    \tFORMAT_PLUS\n * \t\t\t\t\tForces to preceed the result with a plus or minus sign (+ or -) even for positive numbers.\n * \t\t\t\t\tBy default, only negative numbers are preceded with a - sign\n * \t\t- {:0}\t\tFORMAT_ZERO\n * \t\t\t\t\tLeft-pads the number with zeroes (0) instead of spaces when padding is specified\n * \t\t- {: }   \tFORMAT_SPACE\n * \t\t\t\t\tIf no sign is going to be written, a blank space is inserted before the value\n * \t\t- {:,}\t\tFORMAT_SEPARATOR\n * \t\t\t\t\tuse thousand separator on decimal number\n * \t\t\t\t\thexadecimal number: FFFFFFFF => FFFF,FFFF\n * \t\t\t\t\toctal number: 77777777 => 7777,7777\n * \t\t\t\t\tbinary number: 1111111111111111 => 11111111,11111111\n * \t\t{:-}    \tFORMAT_LEFT\n * \t\t\t\t\tLeft-justify within the given field width; Right justification is the default\n * @example\n * \t\tformat('<{: d}>',  12);\t\t// return \"< 12>\"\n *\t\tformat('<{: d}>',   0);\t\t// return \"< 0>\"\n *\t\tformat('<{: d}>', -12);\t\t// return \"<-12>\"\n *\t\tformat('<{:+d}>',  12);\t\t// return \"<+12>\"\n *\t\tformat('<{:+d}>',   0);\t\t// return \"<+0>\"\n *\t\tformat('<{:+d}>', -12);\t\t// return \"<-12>\"\n *\t\tformat('<{:6s}>',  12);\t\t// return \"<    12>\"\n *\t\tformat('<{:-6s}>', 12);\t\t// return \"<12    >\"\n *\t\tformat('<{:#o}>',  12);\t\t// return \"<014>\"\n *\t\tformat('<{:#x}>',  12);\t\t// return \"<0xc>\"\n *\t\tformat('<{:#X}>',  12);\t\t// return \"<0XC>\"\n *\t\tformat('<{:#b}>',  12);\t\t// return \"<0b1100>\"\n *\t\tformat('<{:#B}>',  12);\t\t// return \"<0B1100>\"\n\n * - width\n * \t\tMinimum number of characters to be printed.\n * \t\tIf the value to be printed is shorter than this number, the result is padded with pad char(default is space).\n * \t\tThe value is not truncated even if the result is larger.\n *\t\t- width value\n * \t\t\t{:<number>}\n * \t\t\t{:&@}\n * \t\t\t{:&$}\n * \t\t\t{:&<number>}\n * \t\t\t{:&@{<prop>}}\n * \t\t\t{:&${<prop>}}\n * \t\t\t{:&<number>{<prop>}}\n *\t\t- pad char\n * \t\t\t{:&@=<pad-char>}\n * \t\t\t{:&$=<pad-char>}\n * \t\t\t{:&<number>=<pad-char>}\n * \t\t\t{:&@{<prop>}=<pad-char>}\n * \t\t\t{:&${<prop>}=<pad-char>}\n * \t\t\t{:&<number>{<prop>}=<pad-char>}\n * @example\n * - precision\n * \t\tFor integer specifiers (d,  o, u, x, X): precision specifies the minimum number of digits to be written.\n * \t\tIf the value to be written is shorter than this number, the result is padded with leading zeros.\n * \t\tThe value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0.\n * \t\tFor a, A, e, E, f and F specifiers: this is the number of digits to be printed after the decimal point (by default, this is 6).\n * \t\tFor g and G specifiers: This is the maximum number of significant digits to be printed.\n * \t\tFor s: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered.\n * \t\tIf the period is specified without an explicit value for precision, 0 is assumed.\n * \t\t- precision value\n * \t\t\t{:.<number>}\n * \t\t\t{:.&@}\n * \t\t\t{:.&$}\n * \t\t\t{:.&<number>}\n * \t\t\t{:.&@{<prop>}}\n * \t\t\t{:.&${<prop>}}\n * \t\t\t{:.&<number>{<prop>}}\n * \t\t- shorten suffix\n * \t\t\t{:.&@=\"<suffix>\"}\n * \t\t\t{:.&$=\"<suffix>\"}\n * \t\t\t{:.&<number>=\"<suffix>\"}\n * \t\t\t{:.&@{<prop>}=\"<suffix>\"}\n * \t\t\t{:.&${<prop>}=\"<suffix>\"}\n * \t\t\t{:.&<number>{<prop>}=\"<suffix>\"}\n * - type\n * \t\t- default types\n *\t\t\t- {c}\t\tCharacter\n * \t\t\t- {s}\t\tString\n * \t\t\t- {j}\t\tJSON String\n * \t\t\t- {y}\t\tDate Year\n * \t\t\t- {m}\t\tDate Month\n * \t\t\t- {w}\t\tDate Weekly\n * \t\t\t- {W}\t\tDate Weekly\n * \t\t\t- {D}\t\tDate\n * \t\t\t- {H}\t\tDate\n * \t\t\t- {M}\t\tDate\n * \t\t\t- {S}\t\tDate\n * \t\t\t- {d} \t\tSigned decimal integer\n *\t\t\t- {u}\t\tUnsigned decimal integer\n *\t\t\t- {o}\t\tUnsigned octal\n *\t\t\t- {x}\t\tUnsigned hexadecimal integer\n *\t\t\t- {X}\t\tUnsigned hexadecimal integer (uppercase)\n *\t\t\t- {f}\t\tDecimal floating point, lowercase,\n *\t\t\t- {e}\t\tScientific notation (mantissa/exponent), lowercase\n *\t\t\t- {E}\t\tScientific notation (mantissa/exponent), uppercase\n *\t\t\t- {g}\t\tUse the shortest representation: %e or %f\n *\t\t\t- {G}\t\tUse the shortest representation: %E or %F\n * - Rules\n * \t\t- property-path\n * \t\t\t\t(\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t[a-zA-Z$_][\\w$_]*|\n * \t\t\t\t\t\t\\[\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\\d+|\n * \t\t\t\t\t\t\t\"(?:[^\\\\\"]|\\\\.)*\"|\n * \t\t\t\t\t\t\t'(?:[^\\\\']|\\\\.)*'\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t\\]\n * \t\t\t\t\t)\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t\\.[a-zA-Z$_][\\w$_]*|\n * \t\t\t\t\t\t\\[\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\\d+|\n * \t\t\t\t\t\t\t\"(?:[^\\\\\"]|\\\\.)*\"|\n * \t\t\t\t\t\t\t'(?:[^\\\\']|\\\\.)*'\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t\\]\n * \t\t\t\t\t)*\n * \t\t\t\t)\n * \t\t- expression\n * \t\t\t/\\\\.|\t\t\t\t\t\t\t\t\t\t\t\t// escape\n * \t\t\t(\t\t\t\t\t\t\t\t\t\t\t\t\t// 1: expression\n * \t\t\t\t\\{\n * \t\t\t\t(\\d+|\\$|@)?\t\t\t\t\t\t\t\t\t\t// 2: parameter index\n * \t\t\t\t(?:\\{<property-path>\\})?\t\t\t\t\t\t// 3: property path of parameter\n * \t\t\t\t(?:\n * \t\t\t\t\t:\n * \t\t\t\t\t([#,+\\- ]*)\t\t\t\t\t\t\t\t\t// 4: flags\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t(\\d+)|\t\t\t\t\t\t\t\t// 5: width\n * \t\t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\t&\n * \t\t\t\t\t\t\t\t(\\d+|\\$|@)\t\t\t\t\t\t// 6: parameter index of width\n * \t\t\t\t\t\t\t\t(?:\\{<property-path>\\})?\t\t// 7: property path of width parameter\n * \t\t\t\t\t\t\t)\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t(?:=(.))?\t\t\t\t\t\t\t\t// 8: pad fill\n * \t\t\t\t\t)?\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t\\.\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t(\\d+)|\t\t\t\t\t\t\t\t// 9: width\n * \t\t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\t&\n * \t\t\t\t\t\t\t\t(\\d+|\\$|@)\t\t\t\t\t\t// 10: parameter index of width\n * \t\t\t\t\t\t\t\t(?:\\{<property-path>\\})?\t\t// 11: property path of width parameter\n * \t\t\t\t\t\t\t)\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t=\n * \t\t\t\t\t\t\t\"\n * \t\t\t\t\t\t\t((?:[^\\\\\"]|\\\\.)*)\t\t\t\t\t// 12: shorten su\n * \t\t\t\t\t\t\t\"\n * \t\t\t\t\t\t)\n * \t\t\t\t\t)?\n * \t\t\t\t)?\n * \t\t\t\t([a-zA-Z_][a-zA-Z0-9_$]*)?\t\t\t\t\t\t// 13: data type\n * \t\t\t\t\\}\n * \t\t\t)/\n * @param fmt \t\tformat String\n * @param args\t\tformat arguments\n * @param offset\tstart offset of arguments\n * @param getParam\tget parameter on arguments callback\n */\nexport function vformat<T>(fmt: string, args: T, offset?: number, getParam?: (args: T, idx: number) => any): string {\n\toffset = offset || 0\n\tconst start = offset\n\tgetParam = getParam || defaultGetParam\n\treturn fmt.replace(formatReg, function(\n\t\ts,\n\t\tm,\n\t\tparam,\n\t\tparamProp,\n\t\tflags,\n\t\twidth,\n\t\twidx,\n\t\twprop,\n\t\tfill,\n\t\tprecision,\n\t\tpidx,\n\t\tpprop,\n\t\tshortenSuffix,\n\t\ttype\n\t) {\n\t\tif (!m) return s.charAt(1)\n\t\treturn getFormatter(type)(\n\t\t\tparseParam(param || '$', paramProp),\n\t\t\tparseFlags(flags),\n\t\t\tparseWidth(width, widx, wprop) || 0,\n\t\t\tfill,\n\t\t\tparseWidth(precision, pidx, pprop),\n\t\t\tshortenSuffix\n\t\t)\n\t})\n\n\tfunction parseWidth<T>(width: string, idx: string, prop: string): number {\n\t\tif (width) return (width as any) >> 0\n\t\tif (idx) {\n\t\t\tconst w = parseParam(idx, prop) >> 0\n\t\t\tif (isFinite(w)) return w\n\t\t}\n\t}\n\n\tfunction parseParam<T>(paramIdx: string, prop: string): any {\n\t\tlet param = getParam(\n\t\t\targs,\n\t\t\tparamIdx === '$'\n\t\t\t\t? offset++\n\t\t\t\t: paramIdx === '@'\n\t\t\t\t? offset === start\n\t\t\t\t\t? offset\n\t\t\t\t\t: offset - 1\n\t\t\t\t: (paramIdx as any) >> 0\n\t\t)\n\t\treturn prop ? get(param, prop) : param\n\t}\n}\n\nfunction defaultGetParam(args: any, idx: number) {\n\treturn args[idx]\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        format                                        *\n *                                                                                      */\n//========================================================================================\n\n/**\n * @see vformat\n * @param fmt\tformat string\n * @param args\tformat arguments\n */\nexport function format(fmt: string, ...args: any): string\nexport function format(fmt: string): string {\n\treturn vformat(fmt, arguments, 0, getFormatParam)\n}\n\nfunction getFormatParam(args: IArguments, idx: number) {\n\treturn args[idx + 1]\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       formatter                                      *\n *                                                                                      */\n//========================================================================================\n\nconst GET_PARAM_VAR = 'getp',\n\tGET_PROP_VAR = 'get',\n\tSTATE_VAR = 'state'\nfunction createFormatter(\n\tm: string[],\n\tgetParam?: (args: IArguments, idx: number) => any\n): (args: any[], state: [number, number]) => string {\n\treturn createFn(\n\t\t`return function(args, ${STATE_VAR}){\nreturn fmt(${getParamCode(m[2] || '$', m[3])},\n\"${parseFlags(m[4])}\",\n${getWidthCode(m[5], m[6], m[7], '0')},\n\"${m[8] ? escapeStr(m[8]) : ' '}\",\n${getWidthCode(m[9], m[10], m[11], 'void 0')},\n\"${m[12] ? escapeStr(m[12]) : ''}\");\n}`,\n\t\t['fmt', GET_PROP_VAR, GET_PARAM_VAR]\n\t)(getFormatter(m[13]), get, getParam)\n}\n\nfunction getWidthCode(width: string, idx: string, prop: string, def: string): string {\n\treturn width ? width : idx ? getParamCode(idx, prop) : def\n}\n\nfunction getParamCode(idx: string, prop: string): string {\n\tlet code = `${GET_PARAM_VAR}(args, ${\n\t\tidx === '$'\n\t\t\t? `${STATE_VAR}[0]++`\n\t\t\t: idx === '@'\n\t\t\t? `${STATE_VAR}[0] === ${STATE_VAR}[1] ? ${STATE_VAR}[0] : ${STATE_VAR}[0] - 1`\n\t\t\t: idx\n\t})`\n\tif (prop) {\n\t\tconst path = parsePath(prop)\n\t\tvar i = path.length\n\t\tconst strs = new Array(i)\n\t\twhile (i--) strs[i] = `\"${escapeStr(path[i])}\"`\n\t\treturn `${GET_PROP_VAR}(${code}, [${strs.join(', ')}])`\n\t}\n\treturn code\n}\n\nexport type Formatter = (...args: any[]) => string\nexport type FormatParamLoader = (args: IArguments, idx: number) => any\n/**\n * @see vformat\n * @param fmt\t\tformat string\n * @param offset\tstart offset of arguments\n * @param getParam\tget parameter on arguments callback\n */\nexport function formatter(fmt: string, offset?: number, getParam?: FormatParamLoader): Formatter {\n\tlet m: string[],\n\t\tlastIdx = 0,\n\t\tmStart: number,\n\t\tmEnd: number,\n\t\tarr: (string | ((args: any[], state: [number, number]) => string))[] = [],\n\t\tcodes: string[] = [],\n\t\ti = 0\n\toffset = offset || 0\n\tformatReg.lastIndex = 0\n\twhile ((m = formatReg.exec(fmt))) {\n\t\tmEnd = formatReg.lastIndex\n\t\tmStart = mEnd - m[0].length\n\t\tlastIdx < mStart && pushStr(cutStr(fmt, lastIdx, mStart))\n\t\tif (m[1]) {\n\t\t\tcodes[i] = `arr[${i}](arguments, ${STATE_VAR})`\n\t\t\tarr[i++] = createFormatter(m, getParam || defaultGetParam)\n\t\t} else {\n\t\t\tpushStr(m[0].charAt(1), i)\n\t\t}\n\t\tlastIdx = mEnd\n\t}\n\tlastIdx < fmt.length && pushStr(cutStr(fmt, lastIdx), i)\n\treturn createFn(`return function(){var ${STATE_VAR} = [${offset}, ${offset}]; return ${codes.join(' + ')}}`, [\n\t\t'arr'\n\t])(arr)\n\n\tfunction pushStr(str: string, append?: any) {\n\t\tif (append && (arr[i - 1] as string).match) {\n\t\t\tarr[i - 1] += str\n\t\t} else {\n\t\t\tcodes[i] = `arr[${i}]`\n\t\t\tarr[i++] = str\n\t\t}\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                  default formatters                                  *\n *                                                                                      */\n//========================================================================================\n\nfunction strFormatter(toStr: (val: any, flags: FormatFlags) => string): FormatCallback {\n\treturn function(val, flags, width, fill, precision, shortenSuffix) {\n\t\tconst str = toStr(val, flags)\n\t\treturn width > str.length\n\t\t\t? __pad(str, width, fill, flags & FORMAT_LEFT)\n\t\t\t: shorten(str, precision, shortenSuffix)\n\t}\n}\n\nfunction numFormatter(\n\tparseNum: (val: any) => number,\n\tgetPrefix: (num: number, flags: FormatFlags) => string,\n\ttoStr: (num: number, flags: FormatFlags, precision: number) => string,\n\tseparator: (numStr: string) => string\n): FormatCallback {\n\treturn function(val, flags, width, fill, precision) {\n\t\tconst num = parseNum(val)\n\t\tif (!isFinite(num)) return String(num)\n\n\t\tconst prefix = getPrefix(num, flags),\n\t\t\tplen = prefix.length\n\t\tlet str = toStr(num < 0 ? -num : num, flags, precision)\n\n\t\treturn flags & FORMAT_ZERO\n\t\t\t? ((str = prefix + pad(str, width - plen, '0')), flags & FORMAT_SEPARATOR ? separator(str) : str)\n\t\t\t: (flags & FORMAT_SEPARATOR && (str = separator(str)), pad(prefix + str, width, fill, flags & FORMAT_LEFT))\n\t}\n}\n\nfunction decimalPrefix(num: number, flags: FormatFlags): string {\n\treturn num < 0 ? '-' : flags & FORMAT_PLUS ? '+' : flags & FORMAT_SPACE ? ' ' : ''\n}\n\n// base formatter \nconst BASE_RADIXS = {\n\tb: [2, binarySeparate],\n\to: [8, octalSeparate],\n\tu: [10, thousandSeparate],\n\tx: [16, hexSeparate]\n}\nconst BASE_PREFIXS = ['0b', '0o', '0x']\nfunction baseFormatter(type: string): FormatCallback {\n\tconst base = BASE_RADIXS[lower(type)],\n\t\tn = base[0],\n\t\t__toStr = (num: number) => num.toString(n),\n\t\ttoStr = type === 'X' ? (num: number) => upper(__toStr(num)) : __toStr\n\tlet xprefix = n === 10 ? '' : BASE_PREFIXS[n >> 3]\n\tcharCode(type) < 96 && (xprefix = upper(xprefix))\n\treturn numFormatter(v => v >>> 0, (num, flags) => (flags & FORMAT_XPREFIX ? xprefix : ''), toStr, base[1])\n}\n\n// float formatter \nfunction floatFormatter(type: string): FormatCallback {\n\tconst ____toStr = upper(type) === 'E' ? toExponential : type === 'f' ? toFixed : toPrecision,\n\t\t__toStr = (num: number, flags: FormatFlags, precision: number) => ____toStr(num, precision) || String(num),\n\t\ttoStr =\n\t\t\tcharCode(type) > 96\n\t\t\t\t? __toStr\n\t\t\t\t: (num: number, flags: FormatFlags, precision: number) => upper(__toStr(num, flags, precision))\n\treturn numFormatter(parseFloat, decimalPrefix, toStr, thousandSeparate)\n}\n\nfunction toExponential(num: number, precision: number): string {\n\treturn num.toExponential(precision)\n}\nfunction toPrecision(num: number, precision: number): string {\n\treturn precision && num.toPrecision(precision)\n}\nfunction toFixed(num: number, precision: number): string {\n\treturn precision >= 0 && num.toFixed(precision)\n}\n\n// register formatters \nextendFormatter({\n\ts: strFormatter(toStr),\n\tj: strFormatter(v => (isNil(v) || isFn(v) ? toStr(v) : ((v = JSON.stringify(v)), v === undefined) ? toStr(v) : v)),\n\tc(val: any) {\n\t\tconst num = val >> 0\n\t\treturn num > 0 ? String.fromCharCode(num) : ''\n\t},\n\td: numFormatter(val => val >> 0, decimalPrefix, toStr, thousandSeparate),\n\te: floatFormatter('e'),\n\tE: floatFormatter('E'),\n\tf: floatFormatter('f'),\n\tg: floatFormatter('g'),\n\tG: floatFormatter('G'),\n\tb: baseFormatter('b'),\n\tB: baseFormatter('B'),\n\to: baseFormatter('o'),\n\tO: baseFormatter('O'),\n\tu: baseFormatter('u'),\n\tx: baseFormatter('x'),\n\tX: baseFormatter('X')\n})\n\nfunction toStr(v: any): string {\n\treturn String(v)\n}\n","/**\n * @module assert\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Nov 28 2018 11:01:45 GMT+0800 (China Standard Time)\n * @modified Thu Apr 11 2019 13:49:48 GMT+0800 (China Standard Time)\n */\n\nimport {\n\tcreate,\n\tupperFirst,\n\tcreateFn,\n\teachObj,\n\tmakeArray,\n\tdeepEq,\n\teq,\n\tisBool,\n\tisNum,\n\tisStr,\n\tisBoolean,\n\tisNumber,\n\tisString,\n\tisDate,\n\tisNull,\n\tisUndef,\n\tisNil,\n\tisFn,\n\tisInt,\n\tisPrimitive,\n\tisReg,\n\tisArray,\n\tisArrayLike,\n\tisTypedArray,\n\tisObj,\n\tisBlank\n} from '../util'\nimport { T_UNDEF, T_FN, T_STRING, T_NUM, T_BOOL, P_CTOR } from '../util/consts'\nimport { formatter, Formatter } from '../format'\n\nexport interface assert {\n\t(msg?: string, ...args: any[]): never\n\tis(actual: any, msg?: string, ...args: any[]): assert\n\tnot(actual: any, msg?: string, ...args: any[]): assert\n\n\teq(actual: any, expect: any, msg?: string, ...args: any[]): assert\n\tnotEq(actual: any, expect: any, msg?: string, ...args: any[]): assert\n\n\teql(actual: any, expect: any, msg?: string, ...args: any[]): assert\n\tnotEql(actual: any, expect: any, msg?: string, ...args: any[]): assert\n\n\tblank(actual: any, msg?: string, ...args: any[]): assert\n\tnotBlank(actual: any, msg?: string, ...args: any[]): assert\n\n\tnul(actual: any, msg?: string, ...args: any[]): assert\n\tnotNul(actual: any, msg?: string, ...args: any[]): assert\n\n\tnil(actual: any, msg?: string, ...args: any[]): assert\n\tnotNil(actual: any, msg?: string, ...args: any[]): assert\n\n\tundef(actual: any, msg?: string, ...args: any[]): assert\n\tnotUndef(actual: any, msg?: string, ...args: any[]): assert\n\n\tbool(actual: any, msg?: string, ...args: any[]): assert\n\tnotBool(actual: any, msg?: string, ...args: any[]): assert\n\n\tnum(actual: any, msg?: string, ...args: any[]): assert\n\tnotNum(actual: any, msg?: string, ...args: any[]): assert\n\n\tint(actual: any, msg?: string, ...args: any[]): assert\n\tnotInt(actual: any, msg?: string, ...args: any[]): assert\n\n\tstr(actual: any, msg?: string, ...args: any[]): assert\n\tnotStr(actual: any, msg?: string, ...args: any[]): assert\n\n\tfn(actual: any, msg?: string, ...args: any[]): assert\n\tnotFn(actual: any, msg?: string, ...args: any[]): assert\n\n\tprimitive(actual: any, msg?: string, ...args: any[]): assert\n\tnotPrimitive(actual: any, msg?: string, ...args: any[]): assert\n\n\tboolean(actual: any, msg?: string, ...args: any[]): assert\n\tnotBoolean(actual: any, msg?: string, ...args: any[]): assert\n\n\tnumber(actual: any, msg?: string, ...args: any[]): assert\n\tnotNumber(actual: any, msg?: string, ...args: any[]): assert\n\n\tstring(actual: any, msg?: string, ...args: any[]): assert\n\tnotString(actual: any, msg?: string, ...args: any[]): assert\n\n\tdate(actual: any, msg?: string, ...args: any[]): assert\n\tnotDate(actual: any, msg?: string, ...args: any[]): assert\n\n\treg(actual: any, msg?: string, ...args: any[]): assert\n\tnotReg(actual: any, msg?: string, ...args: any[]): assert\n\n\tarray(actual: any, msg?: string, ...args: any[]): assert\n\tnotArray(actual: any, msg?: string, ...args: any[]): assert\n\n\ttypedArray(actual: any, msg?: string, ...args: any[]): assert\n\tnotTypedArray(actual: any, msg?: string, ...args: any[]): assert\n\n\tarrayLike(actual: any, msg?: string, ...args: any[]): assert\n\tnotArrayLike(actual: any, msg?: string, ...args: any[]): assert\n\n\tobj(actual: any, msg?: string, ...args: any[]): assert\n\tnotObj(actual: any, msg?: string, ...args: any[]): assert\n\n\tnan(actual: any, msg?: string, ...args: any[]): assert\n\tnotNan(actual: any, msg?: string, ...args: any[]): assert\n\n\tfinite(actual: number | string, msg?: string, ...args: any[]): assert\n\tnotFinite(actual: any, msg?: string, ...args: any[]): assert\n\n\tless(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\tnotLess(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\n\tgreater(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\tnotGreater(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\n\tmatch(actual: string, expect: any, msg?: string, ...args: any[]): assert\n\tnotMatch(actual: string, expect: any, msg?: string, ...args: any[]): assert\n\n\trange(actual: number, start: number, end: number, msg?: string, ...args: any[]): assert\n\tnotRange(actual: number, start: number, end: number, msg?: string, ...args: any[]): assert\n\n\tthrow(fn: () => any, err?: Error | string, msg?: string, ...args: any[]): assert\n\tnotThrow(fn: () => any, err?: Error | string, msg?: string, ...args: any[]): assert\n\n\texecutor<T extends (...args: any[]) => any>(fn: T, maxCall: number, msg?: string): T & { called: number }\n}\n\nconst formatters: { [msg: string]: Formatter } = create(null)\nfunction mkError(Err: { new (message?: string): Error }, msg: string, args: any[] | IArguments, msgIdx: number): Error {\n\tconst fmtter =\n\t\tformatters[msg] ||\n\t\t(formatters[msg] = formatter(msg, msgIdx, (args, offset) => args[0][offset >= msgIdx ? offset + 1 : offset]))\n\treturn popErrStack(new Err(fmtter(args)), 2)\n}\n\nexport function popErrStack(err: Error, i: number): Error {\n\tif (err.stack)\n\t\twhile (i-- > 0) {\n\t\t\terr.stack = err.stack.replace(/(\\n\\s{4}at[^\\n]*)/, '')\n\t\t}\n\treturn err\n}\n\nexport const assert = function assert(msg?: string): never {\n\tthrow mkError(Error, msg || 'Error', arguments, 0)\n} as assert\n\nfunction mkThrowAssertor(th: boolean, dmsg: string, ERROR?: any) {\n\treturn function throwErr(fn: () => any, expect: Error | string, msg?: string) {\n\t\tlet err: Error\n\t\ttry {\n\t\t\tfn()\n\t\t} catch (e) {\n\t\t\terr = e\n\t\t}\n\t\tif (\n\t\t\tth !==\n\t\t\t!!(\n\t\t\t\terr &&\n\t\t\t\t(!expect ||\n\t\t\t\t\t(isStr(expect)\n\t\t\t\t\t\t? expect === err.message\n\t\t\t\t\t\t: err[P_CTOR] === (expect as Error)[P_CTOR] &&\n\t\t\t\t\t\t  (!(expect as Error).message || (expect as Error).message === err.message)))\n\t\t\t)\n\t\t) {\n\t\t\targuments[0] = err\n\t\t\t!expect && (arguments[1] = ERROR)\n\t\t\tthrow mkError(Error, msg || dmsg, arguments, 2)\n\t\t}\n\t\treturn assert\n\t}\n}\n\nassert.throw = mkThrowAssertor(true, `expected catched error {0s} is {1s}`, new Error())\nassert.notThrow = mkThrowAssertor(false, `expected catched error {0s} is not {1s}`)\n\n/**\n * @param name \t\tname of the assertor\n * @param condition condition, function or expression\n * @param args \t\tname or length of the parameters\n * @param dmsg  \tthe default message\n * @param Err  \t\tthe Error Constructor, default Error\n */\nfunction mkAssertor<T extends (...args: any[]) => assert>(\n\tname: string,\n\tcondition: string | ((...args: any) => boolean) | [string | ((...args: any) => boolean), string?],\n\targs: string | string[] | number,\n\tdmsg: string,\n\tErr?: { new (message?: string): Error }\n): T {\n\tconst params: string[] = isStr(args)\n\t\t\t? (args as string).split(/,/g)\n\t\t\t: isNum(args)\n\t\t\t? makeArray(args as number, i => `arg${i + 1}`)\n\t\t\t: (args as string[]),\n\t\tparamStr = params.join(', '),\n\t\tcond = isArray(condition) ? condition[0] : condition,\n\t\texpr = (isArray(condition) ? condition[1] : '') + (isStr(cond) ? `(${cond})` : `cond(${paramStr})`)\n\n\treturn (assert[name] = createFn(\n\t\t`return function assert${upperFirst(name)}(${paramStr}, msg){\n\tif (${expr})\n\t\tthrow mkErr(Err, msg || dmsg, arguments, ${params.length});\n\treturn assert;\n}`,\n\t\t['Err', 'mkErr', 'dmsg', 'cond', 'assert']\n\t)(Err || Error, mkError, dmsg, cond, assert))\n}\n\n// [condition, argcount?, [msg, not msg], Error]\nfunction mkAssertors(apis: {\n\t[method: string]: [\n\t\tstring | ((...args: any) => boolean), // condition, function or expression\n\t\tstring | number | string[], // arguments\n\t\t[string, string], // expect or [err msg, not err msg]\n\t\t({ new (message?: string): Error })? // the Error Constructor, default Error\n\t]\n}) {\n\teachObj(apis, (desc, name) => {\n\t\tconst condition = desc[0],\n\t\t\targs = desc[1],\n\t\t\tmsg = desc[2],\n\t\t\tErr = desc[3] || TypeError\n\n\t\tmsg[0] && mkAssertor(name, [condition, '!'], args, msg[0], Err)\n\t\tmsg[1] && mkAssertor('not' + upperFirst(name), condition, args, msg[1], Err)\n\t})\n}\n\nconst UNDEFINED = T_UNDEF,\n\tBOOLEAN = T_BOOL,\n\tNUMBER = T_NUM,\n\tSTRING = T_STRING,\n\tFUNCTION = T_FN,\n\tNULL = 'null',\n\tINTEGER = 'integer',\n\tARRAY = 'Array',\n\tTYPED_ARRAY = 'TypedArray'\n\nmkAssertor('is', '!o', 'o', expectMsg('exist'))\nmkAssertor('not', 'o', 'o', expectMsg('exist', true))\nmkAssertors({\n\teq: [eq, 2, mkMsg(objFormatter(1))],\n\teql: [deepEq, 2, mkMsg(objFormatter(1))],\n\tnul: [isNull, 1, mkMsg(NULL)],\n\tnil: [isNil, 1, mkMsg(typeExpect(NULL, UNDEFINED))],\n\tundef: [isUndef, 1, mkMsg(UNDEFINED)],\n\tbool: [isBool, 1, mkMsg(BOOLEAN)],\n\tnum: [isNum, 1, mkMsg(NUMBER)],\n\tint: [isInt, 1, mkMsg(INTEGER)],\n\tstr: [isStr, 1, mkMsg(STRING)],\n\tfn: [isFn, 1, mkMsg(FUNCTION)],\n\tprimitive: [\n\t\tisPrimitive,\n\t\t1,\n\t\tmkMsg(`Primitive type(${typeExpect(NULL, UNDEFINED, BOOLEAN, NUMBER, INTEGER, STRING, FUNCTION)})`)\n\t],\n\tboolean: [isBoolean, 1, mkMsg(packTypeExpect(BOOLEAN))],\n\tnumber: [isNumber, 1, mkMsg(packTypeExpect(NUMBER))],\n\tstring: [isString, 1, mkMsg(packTypeExpect(STRING))],\n\tdate: [isDate, 1, mkMsg('Date')],\n\treg: [isReg, 1, mkMsg('RegExp')],\n\tarray: [isArray, 1, mkMsg(ARRAY)],\n\ttypedArray: [isTypedArray, 1, mkMsg('TypedArray')],\n\tarrayLike: [\n\t\tisArrayLike,\n\t\t1,\n\t\tmkMsg(typeExpect(ARRAY, packTypeExpect(STRING), 'Arguments', TYPED_ARRAY, 'NodeList', 'HTMLCollection'))\n\t],\n\tobj: [isObj, 1, mkMsg('Object')],\n\tnan: [isNaN, 1, mkMsg('NaN')],\n\tfinite: [isFinite, 1, mkMsg('Finite')],\n\tblank: [isBlank, 1, mkMsg('Blank')],\n\tless: ['o<t', 'o,t', mkMsg(objFormatter(1), 'less than')],\n\tgreater: ['o>t', 'o,t', mkMsg(objFormatter(1), 'greater than')],\n\tmatch: ['reg.test(str)', 'str,reg', mkMsg(objFormatter(1), 'match')],\n\trange: ['o>=s&&o<e', 'o,s,e', mkMsg(`[{1} - {2})`)]\n})\n\nfunction mkMsg(expect: string, to?: string): [string, string] {\n\treturn [expectMsg(expect, false, to), expectMsg(expect, true, to)]\n}\nfunction expectMsg(expect: string, not?: boolean, to?: string): string {\n\treturn `expected ${objFormatter(0)} ${not ? 'not ' : ''}${to || 'to'} ${expect}`\n}\n\nfunction objFormatter(idx: number): string {\n\treturn `{${idx}:.80=\"...\"j}`\n}\n\nfunction packTypeExpect(base: string, all?: boolean): string {\n\treturn all ? typeExpect(base, upperFirst(base)) : upperFirst(base)\n}\nfunction typeExpect(...types: string[]): string\nfunction typeExpect(): string {\n\treturn Array.prototype.join.call(arguments, ' | ')\n}\n","/**\n * Double Linked List\n * @module util/list\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 18:28:27 GMT+0800 (China Standard Time)\n */\n\nimport { bind, defValue, addDKey } from '../util'\nimport { assert } from '../assert'\nimport { EMPTY_FN } from '../util/consts'\n\nconst DEFAULT_BINDING = addDKey('__list__')\n\ninterface ListNode<T> extends Array<any> {\n\t0: T // target\n\t1: ListNode<T> // prev node\n\t2: ListNode<T> // next node\n\t3: List<T> // list\n\t4: number // version\n\ttoJSON?: () => any\n}\n\nexport class List<T> {\n\tstatic readonly binding: string = DEFAULT_BINDING\n\n\treadonly binding: string\n\tprivate __head?: ListNode<T>\n\tprivate __tail?: ListNode<T>\n\tprivate __length: number = 0\n\tprivate __scaning: boolean = false\n\tprivate __lazyRemoves?: ListNode<T>[]\n\tprivate __ver: number = 0\n\tconstructor(binding?: string) {\n\t\tthis.binding = binding || DEFAULT_BINDING\n\t}\n\tsize(): number {\n\t\treturn this.__length\n\t}\n\thas(obj: T): boolean {\n\t\tconst node: ListNode<T> = obj[this.binding]\n\t\treturn node ? node[0] === obj && node[3] === this : false\n\t}\n\t/**\n\t *\n\t * @param obj\n\t * @return new length\n\t */\n\tadd(obj: T): number {\n\t\treturn this.__insert(obj, this.__tail)\n\t}\n\t/**\n\t *\n\t * @param obj\n\t * @return new length\n\t */\n\taddFirst(obj: T): number {\n\t\treturn this.__insert(obj)\n\t}\n\t/**\n\t *\n\t * @param obj\n\t * @return new length\n\t */\n\tinsertAfter(obj: T, target?: T): number {\n\t\treturn this.__insert(obj, target && this.__getNode(target))\n\t}\n\t/**\n\t *\n\t * @param obj\n\t * @return new length\n\t */\n\tinsertBefore(obj: T, target?: T): number {\n\t\treturn this.__insert(obj, target && this.__getNode(target)[1])\n\t}\n\t/**\n\t *\n\t * @param objs\n\t * @return new length\n\t */\n\taddAll(objs: T[]): number {\n\t\treturn this.__insertAll(objs, this.__tail)\n\t}\n\taddFirstAll(objs: T[]): number {\n\t\treturn this.__insertAll(objs)\n\t}\n\tinsertAfterAll(objs: T[], target?: T): number {\n\t\treturn this.__insertAll(objs, target && this.__getNode(target))\n\t}\n\tinsertBeforeAll(objs: T[], target?: T): number {\n\t\treturn this.__insertAll(objs, target && this.__getNode(target)[1])\n\t}\n\tprev(obj: T): T {\n\t\treturn this.__siblingObj(obj, 1)\n\t}\n\tnext(obj: T): T {\n\t\treturn this.__siblingObj(obj, 2)\n\t}\n\tfirst(): T {\n\t\tconst node: ListNode<T> = this.__head\n\t\treturn node && node[0]\n\t}\n\tlast(): T {\n\t\tconst node: ListNode<T> = this.__tail\n\t\treturn node && node[0]\n\t}\n\teach(cb: (obj: T) => boolean | void, scope?: any) {\n\t\tif (this.__length) {\n\t\t\tassert.not(this.__scaning, 'Nested calls are not allowed.')\n\t\t\tthis.__scaning = true\n\n\t\t\tconst __ver = ++this.__ver\n\n\t\t\tcb = bind(cb, scope)\n\t\t\tvar node = this.__head,\n\t\t\t\terr: Error\n\n\t\t\twhile (node) {\n\t\t\t\tif (node[3] === this) {\n\t\t\t\t\tif (__ver === node[4]) break\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (cb(node[0]) === false) break\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\terr = e\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode = node[2]\n\t\t\t}\n\t\t\tthis.__doLazyRemove()\n\t\t\tthis.__scaning = false\n\t\t\tif (err) throw err\n\t\t}\n\t}\n\teachUnsafe(cb: (obj: T) => boolean | void, scope?: any) {\n\t\tif (this.__length) {\n\t\t\tvar node = this.__head\n\t\t\twhile (node) {\n\t\t\t\tif (node[3] === this && cb(node[0]) === false) break\n\t\t\t\tnode = node[2]\n\t\t\t}\n\t\t}\n\t}\n\ttoArray(): T[] {\n\t\tconst array: T[] = new Array(this.__length)\n\t\tlet node = this.__head,\n\t\t\ti = 0\n\t\twhile (node) {\n\t\t\tif (node[3] === this) array[i++] = node[0]\n\t\t\tnode = node[2]\n\t\t}\n\t\treturn array\n\t}\n\t/**\n\t *\n\t * @param obj\n\t * @return new length\n\t */\n\tremove(obj: T): number {\n\t\treturn this.__remove(this.__getNode(obj))\n\t}\n\tclean() {\n\t\tif (this.__length) {\n\t\t\tif (this.__scaning) {\n\t\t\t\tvar node = this.__head\n\t\t\t\twhile (node) {\n\t\t\t\t\tnode[3] === this && this.__lazyRemove(node)\n\t\t\t\t\tnode = node[2]\n\t\t\t\t}\n\t\t\t\tthis.__length = 0\n\t\t\t} else {\n\t\t\t\tthis.__clean()\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate __initNode(obj: T): ListNode<T> {\n\t\tconst { binding } = this\n\t\tlet node: ListNode<T> = obj[binding]\n\t\tif (node && node[0] === obj) {\n\t\t\tif (node[3] === this) {\n\t\t\t\tthis.__remove(node)\n\t\t\t\treturn this.__initNode(obj)\n\t\t\t} else if (node[3]) {\n\t\t\t\tassert('Object is still in some List')\n\t\t\t}\n\t\t\tnode[3] = this\n\t\t\tnode[4] = this.__ver\n\t\t} else {\n\t\t\tnode = [obj, , , this, this.__ver]\n\t\t\tnode.toJSON = EMPTY_FN\n\t\t\tdefValue(obj, binding, node, false)\n\t\t}\n\t\treturn node\n\t}\n\n\tprivate __getNode(obj: T): ListNode<T> {\n\t\tconst node: ListNode<T> = obj[this.binding]\n\t\tassert.is(node && node[0] === obj && node[3] === this, 'Object is not in this List')\n\t\treturn node\n\t}\n\n\tprivate __siblingObj(obj: T, siblingIdx: number): T {\n\t\tconst node: ListNode<T> = this.__getNode(obj)\n\t\tlet sibling: ListNode<T> = node[siblingIdx]\n\t\tif (sibling) {\n\t\t\twhile (!sibling[3]) {\n\t\t\t\tsibling = sibling[siblingIdx]\n\t\t\t\tif (!sibling) return\n\t\t\t}\n\t\t\treturn sibling[0]\n\t\t}\n\t}\n\n\tprivate __doInsert(nodeHead: ListNode<T>, nodeTail: ListNode<T>, len: number, prev?: ListNode<T>): number {\n\t\tlet next: ListNode<T>\n\t\tnodeHead[1] = prev\n\t\tif (prev) {\n\t\t\tnodeTail[2] = next = prev[2]\n\t\t\tprev[2] = nodeHead\n\t\t} else {\n\t\t\tnodeTail[2] = next = this.__head\n\t\t\tthis.__head = nodeHead\n\t\t}\n\t\tif (next) next[1] = nodeTail\n\t\telse this.__tail = nodeTail\n\t\treturn (this.__length += len)\n\t}\n\n\tprivate __insert(obj: T, prev?: ListNode<T>): number {\n\t\tconst node = this.__initNode(obj)\n\t\treturn this.__doInsert(node, node, 1, prev)\n\t}\n\n\tprivate __insertAll(objs: T[], prev?: ListNode<T>): number {\n\t\tlet l = objs.length\n\t\tif (l) {\n\t\t\tconst head = this.__initNode(objs[0])\n\t\t\tvar __prev = head,\n\t\t\t\ttail = head,\n\t\t\t\ti = 1\n\t\t\tfor (; i < l; i++) {\n\t\t\t\ttail = this.__initNode(objs[i])\n\t\t\t\ttail[1] = __prev\n\t\t\t\t__prev[2] = tail\n\t\t\t\t__prev = tail\n\t\t\t}\n\t\t\treturn this.__doInsert(head, tail, l, prev)\n\t\t}\n\t\treturn -1\n\t}\n\n\tprivate __remove(node: ListNode<T>): number {\n\t\tthis.__scaning ? this.__lazyRemove(node) : this.__doRemove(node)\n\t\treturn --this.__length\n\t}\n\n\tprivate __lazyRemove(node: ListNode<T>): void {\n\t\tconst { __lazyRemoves: lazyRemoves } = this\n\t\tnode[0][this.binding] = null // unbind this node\n\t\tnode[3] = null\n\t\tif (lazyRemoves) {\n\t\t\tlazyRemoves.push(node)\n\t\t} else {\n\t\t\tthis.__lazyRemoves = [node]\n\t\t}\n\t}\n\n\tprivate __doLazyRemove() {\n\t\tconst { __lazyRemoves: lazyRemoves } = this\n\t\tif (lazyRemoves) {\n\t\t\tvar len = lazyRemoves.length\n\t\t\tif (len) {\n\t\t\t\tif (this.__length) {\n\t\t\t\t\twhile (len--) this.__doRemove(lazyRemoves[len])\n\t\t\t\t} else {\n\t\t\t\t\tthis.__clean()\n\t\t\t\t}\n\t\t\t\tlazyRemoves.length = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate __doRemove(node: ListNode<T>) {\n\t\tconst prev = node[1],\n\t\t\tnext = node[2]\n\t\tif (prev) {\n\t\t\tprev[2] = next\n\t\t} else {\n\t\t\tthis.__head = next\n\t\t}\n\t\tif (next) {\n\t\t\tnext[1] = prev\n\t\t} else {\n\t\t\tthis.__tail = prev\n\t\t}\n\t\tnode.length = 1\n\t}\n\n\tprivate __clean() {\n\t\tlet node: ListNode<T>,\n\t\t\tnext = this.__head\n\t\twhile ((node = next)) {\n\t\t\tnext = node[2]\n\t\t\tnode.length = 1\n\t\t}\n\t\tthis.__head = null\n\t\tthis.__tail = null\n\t\tthis.__length = 0\n\t}\n}\n","/**\n * Function List\n * @module util/list\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 14:05:16 GMT+0800 (China Standard Time)\n */\n\nimport { List } from './List'\nimport { create, defValue, addDKey } from '../util'\n\nconst DEFAULT_FN_BINDING = addDKey('__flist_id__')\nconst DEFAULT_SCOPE_BINDING = addDKey(DEFAULT_FN_BINDING)\n\ntype FnNode<T extends Function> = [string, T, any, any]\nexport class FnList<T extends Function> {\n\tstatic readonly fnBinding: string = DEFAULT_FN_BINDING\n\tstatic readonly scopeBinding: string = DEFAULT_SCOPE_BINDING\n\n\treadonly fnBinding: string\n\treadonly scopeBinding: string\n\tprivate readonly __list: List<FnNode<T>>\n\tprivate __nodeMap: { [key: string]: FnNode<T> }\n\n\tconstructor(fnBinding?: string, scopeBinding?: string) {\n\t\tthis.__nodeMap = create(null)\n\t\tthis.__list = new List()\n\t\tthis.fnBinding = fnBinding || DEFAULT_FN_BINDING\n\t\tthis.scopeBinding = scopeBinding || DEFAULT_SCOPE_BINDING\n\t}\n\t/**\n\t * add executable function\n\t * @param fn\t\tfunction\n\t * @param scope\t\tscope of function\n\t * @param data\t\tuser data of [function + scope]\n\t * @return executable function id, can remove executable function by id: {@link FnList#removeId}\n\t */\n\tadd(fn: T, scope?: any, data?: any): string {\n\t\tscope = parseScope(scope)\n\t\tconst { __list: list, __nodeMap: nodeMap } = this\n\t\tconst id = this.id(fn, scope)\n\t\tlet node = nodeMap[id]\n\t\tif (!node) {\n\t\t\tnode = [id, fn, scope, data]\n\t\t\tif (list.add(node)) nodeMap[id] = node\n\t\t\treturn id\n\t\t}\n\t}\n\n\t/**\n\t * remove executable function by id\n\t *\n\t * @param id\n\t */\n\tremoveId(id: string): number {\n\t\tconst { __list: list, __nodeMap: nodeMap } = this\n\t\tconst node = nodeMap[id]\n\t\tif (node) {\n\t\t\tnodeMap[id] = undefined\n\t\t\treturn list.remove(node)\n\t\t}\n\t\treturn -1\n\t}\n\tremove(fn: T, scope?: any): number {\n\t\treturn this.removeId(this.id(fn, parseScope(scope)))\n\t}\n\thas(fn: T, scope?: any): string {\n\t\tconst id = this.id(fn, parseScope(scope))\n\t\treturn this.__nodeMap[id] && id\n\t}\n\thasId(id: string): boolean {\n\t\treturn !!this.__nodeMap[id]\n\t}\n\tsize(): number {\n\t\treturn this.__list.size()\n\t}\n\tclean() {\n\t\tthis.__nodeMap = create(null)\n\t\tthis.__list.clean()\n\t}\n\teach(cb: (fn: T, scope: any, data: any, __node: FnNode<T>) => boolean | void, scope?: any) {\n\t\tcb = cb.bind(scope)\n\t\tthis.__list.each(node => cb(node[1], node[2], node[3], node))\n\t}\n\teachUnsafe(cb: (fn: T, scope: any, data: any, __node: FnNode<T>) => boolean | void, scope?: any) {\n\t\tthis.__list.eachUnsafe(node => cb(node[1], node[2], node[3], node))\n\t}\n\tid(fn: T, scope?: any): string {\n\t\tconst { fnBinding, scopeBinding } = this\n\n\t\tlet fnId = fn[fnBinding],\n\t\t\tscopeId = scope ? scope[scopeBinding] : DEFAULT_SCOPE_ID\n\t\tif (!fnId) fnId = defValue(fn, fnBinding, ++fnIdGenerator, false, false, false)\n\t\tif (!scopeId) scopeId = defValue(scope, scopeBinding, ++scopeIdGenerator, false, false, false)\n\t\treturn `${fnId}#${scopeId}`\n\t}\n}\n\nconst DEFAULT_SCOPE_ID = 1\nlet scopeIdGenerator = 1,\n\tfnIdGenerator = 0\n\nfunction parseScope(scope: any): any {\n\treturn !scope ? undefined : scope\n}\n","/**\n * @module util/nextTick\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 14:04:49 GMT+0800 (China Standard Time)\n */\nimport { FnList } from '../list'\nimport { T_FN } from '../util/consts'\n\nlet next: () => void\nif (typeof MutationObserver === T_FN) {\n\t// chrome18+, safari6+, firefox14+,ie11+,opera15\n\tconst textNode = document.createTextNode(v)\n\n\tnew MutationObserver(flush).observe(textNode, {\n\t\tcharacterData: true\n\t})\n\tvar v = ''\n\tnext = function() {\n\t\ttextNode.data = v = v ? '' : '0'\n\t}\n} else {\n\tnext = function() {\n\t\tsetTimeout(flush, 0)\n\t}\n}\n\nconst ticks = [new FnList<() => void>(), new FnList<() => void>()]\nlet pending: FnList<() => void>,\n\ti = 0\n\nfunction executeTick(fn: () => void, scope?: any) {\n\tscope ? fn.call(scope) : fn()\n}\n\nfunction flush() {\n\tconst t = pending\n\tpending = null\n\tt.each(executeTick)\n\tt.clean()\n}\n\nexport function nextTick(fn: () => void, scope?: any): string {\n\tif (!pending) {\n\t\tpending = ticks[++i & 1]\n\t\tnext()\n\t}\n\treturn pending.add(fn, scope)\n}\n\nexport function clearTick(fn: () => void, scope?: any) {\n\treturn pending.remove(fn, scope)\n}\n\nexport function clearTickId(id: string) {\n\treturn pending.removeId(id)\n}\n","/**\n * @module util/Source\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 17 2018 10:41:21 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 13:58:29 GMT+0800 (China Standard Time)\n */\n\nimport { pad } from '../format'\nimport { escapeStr } from '../util'\n\nconst LINE_REG = /([^\\n]+)?(\\n|$)/g\nexport class Source {\n\treadonly buff: string\n\treadonly len: number\n\tprivate __lines: ([number, string])[]\n\tprivate __linePos: number\n\tconstructor(buff: string) {\n\t\tthis.buff = buff\n\t\tthis.len = buff.length\n\t\tthis.__lines = []\n\t\tthis.__linePos = 0\n\t}\n\tposition(offset: number): [number, number, string] {\n\t\tconst { buff, len, __lines: lines, __linePos: linePos } = this\n\t\tlet i = lines.length,\n\t\t\tp: number\n\t\tif (offset < linePos) {\n\t\t\twhile (i--) {\n\t\t\t\tp = offset - lines[i][0]\n\t\t\t\tif (p >= 0) return [i + 1, p, lines[i][1]]\n\t\t\t}\n\t\t} else {\n\t\t\tif (linePos < len) {\n\t\t\t\tvar m: string[]\n\t\t\t\tLINE_REG.lastIndex = p = linePos\n\t\t\t\twhile ((m = LINE_REG.exec(buff))) {\n\t\t\t\t\tlines[i++] = [p, m[1] || '']\n\t\t\t\t\tp = LINE_REG.lastIndex\n\t\t\t\t\tif (!p || offset < p) break\n\t\t\t\t}\n\t\t\t\tthis.__linePos = p || len\n\t\t\t}\n\t\t\treturn i ? [i, (offset > len ? len : offset) - lines[i - 1][0], lines[i - 1][1]] : [1, 0, '']\n\t\t}\n\t}\n\tsource(escape?: boolean): string {\n\t\tconst { buff } = this\n\t\tlet line = 1,\n\t\t\ttoSourceStr = escape ? escapeSourceStr : sourceStr\n\n\t\treturn buff.replace(LINE_REG, (m, s, t) => pad(String(line++), 3) + ': ' + toSourceStr(m, s, t))\n\t}\n}\n\nfunction sourceStr(m: string, s: string, t: string) {\n\treturn m || ''\n}\n\nfunction escapeSourceStr(m: string, s: string, t: string) {\n\treturn s ? escapeStr(s) + t : t\n}\n","/**\n * utilities for ast builder\n *\n * @module util/AST\n * @author Tao Zeng (tao.zeng.zt@qq.com)\n * @created 2018-11-09 13:22:51\n * @modified 2018-11-09 13:22:51 by Tao Zeng (tao.zeng.zt@qq.com)\n */\nimport { charCode, isStr, isArray, isInt, isNum } from '../util'\n\nexport function genCharCodes(start: number | string, end: number | string, ignoreCase?: boolean) {\n\tlet s: number = isNum(start) ? (start as number) : charCode(start as string),\n\t\te: number = isNum(end) ? (end as number) : charCode(end as string),\n\t\tcodes: number[] = new Array(e - s),\n\t\ti = 0\n\tif (ignoreCase) {\n\t\tvar c: number\n\t\tfor (; s <= e; s++) {\n\t\t\tcodes[i++] = s\n\t\t\tc = getAnotherCode(s)\n\t\t\tcodes[i++] = c\n\t\t}\n\t} else {\n\t\tfor (; s <= e; s++) codes[i++] = s\n\t}\n\treturn codes\n}\n\n/**\n * each char codes\n */\nexport function eachCharCodes(codes: number | string | any[], ignoreCase: boolean, cb: (code: number) => void) {\n\tlet i: number\n\tif (isStr(codes)) {\n\t\ti = (codes as any).length\n\t\twhile (i--) eachCharCode(charCode(codes as any, i), ignoreCase, cb)\n\t} else if (isArray(codes)) {\n\t\ti = (codes as any).length\n\t\twhile (i--) eachCharCodes((codes as any)[i], ignoreCase, cb)\n\t} else if (isInt(codes)) {\n\t\teachCharCode(codes as any, ignoreCase, cb)\n\t}\n}\nfunction eachCharCode(code: number, ignoreCase: boolean, cb: (code: number) => void): void {\n\tcb(code)\n\tif (ignoreCase) {\n\t\tvar c = getAnotherCode(code)\n\t\tc && cb(c)\n\t}\n}\n\nfunction getAnotherCode(code: number) {\n\treturn code <= 90 ? (code >= 65 ? code + 32 : 0) : code <= 122 ? code - 32 : 0\n}\n","/**\n * @module util/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:06:22 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 13:58:23 GMT+0800 (China Standard Time)\n */\nimport { MatchContext } from './MatchContext'\nimport { eachCharCodes } from './util'\nimport { assert } from '../assert'\nimport { isBool, mixin } from '../util'\n\n@mixin({ $ruleErr: true })\nexport class MatchError {\n\treadonly $ruleErr: boolean\n\treadonly rule: Rule\n\treadonly context: MatchContext\n\treadonly source: MatchError\n\treadonly target: MatchError\n\tcapturable: boolean\n\treadonly pos: number\n\tmsg: string\n\tconstructor(msg: string, capturable: boolean, source: MatchError, context: MatchContext, rule: Rule) {\n\t\t!isBool(capturable) && (capturable = rule.capturable)\n\t\tthis.capturable = capturable && source ? source.capturable : capturable\n\t\tthis.msg = msg\n\t\tthis.source = source\n\t\tthis.target = source ? source.target : this\n\t\tthis.context = context\n\t\tthis.rule = rule\n\t\tthis.pos = context.startPos()\n\t}\n\tposition(): [number, number, string] {\n\t\treturn this.context.source.position(this.pos)\n\t}\n}\n\nexport type onMatchCallback = (data: any, len: number, context: MatchContext, rule: Rule) => MatchError | string | void\nexport type onErrorCallback = (err: MatchError, context: MatchContext, rule: Rule) => MatchError | string | void\n\nfunction defaultErr(err: MatchError) {\n\treturn err\n}\n\nfunction defaultMatch(data: any, len: number, context: MatchContext) {\n\tcontext.add(data)\n}\n\nexport type RuleOptions = {\n\t/**\n\t * error is capturable\n\t */\n\tcapturable?: boolean\n\t/**\n\t * matched callback\n\t */\n\tmatch?: (data: any, len: number, context: MatchContext, rule: Rule) => MatchError | string | void\n\t/**\n\t * error callback\n\t */\n\terr?: (err: MatchError, context: MatchContext, rule: Rule) => MatchError | string | void\n}\n\nlet idGen = 0\n/**\n * Abstract Rule\n */\n@mixin({ $rule: true })\nexport class Rule {\n\treadonly $rule: boolean\n\t// rule type (for debug)\n\ttype: string\n\t// rule id\n\treadonly id: number\n\t// rule name\n\treadonly name: string\n\t// error is capturable\n\treadonly capturable: boolean\n\t// rule expression (for debug)\n\tprotected expr: string\n\t// rule EXPECT content (for debug)\n\tprotected EXPECT: string\n\t// matched callback\n\treadonly onMatch: onMatchCallback\n\t// error callback\n\treadonly onErr: onErrorCallback\n\t// index of start codes\n\tprotected startCodeIdx: any[]\n\t// start codes\n\tprotected startCodes: number[]\n\n\t/**\n\t * @param name\t\t\trule name\n\t * @param capturable\terror is capturable\n\t * @param onMatch\t\tcallback on matched, allow modify the match result or return an error\n\t * @param onErr\t\t\tcallback on Error, allow to ignore error or modify error message or return new error\n\t */\n\tconstructor(name: string, options: RuleOptions) {\n\t\tthis.id = idGen++\n\t\tthis.name = name\n\t\tthis.capturable = options.capturable !== false\n\t\tthis.onMatch = options.match || defaultMatch\n\t\tthis.onErr = options.err || defaultErr\n\t}\n\n\t/**\n\t * create Error\n\t * @param msg \t\t\terror message\n\t * @param context \t\tmatch context\n\t * @param capturable \tis capturable error\n\t * @param src \t\t\tsource error\n\t */\n\tmkErr(msg: string, context: MatchContext, capturable?: boolean, source?: MatchError): MatchError {\n\t\treturn new MatchError(msg, capturable, source, context, this)\n\t}\n\n\t/**\n\t * match fail\n\t * @param msg \t\t\terror message\n\t * @param context \t\tmatch context\n\t * @param capturable \tis capturable error\n\t * @param src \t\t\tsource error\n\t * @return Error|void: may ignore Error in the error callback\n\t */\n\tprotected error(msg: string, context: MatchContext, src?: MatchError, capturable?: boolean): MatchError {\n\t\tconst err = this.mkErr(msg, context, capturable, src)\n\t\tconst userErr = this.onErr(err, context, this)\n\t\tif (userErr) return (userErr as any).$ruleErr ? (userErr as MatchError) : ((err[0] = String(userErr)), err)\n\t}\n\n\t/**\n\t * match success\n\t * > attach the matched result by match callback\n\t * @param data \t\tmatched data\n\t * @param len  \t\tmatched data length\n\t * @param context \tmatch context\n\t * @return Error|void: may return Error in the match callback\n\t */\n\tprotected matched(data: any, len: number, context: MatchContext): MatchError {\n\t\tconst err = this.onMatch(data, len, context, this)\n\t\tif (err) return (err as any).$ruleErr ? (err as MatchError) : this.mkErr(String(err), context, false)\n\t}\n\n\tprotected enter(context: MatchContext) {\n\t\treturn context.create()\n\t}\n\n\t/**\n\t * match\n\t * @param context match context\n\t */\n\tmatch(context: MatchContext): MatchError {\n\t\treturn assert()\n\t}\n\n\t/**\n\t * get start char codes\n\t */\n\tgetStart(stack?: number[]): number[] {\n\t\treturn this.startCodes\n\t}\n\n\t/**\n\t * prepare test before match\n\t */\n\ttest(context: MatchContext): boolean {\n\t\treturn true\n\t}\n\n\tprotected startCodeTest(context: MatchContext): boolean {\n\t\treturn this.startCodeIdx[context.nextCode()]\n\t}\n\n\tprotected setStartCodes(start: number | string | any[], ignoreCase?: boolean) {\n\t\tconst codes: number[] = [],\n\t\t\tindex: number[] = []\n\t\teachCharCodes(start, ignoreCase, code => {\n\t\t\tif (!index[code]) {\n\t\t\t\tcodes.push(code)\n\t\t\t\tindex[code] = code\n\t\t\t}\n\t\t})\n\t\tthis.startCodes = codes\n\t\tthis.setCodeIdx(index)\n\t}\n\n\tprotected setCodeIdx(index: any[]) {\n\t\tif (index.length > 1) {\n\t\t\tthis.startCodeIdx = index\n\t\t\tthis.test = this.startCodeTest\n\t\t}\n\t}\n\n\t// for debug \n\t/**\n\t * make rule expression\n\t * @param expr expression text\n\t */\n\tprotected mkExpr(expr: string): string {\n\t\treturn `<${this.type}: ${expr}>`\n\t}\n\n\t/**\n\t * set rule expression\n\t * \t\t1. make rule expression\n\t * \t\t2. make Expect text\n\t */\n\tprotected setExpr(expr: string) {\n\t\tthis.expr = this.mkExpr(expr)\n\t\tthis.EXPECT = `Expect: ${expr}`\n\t}\n\n\tgetExpr(stack?: number[]): string {\n\t\treturn this.name || this.expr\n\t}\n\n\t/**\n\t * toString by name or expression\n\t */\n\ttoString(): string {\n\t\treturn this.getExpr()\n\t}\n}\n","/**\n * @module util/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 11 2018 15:36:42 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 13:57:26 GMT+0800 (China Standard Time)\n */\nimport { Source } from './Source'\nimport { char, charCode, cutStr } from '../util'\nimport { assert } from '../assert'\n\nexport type CheckPoint = [number, number]\n/**\n * Match Context of Rule\n */\nexport class MatchContext {\n\t// start offset of original buff\n\treadonly source: Source\n\n\t// parent context\n\treadonly parent: MatchContext\n\n\t// matched result list\n\tresult: any[]\n\n\tdata: any\n\n\t// template buff\n\tprivate __buff: string\n\n\t// current offset of template buff\n\tprivate __offset: number\n\n\t// current offset of original buff\n\tprivate __orgOffset: number\n\n\t// advanced characters\n\tprivate __advanced: number\n\n\t// cached character\n\tprivate __code: number\n\n\tconstructor(source: Source, buff: string, offset: number, orgOffset: number, parent?: MatchContext) {\n\t\tthis.source = source\n\t\tthis.parent = parent\n\t\tthis.result = []\n\t\tthis.__buff = buff\n\t\tthis.__offset = offset\n\t\tthis.__orgOffset = orgOffset\n\t\tthis.__advanced = 0\n\t\tparent ? ((this.__code = parent.__code), (this.data = parent.data)) : this.__flushCode()\n\t}\n\n\tprivate __flushCode() {\n\t\tconst { __buff: buff, __offset: offset } = this\n\t\tthis.__code = offset < buff.length ? charCode(buff, offset) : 0\n\t}\n\n\t/**\n\t * create sub Context\n\t */\n\tcreate() {\n\t\treturn new MatchContext(this.source, this.__buff, this.__offset, this.__orgOffset + this.__advanced, this)\n\t}\n\n\tprivate __setAdvanced(advanced: number) {\n\t\tassert.notLess(advanced, 0)\n\n\t\tconst offset = this.__offset - this.__advanced + advanced\n\t\tif (offset < 0) {\n\t\t\tthis.__buff = this.source.buff\n\t\t\tthis.__offset = this.__orgOffset + advanced\n\t\t}\n\t\tthis.__advanced = advanced\n\t\tthis.__offset = offset\n\t\tthis.__flushCode()\n\t}\n\n\t/**\n\t * commit context state to parent context\n\t */\n\tcommit() {\n\t\tconst { __advanced: advanced } = this\n\t\tthis.parent.advance(advanced)\n\t\tthis.__orgOffset += advanced\n\t\tthis.__advanced = 0\n\t\tthis.data = null\n\t}\n\n\t/**\n\t * marge context state\n\t */\n\tmargeState(context: MatchContext) {\n\t\tthis.__setAdvanced(context.__orgOffset + context.__advanced - this.__orgOffset)\n\t}\n\n\t/**\n\t * rollback state and result\n\t * @param checkpoint \trollback to checkpoint\n\t */\n\trollback(checkpoint?: CheckPoint) {\n\t\tlet advanced = 0,\n\t\t\tresultLen = 0\n\n\t\tcheckpoint && ((advanced = checkpoint[0]), (resultLen = checkpoint[1]))\n\n\t\tthis.__setAdvanced(advanced)\n\n\t\tconst { result } = this\n\t\tif (result.length > resultLen) result.length = resultLen\n\t}\n\n\t/**\n\t * get a check point\n\t */\n\tcheckpoint(): CheckPoint {\n\t\treturn [this.__advanced, this.result.length]\n\t}\n\n\t/**\n\t * advance buffer position\n\t */\n\tadvance(i: number) {\n\t\tthis.__offset += i\n\t\tthis.__advanced += i\n\t\tthis.__flushCode()\n\t}\n\n\t/**\n\t * advanced buff length\n\t */\n\tadvanced(): number {\n\t\treturn this.__advanced\n\t}\n\n\t/**\n\t * get buffer\n\t * @param reset reset buffer string from 0\n\t */\n\tbuff(reset?: boolean): string {\n\t\tlet { __buff: buff } = this\n\t\tif (reset) {\n\t\t\tthis.__buff = buff = cutStr(buff, this.__offset)\n\t\t\tthis.__offset = 0\n\t\t}\n\t\treturn buff\n\t}\n\n\torgBuff() {\n\t\treturn this.source.buff\n\t}\n\n\toffset(): number {\n\t\treturn this.__offset\n\t}\n\n\tstartPos(): number {\n\t\treturn this.__orgOffset\n\t}\n\n\tcurrPos(): number {\n\t\treturn this.__orgOffset + this.__advanced\n\t}\n\n\tpos(): [number, number] {\n\t\tconst { __orgOffset: offset } = this\n\t\treturn [offset, offset + this.__advanced]\n\t}\n\n\t/**\n\t * get next char code\n\t * @return number char code number\n\t */\n\tnextCode() {\n\t\treturn this.__code\n\t}\n\n\tnextChar() {\n\t\treturn char(this.__code)\n\t}\n\n\t// result opeartions \n\t/**\n\t * append result\n\t */\n\tadd(data: any) {\n\t\tconst { result } = this\n\t\tresult[result.length] = data\n\t}\n\n\t/**\n\t * append resultset\n\t */\n\taddAll(data: any[]) {\n\t\tconst { result } = this\n\t\tconst len = result.length\n\t\tlet i = data.length\n\t\twhile (i--) result[len + i] = data[i]\n\t}\n\n\t/**\n\t * get result size\n\t */\n\tresultSize() {\n\t\treturn this.result.length\n\t}\n}\n","/**\n * @module util/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:06:22 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 13:56:06 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, MatchError, onMatchCallback, onErrorCallback, RuleOptions } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { assert } from '../assert'\nimport { idxOfArray, escapeStr } from '../util'\nimport { pad } from '../format'\nimport { Source } from './Source'\n\nexport type ComplexRuleBuilder = (rule: Rule) => Rule[]\n\nconst MAX = -1 >>> 0\n/**\n * Abstract Complex Rule\n */\nexport class ComplexRule extends Rule {\n\treadonly split: string\n\tprivate builder: ComplexRuleBuilder\n\tprotected EXPECTS: string[]\n\tprotected rules: Rule[]\n\tprotected readonly rMin: number\n\tprotected readonly rMax: number\n\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param builder \t\tcallback of build rules\n\t * @param options\t\tRule Options\n\t */\n\tconstructor(name: string, repeat: [number, number], builder: ComplexRuleBuilder, options: RuleOptions) {\n\t\tsuper(name, options)\n\n\t\tlet [rMin, rMax] = repeat\n\n\t\trMin < 0 && (rMin = 0)\n\t\trMax <= 0 && (rMax = MAX)\n\n\t\tassert.notGreater(rMin, rMax)\n\n\t\tthis.rMin = rMin\n\t\tthis.rMax = rMax\n\n\t\tthis.builder = builder\n\n\t\tif (rMin !== rMax || rMin !== 1) {\n\t\t\tthis.match = this.rmatch\n\n\t\t\t// for debug\n\t\t\tthis.type = `${this.type}[${rMin}${rMin === rMax ? '' : ` - ${rMax === MAX ? 'MAX' : rMax}`}]`\n\t\t}\n\t}\n\tparse(buff: string, data?: any): any[] {\n\t\tconst ctx = new MatchContext(new Source(buff), buff, 0, 0)\n\t\tctx.data = data\n\t\tlet err = this.match(ctx)\n\t\tif (err) {\n\t\t\tconst msg = []\n\t\t\tvar pos: [number, number, string]\n\t\t\tdo {\n\t\t\t\tpos = err.position()\n\t\t\t\tmsg.unshift(\n\t\t\t\t\t`[${pad(String(pos[0]), 3)}:${pad(String(pos[1]), 2)}] - ${err.rule.toString()}: ${\n\t\t\t\t\t\terr.msg\n\t\t\t\t\t} on \"${escapeStr(pos[2])}\"`\n\t\t\t\t)\n\t\t\t} while ((err = err.source))\n\t\t\tmsg.push('[Source]', ctx.source.source())\n\t\t\tthrow new SyntaxError(msg.join('\\n'))\n\t\t}\n\t\treturn ctx.result\n\t}\n\tinit(): ComplexRule {\n\t\tconst rules = this.builder(this)\n\t\tlet i = rules && rules.length\n\n\t\tassert.is(i, `Require Complex Rules`)\n\n\t\tthis.rules = rules\n\n\t\t// generate expression and expect string for debug\n\t\tconst names = this.rnames(rules)\n\t\tthis.setExpr(names.join(this.split))\n\t\twhile (i--) names[i] = `Expect[${i}]: ${names[i]}`\n\t\tthis.EXPECTS = names\n\n\t\tthis.__init(rules)\n\n\t\tthis.builder = null\n\n\t\treturn this\n\t}\n\t__init(rules: Rule[]) {}\n\n\tprotected rmatch(context: MatchContext): MatchError {\n\t\treturn assert()\n\t}\n\n\tprotected setCodeIdx(index: any[]) {\n\t\tthis.rMin && super.setCodeIdx(index)\n\t}\n\n\tgetRules(): Rule[] {\n\t\treturn this.rules || (this.init(), this.rules)\n\t}\n\n\tgetStart(stack?: number[]): number[] {\n\t\tconst { id, startCodes } = this\n\t\treturn startCodes\n\t\t\t? startCodes\n\t\t\t: (stack && ~idxOfArray(stack, id)) || this.rules\n\t\t\t? []\n\t\t\t: (this.init(), this.startCodes)\n\t}\n\n\tconsume(context: MatchContext): MatchError {\n\t\tconst err = this.matched(context.result, context.advanced(), context.parent)\n\t\t!err && context.commit()\n\t\treturn err\n\t}\n\n\t// for debug\n\tprivate rnames(rules: Rule[], stack?: number[]): string[] {\n\t\tlet i = rules.length\n\t\tconst names: string[] = new Array(i),\n\t\t\tid = this.id\n\t\twhile (i--) names[i] = rules[i].getExpr(stack ? stack.concat(id) : [id])\n\t\treturn names\n\t}\n\n\tgetExpr(stack?: number[]): string {\n\t\tconst { id, name } = this\n\t\tlet i: number\n\n\t\treturn name\n\t\t\t? name\n\t\t\t: stack\n\t\t\t? ~(i = idxOfArray(stack, id))\n\t\t\t\t? `<${this.type} -> $${stack[i]}>`\n\t\t\t\t: this.mkExpr(this.rnames(this.getRules(), stack).join(this.split))\n\t\t\t: this.expr\n\t}\n}\n","/**\n *\n * @module util/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 27 2018 19:05:48 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 14:09:18 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, MatchError } from './Rule'\nimport { MatchContext, CheckPoint } from './MatchContext'\nimport { ComplexRule } from './ComplexRule'\nimport { mixin } from '../util'\n\n/**\n * AND Complex Rule\n */\n@mixin({ type: 'And', split: ' ' })\nexport class AndRule extends ComplexRule {\n\t__init(rules: Rule[]) {\n\t\tthis.setStartCodes(rules[0].getStart([this.id]))\n\t}\n\tmatch(context: MatchContext): MatchError {\n\t\tconst rules = this.getRules(),\n\t\t\tlen = rules.length,\n\t\t\tctx = context.create()\n\t\tlet err: MatchError,\n\t\t\ti: number = 0\n\t\tfor (; i < len; i++) if ((err = this.testRule(rules[i], i, ctx))) return err\n\t\treturn this.consume(ctx)\n\t}\n\tprotected rmatch(context: MatchContext): MatchError {\n\t\tconst { rMin, rMax } = this\n\t\tconst rules = this.getRules(),\n\t\t\tlen = rules.length,\n\t\t\tctx = context.create()\n\n\t\tlet err: MatchError,\n\t\t\trepeat: number = 0,\n\t\t\ti: number,\n\t\t\tcp: CheckPoint\n\n\t\tout: for (; repeat < rMax; repeat++) {\n\t\t\tcp = ctx.checkpoint()\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tif ((err = this.testRule(rules[i], i, ctx))) {\n\t\t\t\t\tif (repeat < rMin) return err\n\t\t\t\t\tctx.rollback(cp)\n\t\t\t\t\tbreak out\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.consume(ctx)\n\t}\n\ttestRule(rule: Rule, i: number, ctx: MatchContext): MatchError {\n\t\tlet err: MatchError\n\t\tif (!rule.test(ctx)) {\n\t\t\treturn this.error(this.EXPECTS[i], ctx)\n\t\t} else if ((err = rule.match(ctx))) {\n\t\t\treturn this.error(this.EXPECTS[i], ctx, err)\n\t\t}\n\n\t\t// return (!rule.test(ctx) || (err = rule.match(ctx))) && (err = this.error(this.EXPECTS[i], ctx, err))\n\t}\n}\n","/**\n *\n * @module util/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 27 2018 19:05:48 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 14:09:35 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, MatchError } from './Rule'\nimport { MatchContext, CheckPoint } from './MatchContext'\nimport { ComplexRule } from './ComplexRule'\nimport { eachCharCodes } from './util'\nimport { mixin } from '../util'\n\n/**\n * OR Complex Rule\n */\n@mixin({ type: 'Or', split: ' | ' })\nexport class OrRule extends ComplexRule {\n\tindex: Rule[][]\n\t__init(rules: Rule[]) {\n\t\tconst { id } = this\n\t\tconst len = rules.length,\n\t\t\tstarts: number[] = [], // all distinct start codes\n\t\t\trStarts: number[][] = [], // start codes per rule\n\t\t\tindex: Rule[][] = [\n\t\t\t\t[] // rules which without start code\n\t\t\t]\n\n\t\tlet i: number, j: number, k: Rule[] & { idx: number }, codes: number[]\n\n\t\t// get start codes of all rules\n\t\tfor (i = 0; i < len; i++) {\n\t\t\trStarts[i] = [] // init rule start codes\n\t\t\teachCharCodes(rules[i].getStart([id]), false, code => {\n\t\t\t\trStarts[i].push(code) // append to rule start codes\n\t\t\t\tif (!index[code]) {\n\t\t\t\t\tindex[code] = [] // init start code index\n\t\t\t\t\tstarts.push(code) // append to all start codes\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\t// fill index\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tcodes = rStarts[i] // append rule to start code index by rule start codes\n\t\t\tif (!codes.length) {\n\t\t\t\t// rule without start code\n\t\t\t\tindex[0].push(rules[i]) // append rule to index[0]\n\t\t\t\tcodes = starts // append rule to start code index by all start codes\n\t\t\t}\n\n\t\t\t// append rule to start code index (by rule start codes or all start codes)\n\t\t\tj = codes.length\n\t\t\twhile (j--) {\n\t\t\t\tk = index[codes[j]] as Rule[] & { idx: number }\n\t\t\t\tif (k.idx !== i) {\n\t\t\t\t\t// deduplication\n\t\t\t\t\tk.push(rules[i]) // append rules[i] to start code index[codes[j]]\n\t\t\t\t\tk.idx = i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// rule have unkown start code when got unkown start code from any rules\n\t\tconst startCodes = !index[0].length && starts\n\t\tthis.startCodes = startCodes || []\n\t\tstartCodes && this.setCodeIdx(index)\n\t\tthis.index = index\n\t}\n\n\tmatch(context: MatchContext): MatchError {\n\t\tconst index = this.index || (this.init(), this.index),\n\t\t\trules: Rule[] = index[context.nextCode()] || index[0],\n\t\t\tlen = rules.length,\n\t\t\tctx = context.create()\n\n\t\tlet err: MatchError,\n\t\t\tupErr: MatchError,\n\t\t\ti = 0\n\n\t\tfor (; i < len; i++) {\n\t\t\terr = rules[i].match(ctx) || this.consume(ctx)\n\t\t\tif (!err) return\n\t\t\tif (!err.capturable) {\n\t\t\t\tupErr = err\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif (!upErr || err.pos >= upErr.pos) upErr = err\n\t\t\tctx.rollback()\n\t\t}\n\t\treturn this.error(this.EXPECT, ctx, upErr)\n\t}\n\n\tprotected rmatch(context: MatchContext): MatchError {\n\t\tconst { rMin, rMax } = this\n\t\tconst index = this.index || (this.init(), this.index),\n\t\t\tctx = context.create()\n\n\t\tlet rules: Rule[],\n\t\t\tlen: number,\n\t\t\terr: MatchError,\n\t\t\tupErr: MatchError,\n\t\t\trepeat: number = 0,\n\t\t\ti: number,\n\t\t\tcp: CheckPoint\n\n\t\tout: for (; repeat < rMax; repeat++) {\n\t\t\trules = index[ctx.nextCode()] || index[0]\n\t\t\tupErr = null\n\t\t\tif ((len = rules.length)) {\n\t\t\t\tcp = ctx.checkpoint()\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\terr = rules[i].match(ctx)\n\t\t\t\t\tif (!err) continue out\n\t\t\t\t\tif (!err.capturable) {\n\t\t\t\t\t\tupErr = err\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tif (!upErr || err.pos >= upErr.pos) upErr = err\n\t\t\t\t\tctx.rollback(cp)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (repeat < rMin || (upErr && !upErr.capturable)) return this.error(this.EXPECT, ctx, upErr)\n\t\t\tbreak\n\t\t}\n\t\treturn this.consume(ctx)\n\t}\n}\n","/**\n * @module util/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:06:22 GMT+0800 (China Standard Time)\n * @modified Sat Dec 22 2018 15:11:19 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, MatchError, RuleOptions } from './Rule'\nimport { MatchContext } from './MatchContext'\n\n/**\n * Match Rule Interface\n */\nexport class MatchRule extends Rule {\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param start \t\tstart char codes, prepare test by start char codes before match\n\t * @param ignoreCase\tignore case for the start char codes\n\t * @param options\t\tRule Options\n\t */\n\tconstructor(name: string, start: number | string | any[], ignoreCase: boolean, options: RuleOptions) {\n\t\tsuper(name, options)\n\t\tthis.setStartCodes(start, ignoreCase)\n\t}\n\n\t/**\n\t * consume matched result\n\t * @param data \t\tmatched result\n\t * @param len \t\tmatched chars\n\t * @param context \tmatch context\n\t */\n\tcomsume(data: string | string[], len: number, context: MatchContext): MatchError {\n\t\tcontext.advance(len)\n\t\treturn this.matched(data, len, context)\n\t}\n}\n","/**\n *\n * @module util/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 11 2018 15:36:42 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 13:57:09 GMT+0800 (China Standard Time)\n */\n\nimport { RuleOptions } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { MatchRule } from './MatchRule'\nimport { char, mixin } from '../util'\n\n/**\n * match a character in the allowed list\n * > well match any character if the allowed list is empty\n *\n * > must call test() before match\n */\n@mixin({ type: 'Character' })\nexport class CharMatchRule extends MatchRule {\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param allows \t\tallowed character codes for match\n\t * \t\t\t\t\t\twell match any character if the allowed list is empty\n\t * @param ignoreCase\tignore case for the allowed character codes\n\t * @param options\t\tRule Options\n\t */\n\tconstructor(name: string, allows: number | string | any[], ignoreCase: boolean, options: RuleOptions) {\n\t\tsuper(name, allows, ignoreCase, options)\n\n\t\t// generate expression for debug\n\t\tconst codes = this.startCodes\n\t\tlet i = codes.length,\n\t\t\texpr = '*'\n\t\tif (i) {\n\t\t\tconst chars = []\n\t\t\twhile (i--) chars[i] = char(codes[i])\n\t\t\texpr = `\"${chars.join('\" | \"')}\"`\n\t\t}\n\t\tthis.setExpr(expr)\n\t}\n\tmatch(context: MatchContext) {\n\t\treturn this.comsume(context.nextChar(), 1, context)\n\t}\n}\n","/**\n * @module util/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 11 2018 15:36:42 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 13:58:09 GMT+0800 (China Standard Time)\n */\n\nimport { MatchError, RuleOptions } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { MatchRule } from './MatchRule'\nimport { mixin, createFn, create, mapArray, cutLStr, stickyReg, isInt } from '../util'\n\n/**\n * match string by RegExp\n *\n * optimization:\n * - Priority use sticky mode {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky}\n *\n */\n@mixin({ type: 'RegExp' })\nexport class RegMatchRule extends MatchRule {\n\treadonly regexp: RegExp\n\treadonly pick: boolean | number\n\tprivate picker: (m: string[]) => string | string[]\n\tprivate spicker: (buff: string, start: number, end: number) => string\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param regexp\t\tregular\n\t * @param pick\t\t\tpick regular matching results\n\t * \t\t\t\t\t\t    0: pick results[0] (optimize: test and substring in sticky mode)\n\t * \t\t\t\t\t\t  > 0: pick results[{pick}]\n\t * \t\t\t\t\t\t  < 0: pick first non-blank string from 1 to -{pick} index on results\n\t * \t\t\t\t\t\t true: pick results\n\t * \t\t\t\t\t\tfalse: not pick result, result is null (optimize: just test string in sticky mode)\n\t * @param start\t\t\tstart character codes in the regular, optimize performance by start character codes\n\t * @param capturable\terror is capturable\n\t * @param onMatch\t\tmatch callback\n\t * @param onErr\t\t\terror callback\n\t */\n\tconstructor(\n\t\tname: string,\n\t\tregexp: RegExp,\n\t\tpick: boolean | number,\n\t\tstart: number | string | any[],\n\t\toptions: RuleOptions\n\t) {\n\t\tpick = pick === false || isInt(pick) ? pick : !!pick || 0\n\n\t\tconst sticky = stickyReg && !pick, // use exec mode when need pick match group data\n\t\t\tpattern = regexp.source,\n\t\t\tignoreCase = regexp.ignoreCase\n\n\t\t// always wrapping in a none capturing group preceded by '^' to make sure\n\t\t// matching can only work on start of input. duplicate/redundant start of\n\t\t// input markers have no meaning (/^^^^A/ === /^A/)\n\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky\n\t\t// When the y flag is used with a pattern, ^ always matches only at the\n\t\t// beginning of the input, or (if multiline is true) at the beginning of a\n\t\t// line.\n\t\tregexp = new RegExp(\n\t\t\tsticky ? pattern : `^(?:${pattern})`,\n\t\t\t(ignoreCase ? 'i' : '') + (regexp.multiline ? 'm' : '') + (sticky ? 'y' : '')\n\t\t)\n\n\t\tsuper(name, start, ignoreCase, options)\n\n\t\tthis.regexp = regexp\n\t\tthis.pick = pick\n\t\tthis.match = sticky ? this.stickyMatch : this.execMatch\n\n\t\tsticky ? (this.spicker = pick === false ? pickNone : pickTestStr) : (this.picker = mkPicker(pick))\n\n\t\tthis.setExpr(pattern)\n\t}\n\t/**\n\t * match on sticky mode\n\t */\n\tstickyMatch(context: MatchContext): MatchError {\n\t\tconst reg = this.regexp,\n\t\t\tbuff = context.buff(),\n\t\t\tstart = context.offset()\n\t\treg.lastIndex = start\n\t\tlet len: number\n\t\treturn reg.test(buff)\n\t\t\t? ((len = reg.lastIndex - start), this.comsume(this.spicker(buff, start, len), len, context))\n\t\t\t: this.error(this.EXPECT, context)\n\t}\n\t/**\n\t * match on exec mode\n\t */\n\texecMatch(context: MatchContext): MatchError {\n\t\tconst m = this.regexp.exec(context.buff(true))\n\t\treturn m ? this.comsume(this.picker(m), m[0].length, context) : this.error(this.EXPECT, context)\n\t}\n}\n\nconst cache = create(null)\nfunction mkPicker(pick: number | boolean): (m: string[]) => string | string[] {\n\treturn (\n\t\tcache[pick as any] ||\n\t\t(cache[pick as any] =\n\t\t\tpick === false\n\t\t\t\t? pickNone\n\t\t\t\t: pick === true\n\t\t\t\t? pickAll\n\t\t\t\t: pick >= 0\n\t\t\t\t? createFn(`return m[${pick}]`, ['m'], `pick_${pick}`)\n\t\t\t\t: createFn(\n\t\t\t\t\t\t`return ${mapArray(new Array(-pick), (v, i) => `m[${i + 1}]`).join(' || ')}`,\n\t\t\t\t\t\t['m'],\n\t\t\t\t\t\t`pick_1_${-pick}`\n\t\t\t\t  ))\n\t)\n}\n\nfunction pickNone(): string {\n\treturn null\n}\n\nfunction pickAll(m: string[]): string[] {\n\treturn m\n}\n\nfunction pickTestStr(buff: string, start: number, end: number): string {\n\treturn cutLStr(buff, start, end)\n}\n","/**\n * @module util/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 11 2018 15:36:42 GMT+0800 (China Standard Time)\n * @modified Mon Apr 08 2019 13:58:56 GMT+0800 (China Standard Time)\n */\n\nimport { RuleOptions } from './Rule'\nimport { RegMatchRule } from './RegMatchRule'\nimport { reEscape, mixin, charCode } from '../util'\n\n@mixin({ type: 'String' })\nexport class StringMatchRule extends RegMatchRule {\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param str \t\t\tmatch string\n\t * @param ignoreCase\tignore case\n\t * @param options\t\tRule Options\n\t */\n\tconstructor(name: string, str: string, ignoreCase: boolean, options: RuleOptions) {\n\t\tsuper(name, new RegExp(reEscape(str), ignoreCase ? 'i' : ''), 0, charCode(str), options)\n\t\tthis.setExpr(str)\n\t}\n}\n","/**\n * AST Parser API\n * @module util/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:58:52 GMT+0800 (China Standard Time)\n * @modified Thu Apr 04 2019 19:59:23 GMT+0800 (China Standard Time)\n */\n\nimport { ComplexRuleBuilder } from './ComplexRule'\nimport { CharMatchRule } from './CharMatchRule'\nimport { StringMatchRule } from './StringMatchRule'\nimport { RegMatchRule } from './RegMatchRule'\nimport { onMatchCallback, onErrorCallback, Rule, MatchError, RuleOptions } from './Rule'\nimport { MatchRule } from './MatchRule'\nimport { AndRule } from './AndRule'\nimport { OrRule } from './OrRule'\nimport { MatchContext } from './MatchContext'\nimport { mapArray, SKIP, isObj, isReg, isStr, isBool, isNum, isInt, isArray, isArrayLike, isFn } from '../util'\nimport { EMPTY_FN } from '../util/consts'\nimport { assert } from '../assert'\n\n//========================================================================================\n/*                                                                                      *\n *                                      match tools                                     *\n *                                                                                      */\n//========================================================================================\n\nexport const discardMatch: onMatchCallback = EMPTY_FN\n\nexport function appendMatch(data: any, len: number, context: MatchContext) {\n\tcontext.addAll(data)\n}\nexport function attachMatch(\n\tcallback: (data: any, len: number, context: MatchContext, rule: Rule) => any\n): onMatchCallback\nexport function attachMatch(val: any): onMatchCallback\nexport function attachMatch(val: any) {\n\tconst callback: (data: any, len: number, context: MatchContext, rule: Rule) => any = isFn(val) ? val : () => val\n\treturn (data: any, len: number, context: MatchContext, rule: Rule) => {\n\t\tcontext.add(callback(data, len, context, rule))\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       match api                                      *\n *                                                                                      */\n//========================================================================================\n\nexport function match(desc: MatchRuleDescriptor): MatchRule\n\n// named regexp match api \n// pick, start, cap\n// pick, cap\n// pick, start\n// pick\n// start, cap\n// start\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tpick?: boolean | number,\n\tstartCodes?: number | string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tstartCodes: number | string | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tstartCodes: string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tstartCodes: string | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(name: string, pattern: RegExp, onMatch: onMatchCallback, onErr?: onErrorCallback): MatchRule\n\n// regexp match api \nexport function match(\n\tpattern: RegExp,\n\tpick?: boolean | number,\n\tstartCodes?: number | string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tstartCodes: number | string | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tstartCodes: string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tstartCodes: string | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(pattern: RegExp, onMatch: onMatchCallback, onErr?: onErrorCallback): MatchRule\n\n// named string match api \nexport function match(\n\tname: string,\n\tpattern: number | string | any[],\n\tignoreCase?: boolean,\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(\n\tname: string,\n\tpattern: number | string | any[],\n\tignoreCase: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(\n\tname: string,\n\tpattern: number | string | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\n// string match api \nexport function match(\n\tpattern: number | string | any[],\n\tignoreCase?: boolean,\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(\n\tpattern: number | string | any[],\n\tignoreCase: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(pattern: number | string | any[], onMatch: onMatchCallback, onErr?: onErrorCallback): MatchRule\n\nexport function match(): MatchRule {\n\treturn mkMatch(arguments)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     and rule api                                     *\n *                                                                                      */\n//========================================================================================\n\n// and \nexport function and(desc: ComplexRuleDescriptor): AndRule\nexport function and(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(\n\trules: ((rule: Rule) => any[]) | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(rules: ((rule: Rule) => any[]) | any[], onMatch: onMatchCallback, onErr?: onErrorCallback): AndRule\nexport function and(): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [1, 1])\n}\n\n// and any \nexport function any(desc: ComplexRuleDescriptor): AndRule\nexport function any(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function any(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function any(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function any(rules: ((rule: Rule) => any[]) | any[], onMatch: onMatchCallback, onErr?: onErrorCallback): AndRule\nexport function any(): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [0, -1])\n}\n\n// and many \nexport function many(desc: ComplexRuleDescriptor): AndRule\nexport function many(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function many(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function many(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function many(rules: ((rule: Rule) => any[]) | any[], onMatch: onMatchCallback, onErr?: onErrorCallback): AndRule\nexport function many(): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [1, -1])\n}\n\n// and option \nexport function option(desc: ComplexRuleDescriptor): AndRule\nexport function option(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function option(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function option(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function option(\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function option(): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [0, 1])\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      or rule api                                     *\n *                                                                                      */\n//========================================================================================\n\n// or \nexport function or(desc: ComplexRuleDescriptor): OrRule\nexport function or(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(\n\trules: ((rule: Rule) => any[]) | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(rules: ((rule: Rule) => any[]) | any[], onMatch: onMatchCallback, onErr?: onErrorCallback): OrRule\nexport function or(): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [1, 1])\n}\n\n// or any \nexport function anyOne(desc: ComplexRuleDescriptor): OrRule\nexport function anyOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function anyOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function anyOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function anyOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function anyOne(): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [0, -1])\n}\n\n// or many \nexport function manyOne(desc: ComplexRuleDescriptor): OrRule\nexport function manyOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function manyOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function manyOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function manyOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function manyOne(): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [1, -1])\n}\n\n// or option \nexport function optionOne(desc: ComplexRuleDescriptor): OrRule\nexport function optionOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function optionOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function optionOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function optionOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function optionOne(): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [0, 1])\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                  Match Rule Builder                                  *\n *                                                                                      */\n//========================================================================================\n\nexport type MatchRuleDescriptor = {\n\tname?: string\n\tpattern: RegExp | number | string | any[]\n\tpick?: boolean | number\n\tstartCodes?: number | string | any[]\n\tignoreCase?: boolean\n} & RuleOptions\n\nfunction mkMatch(args: IArguments | any[], defaultMatchCallback?: onMatchCallback): MatchRule {\n\tlet name: string,\n\t\tpattern: number | string | any[],\n\t\tregexp: RegExp,\n\t\tpick: boolean | number = 0,\n\t\tstartCodes: number | string | any[],\n\t\tignoreCase: boolean = false,\n\t\toptions: RuleOptions\n\tif (isObj(args[0])) {\n\t\tconst desc = args[0] as MatchRuleDescriptor,\n\t\t\tp = desc.pattern\n\t\tif (isReg(p)) {\n\t\t\tregexp = p as RegExp\n\t\t\tpick = desc.pick\n\t\t\tstartCodes = desc.startCodes\n\t\t} else if (isStrOrCodes(p)) {\n\t\t\tpattern = p as number | string | any[]\n\t\t\tignoreCase = desc.ignoreCase\n\t\t}\n\t\tname = desc.name\n\t\toptions = desc\n\t} else {\n\t\tvar i = 1\n\t\tif (isStr(args[0]) && isMatchPattern(args[1])) {\n\t\t\tname = args[0]\n\t\t\tisReg(args[1]) ? (regexp = args[1]) : (pattern = args[1])\n\t\t\ti = 2\n\t\t} else if (isMatchPattern(args[0])) {\n\t\t\tisReg(args[0]) ? (regexp = args[0]) : (pattern = args[0])\n\t\t}\n\n\t\tif (regexp) {\n\t\t\tif (isBool(args[i]) || isInt(args[i])) pick = args[i++]\n\t\t\tif (isStrOrCodes(args[i])) startCodes = args[i++]\n\t\t} else {\n\t\t\tif (isBool(args[i])) ignoreCase = args[i++]\n\t\t}\n\t\toptions = parseRuleOptions(args, i)\n\t}\n\n\t!options.match && (options.match = defaultMatchCallback)\n\n\treturn regexp\n\t\t? new RegMatchRule(name, regexp, options.match === discardMatch ? false : pick, startCodes, options)\n\t\t: pattern\n\t\t? strMatch(name, pattern, ignoreCase, options)\n\t\t: assert('invalid match rule {j}', args)\n}\n\nfunction isStrOrCodes(pattern): boolean {\n\treturn isStr(pattern) || isNum(pattern) || isArray(pattern)\n}\n\nfunction isMatchPattern(pattern): boolean {\n\treturn isReg(pattern) || isStrOrCodes(pattern)\n}\n\nfunction strMatch(name: string, pattern: string | number | any[], ignoreCase: boolean, options: RuleOptions) {\n\tconst C = isStr(pattern) && (pattern as string).length > 1 ? StringMatchRule : CharMatchRule\n\treturn new C(name, pattern, ignoreCase, options)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                 complex rule builder                                 *\n *                                                                                      */\n//========================================================================================\n\nexport type ComplexRuleDescriptor = {\n\tname?: string\n\trules: ((rule: Rule) => any[]) | any[]\n\trepeat?: [number, number]\n\tcapturable?: boolean\n\tonMatch?: onMatchCallback\n\tonErr?: onErrorCallback\n} & RuleOptions\n\nfunction mkComplexRule<T extends AndRule | OrRule>(\n\targs: IArguments,\n\tRule: typeof AndRule | typeof OrRule,\n\tdefaultRepeat: [number, number]\n): T {\n\tlet name: string,\n\t\tbuilder: ComplexRuleBuilder,\n\t\trules: ((rule: Rule) => any[]) | any[],\n\t\trepeat: [number, number],\n\t\toptions: RuleOptions\n\tif (isObj(args[0])) {\n\t\tconst desc = args[0] as ComplexRuleDescriptor,\n\t\t\tr = desc.rules\n\t\tif (isArray(r) || isFn(r)) rules = r\n\t\trepeat = desc.repeat\n\t\tname = desc.name\n\t\toptions = desc\n\t} else {\n\t\tvar i = 0\n\t\tif (isStr(args[i])) name = args[i++]\n\t\tif (isArray(args[i]) || isFn(args[i])) rules = args[i++]\n\t\tif (isArray(args[i])) repeat = args[i++]\n\t\toptions = parseRuleOptions(args, i)\n\t}\n\tif (!repeat) repeat = defaultRepeat\n\tif (rules) {\n\t\tbuilder = rulesBuilder(rules)\n\t\treturn new Rule(name, repeat, builder, options) as T\n\t}\n}\n\nfunction rulesBuilder(rules: ((rule: Rule) => any[]) | any[]): (rule: Rule) => Rule[] {\n\treturn function(_rule) {\n\t\treturn mapArray(isFn(rules) ? (rules as ((rule: Rule) => any[]))(_rule) : (rules as any[]), (r, i) => {\n\t\t\tif (!r) return SKIP\n\t\t\tlet rule: Rule = r.$rule ? r : mkMatch(isArray(r) ? r : [r], discardMatch)\n\t\t\tassert.is(rule, '{}: Invalid Rule Configuration on index {d}: {j}', _rule, i, r)\n\t\t\treturn rule\n\t\t})\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         tools                                        *\n *                                                                                      */\n//========================================================================================\n\nfunction parseRuleOptions(args: IArguments | any[], i: number) {\n\tconst options: RuleOptions = {}\n\tif (isBool(args[i])) options.capturable = args[i++]\n\toptions.match = args[i++]\n\toptions.err = args[i]\n\treturn options\n}\n","/**\n *\n * @module observer\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Mar 19 2019 14:12:23 GMT+0800 (China Standard Time)\n * @modified Wed Apr 10 2019 10:11:52 GMT+0800 (China Standard Time)\n */\n\nimport { addDKey } from '../util'\n\n/**\n * Observer Key\n */\nexport const OBSERVER_KEY = addDKey('__observer__')\n\n/**\n * the property of observe an array change\n */\nexport const ARRAY_CHANGE = '$change',\n\tARRAY_LENGTH = 'length'\n\nexport type ObserverTarget = any[] | {}\n\n/**\n * change callback for observer\n * @param path \t\tthe observe path\n * @param value \tnew value\n * @param original\toriginal value\n */\nexport type ObserverCallback<T extends ObserverTarget> = (\n\tpath: string[],\n\tvalue: any,\n\toriginal: any,\n\tobserver: IObserver<T>\n) => void\n\nexport type IWatcher = {\n\t/**\n\t * notify topics\n\t * @param original the original value\n\t */\n\tnotify(original: any): void\n}\n\nexport interface IObserver<T extends ObserverTarget> {\n\t/**\n\t * target of the observer\n\t */\n\treadonly target: T\n\n\t/**\n\t * observer proxy\n\t */\n\treadonly proxy: T\n\n\t/**\n\t * is array object\n\t */\n\treadonly isArray: boolean\n\n\t/**\n\t * observe changes in the observer's target\n\t * @param propPath \tproperty path for observe, parse string path by {@link parsePath}\n\t * @param cb\t\tcallback\n\t * @param scope\t\tscope of callback\n\t * @return listen-id\n\t */\n\tobserve(propPath: string | string[], cb: ObserverCallback<T>, scope?: any): string\n\n\t/**\n\t * get listen-id of callback in the observer's target\n\t *\n\t * @param propPath \tproperty path for observe, parse string path by {@link parsePath}\n\t * @param cb\t\tcallback\n\t * @param scope\t\tscope of callback\n\t * @return listen-id\n\t */\n\tobserved(propPath: string | string[], cb: ObserverCallback<T>, scope?: any): string\n\n\t/**\n\t * has listen-id in the observer's target\n\t *\n\t * @param propPath \tproperty path for observe, parse string path by {@link parsePath}\n\t * @param id\t\tlisten-id\n\t * @return listen-id\n\t */\n\tobservedId(propPath: string | string[], id: string): boolean\n\n\t/**\n\t * cancel observing the changes in the observer's target\n\t * @param propPath\tproperty path for unobserve, parse string path by {@link parsePath}\n\t * @param cb\t\tcallback\n\t * @param scope\t\tscope of callback\n\t */\n\tunobserve(propPath: string | string[], cb: ObserverCallback<T>, scope?: any): void\n\n\t/**\n\t * cancel observing the changes in the observer's target by listen-id\n\t * @param propPath\tproperty path for unobserve, parse string path by {@link parsePath}\n\t * @param id \t\tlisten-id\n\t */\n\tunobserveId(propPath: string | string[], id: string): void\n\n\t/**\n\t * set value\n\t * @param propPath \tproperty path for set, parse string path by {@link parsePath}\n\t * @param value\t\tthe value\n\t */\n\tset(propPath: string | string[], value: any): void\n\n\t/**\n\t * get value\n\t * @param propPath \tproperty path for get, parse string path by {@link parsePath}\n\t * @return the value\n\t */\n\tget(propPath: string | string[]): any\n\n\t/**\n\t * notify change on the property\n\t * @param prop\t\tthe property\n\t * @param original \tthe original value\n\t */\n\tnotify(prop: string, original: any): void\n\n\t/**\n\t * notify the observer that properties in the target have changed\n\t *\n\t * @param props \t\tnotify properties, notify all watchers when the props is null or undefined\n\t * @param getOriginal\tget the original value\n\t * @param execludes\t\tdo not notify watchers in execludes\n\t */\n\tnotifies(\n\t\tprops: string[],\n\t\tgetOriginal: (prop: string, ob: IObserver<T>) => any,\n\t\texecludes?: { [key: string]: any }\n\t): void\n}\n","/**\n * @module observer\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Apr 04 2019 20:42:20 GMT+0800 (China Standard Time)\n * @modified Fri Apr 12 2019 14:48:43 GMT+0800 (China Standard Time)\n */\n\nimport { ARRAY_LENGTH, ARRAY_CHANGE, IObserver, OBSERVER_KEY } from './IObserver'\nimport { eachObj, eachArray, isFn, applyScope, defValue, SKIP } from '../util'\nimport { P_PROTOTYPE } from '../util/consts'\n\ntype ArrayHook = [string, (...args: any[]) => any]\nconst arrayHooks = []\nconst ARRAY_LEN_CHANGE = [ARRAY_LENGTH, ARRAY_CHANGE]\nconst arrayHookCfg: {\n\t[methods: string]: [string[]?, { [prop: string]: any }?] | ((ob: IObserver<any[]>, args: IArguments) => void)\n} = {\n\tpush: [ARRAY_LEN_CHANGE],\n\tpop: [ARRAY_LEN_CHANGE],\n\tsplice(ob: IObserver<any[]>, args: IArguments) {\n\t\tconst { target, proxy } = ob\n\t\tconst start = args[0],\n\t\t\td = args.length - 2 - args[1],\n\t\t\tend = start + args[1]\n\t\tob.notifies(null, prop =>\n\t\t\tprop === ARRAY_CHANGE\n\t\t\t\t? proxy\n\t\t\t\t: prop === ARRAY_LENGTH\n\t\t\t\t? d\n\t\t\t\t\t? target[prop]\n\t\t\t\t\t: SKIP\n\t\t\t\t: prop >= start && (d || prop < end)\n\t\t\t\t? target[prop]\n\t\t\t\t: SKIP\n\t\t)\n\t},\n\tshift: [],\n\tunshift: [],\n\t'fill,reverse,sort': [null, { length: 1 }]\n}\neachObj(arrayHookCfg, (hooker, methods) => {\n\teachArray(methods.split(','), method => {\n\t\tconst fn = Array[P_PROTOTYPE][method]\n\t\tlet hook: (...args: any[]) => any\n\t\tif (isFn(hooker)) {\n\t\t\tconst cb: (ob: IObserver<any[]>, args: IArguments) => void = hooker as ((ob: IObserver<any[]>) => void)\n\t\t\thook = function() {\n\t\t\t\tconst ob: IObserver<any[]> = this[OBSERVER_KEY]\n\t\t\t\tcb(ob, arguments)\n\t\t\t\treturn applyScope(fn, ob.target, arguments)\n\t\t\t}\n\t\t} else {\n\t\t\tconst [props, execludes] = hooker as [string[]?, { [prop: string]: any }?]\n\t\t\thook = function() {\n\t\t\t\tconst ob: IObserver<any[]> = this[OBSERVER_KEY]\n\t\t\t\tob.notifies(props, getArrayOriginValue, execludes)\n\t\t\t\treturn applyScope(fn, ob.target, arguments)\n\t\t\t}\n\t\t}\n\t\tarrayHooks.push([method, hook])\n\t})\n})\n\nfunction getArrayOriginValue(prop: string, ob: IObserver<any[]>) {\n\treturn prop === ARRAY_CHANGE ? ob.proxy : ob.target[prop]\n}\n\n/**\n * apply observer hooks on Array\n * @param array\n */\nexport function applyArrayHooks(array: any[]) {\n\tlet hook: ArrayHook,\n\t\ti = arrayHooks.length\n\twhile (i--) {\n\t\thook = arrayHooks[i]\n\t\tdefValue(array, hook[0], hook[1], false, false, false)\n\t}\n}\n","/**\n * Observe implementation on the VBScript of MSIE\n * @module observer\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Mar 19 2019 14:12:23 GMT+0800 (China Standard Time)\n * @modified Wed Apr 10 2019 19:55:47 GMT+0800 (China Standard Time)\n */\nimport { ObserverTarget, IWatcher, IObserver } from './IObserver'\nimport { ObservePolicy } from './ObservePolicy'\nimport { GLOBAL, P_CTOR, P_OWNPROP } from '../util/consts'\nimport { create, isFn, getDKeys, addDKeys } from '../util'\nimport { applyArrayHooks } from './arrayHook'\n\ndeclare function execScript(code: string, type: string): void\ndeclare function parseVB(code: string): void\n\nexport default function(): ObservePolicy {\n\tif (GLOBAL.VBArray) {\n\t\ttry {\n\t\t\texecScript(['Function parseVB(code)', '\\tExecuteGlobal(code)', 'End Function'].join('\\n'), 'VBScript')\n\n\t\t\taddDKeys(VBPROXY_KEY, VBPROXY_CTOR_KEY)\n\n\t\t\treturn {\n\t\t\t\t__name: 'VBProxy',\n\t\t\t\t__proxy: 'vb',\n\t\t\t\t__createProxy<T extends ObserverTarget>(observer: IObserver<T>, target: T, isArray: boolean): T {\n\t\t\t\t\treturn isArray ? (applyArrayHooks(target as any[]), target) : new VBProxy(target, observer).__proxy\n\t\t\t\t},\n\t\t\t\t__watch<T extends ObserverTarget>(observer: IObserver<T>, prop: string, watcher: IWatcher): Error {\n\t\t\t\t\tif (!observer.isArray && !observer.target[VBPROXY_KEY].__props[prop]) {\n\t\t\t\t\t\treturn new Error(`property[${prop}] is not defined`)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(e.message, e)\n\t\t}\n\t}\n}\n\nexport class VBProxy<T extends {}> {\n\tprivate readonly __source: T\n\t/**\n\t * function property map\n\t * \t- key: property name\n\t * \t- value: [scoped function, original function]\n\t */\n\tprivate readonly __fns: { [name: string]: [Function, Function] }\n\treadonly __props: { [prop: string]: boolean }\n\tprivate readonly __observer: IObserver<T>\n\treadonly __proxy: T\n\n\tconstructor(source: T, observer: IObserver<T>) {\n\t\tconst props = [],\n\t\t\tpropMap: { [prop: string]: boolean } = create(null),\n\t\t\t__fns: string[] = [],\n\t\t\tfns: { [prop: string]: [Function, Function] } = create(null)\n\t\tlet prop: string,\n\t\t\ti = 0,\n\t\t\tj = 0\n\n\t\tfor (prop in source) {\n\t\t\tif (!isKey(prop)) {\n\t\t\t\tpropMap[prop] = true\n\t\t\t\tprops[i++] = prop\n\t\t\t\tif (isFn(source[prop])) __fns[j++] = prop\n\t\t\t}\n\t\t}\n\t\tapplyProps(props, propMap, OBJECT_DEFAULT_PROPS)\n\t\tapplyProps(props, propMap, getDKeys())\n\t\tconst proxy = createVBClass(props, this)\n\n\t\twhile (j--) {\n\t\t\tprop = __fns[j]\n\t\t\tfns[prop] = [, source[prop]]\n\t\t}\n\n\t\tthis.__source = source\n\t\tthis.__observer = observer\n\t\tthis.__proxy = proxy\n\t\tthis.__fns = fns\n\t\tthis.__props = propMap\n\t\tsource[VBPROXY_KEY] = this\n\t}\n\n\tset(prop: string, value: any) {\n\t\tconst { __source: source, __fns: fns } = this\n\t\tif (isFn(value)) {\n\t\t\tfns[prop] = [, value]\n\t\t} else if (fns[prop]) {\n\t\t\tfns[prop] = null\n\t\t}\n\t\tconst original = source[prop]\n\t\tif (original !== value) {\n\t\t\tthis.__observer.notify(prop, original)\n\t\t}\n\t\tsource[prop] = value\n\t}\n\n\tget(prop: string) {\n\t\tconst fn = this.__fns[prop]\n\t\treturn fn ? fn[0] || (fn[0] = fn[1].bind(this.__proxy)) : this.__source[prop]\n\t}\n}\n\nfunction applyProps(props: string[], propMap: { [key: string]: boolean }, applyProps: string[]) {\n\tlet i = applyProps.length,\n\t\tj = props.length,\n\t\tprop: string\n\twhile (i--) {\n\t\tprop = applyProps[i]\n\t\tif (!isKey(prop) && propMap[prop] !== true) {\n\t\t\tpropMap[prop] = true\n\t\t\tprops[j++] = prop\n\t\t}\n\t}\n}\nfunction isKey(prop: string) {\n\treturn prop === VBPROXY_KEY || prop === VBPROXY_CTOR_KEY\n}\n\nexport const VBPROXY_KEY = '__vbclass_binding__',\n\tVBPROXY_CTOR_KEY = '__vbclass_constructor__',\n\tOBJECT_DEFAULT_PROPS = [\n\t\tP_CTOR,\n\t\tP_OWNPROP,\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'toLocaleString',\n\t\t'toString',\n\t\t'valueOf'\n\t]\n\nconst CONSTRUCTOR_SCRIPT = `\n\tPublic [${VBPROXY_KEY}]\n\tPublic Default Function [${VBPROXY_CTOR_KEY}](source)\n\t\tSet [${VBPROXY_KEY}] = source\n\t\tSet [${VBPROXY_CTOR_KEY}] = Me\n\tEnd Function\n\t`,\n\tclassPool = create(null)\n\nfunction genAccessorScript(prop: string): string {\n\treturn `\n\tPublic Property Let [${prop}](value)\n\t\tCall [${VBPROXY_KEY}].set(\"${prop}\", value)\n\tEnd Property\n\tPublic Property Set [${prop}](value)\n\t\tCall [${VBPROXY_KEY}].set(\"${prop}\", value)\n\tEnd Property\n\n\tPublic Property Get [${prop}]\n\tOn Error Resume Next\n\t\tSet [${prop}] = [${VBPROXY_KEY}].get(\"${prop}\")\n\tIf Err.Number <> 0 Then\n\t\t[${prop}] = [${VBPROXY_KEY}].get(\"${prop}\")\n\tEnd If\n\tOn Error Goto 0\n\tEnd Property\n\n`\n}\n\nfunction genClassScript(className: string, props: string[]): string {\n\tconst buffer = ['Class ' + className, CONSTRUCTOR_SCRIPT],\n\t\tl = props.length\n\tlet i = 0\n\tfor (; i < l; i++) buffer[i + 3] = genAccessorScript(props[i])\n\tbuffer[i + 3] = 'End Class'\n\treturn buffer.join('\\n')\n}\n\nlet classNameGenerator = 1\nfunction createVBClass<T extends {}>(props: string[], desc: VBProxy<T>): T {\n\tconst classKey = props.sort().join('|')\n\tlet factoryName = classPool[classKey]\n\tif (!factoryName) {\n\t\tconst className = `VBClass${classNameGenerator++}`\n\t\tfactoryName = `${className}Factory`\n\n\t\t// build VB Class\n\t\tparseVB(genClassScript(className, props))\n\n\t\tparseVB(`\nFunction ${factoryName}(desc)\n\tDim o\n\tSet o=(New ${className})(desc)\n\tSet ${factoryName} = o\nEnd Function`)\n\n\t\tclassPool[classKey] = factoryName\n\t}\n\treturn GLOBAL[factoryName](desc)\n}\n","/**\n * @module observer\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Dec 26 2018 13:59:10 GMT+0800 (China Standard Time)\n * @modified Wed Apr 10 2019 13:51:37 GMT+0800 (China Standard Time)\n */\n\nimport { ObserverTarget, IWatcher, OBSERVER_KEY, IObserver, ARRAY_CHANGE, ObserverCallback } from './IObserver'\nimport { ObservePolicy } from './ObservePolicy'\nimport proxyPolicy from './ProxyPolicy'\nimport accessorPolicy from './AccessorPolicy'\nimport vbPolicy from './VBPolicy'\nimport { nextTick } from '../nextTick'\nimport { FnList, List } from '../list'\nimport { parsePath, formatPath, get, set } from '../path'\nimport { defValue, create, isArray, isPrimitive, isNil, toStrType, eq, isObject, SKIP } from '../util'\nimport { assert } from '../assert'\n\nfunction isObserverTarget(obj: any) {\n\treturn obj && (isArray(obj) || isObject(obj))\n}\n\n/**\n * is array change property\n * @param observer \tobserver\n * @param prop \t\tproperty of the observer's target\n */\nfunction isArrayChangeProp<T extends ObserverTarget>(observer: IObserver<T>, prop: string) {\n\treturn observer.isArray && prop === ARRAY_CHANGE\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        topic                                         *\n *                                                                                      */\n//========================================================================================\n\n/**\n * special object\n * - special object indicates that the topic has not changed\n */\nconst V = {}\n\n/**\n * get property value on object\n * @param obj \tobject\n * @param prop \tproperty\n */\nfunction getValue(obj: any, prop: string) {\n\treturn obj === undefined || obj === null ? undefined : obj[prop]\n}\n\n// id generator of topic\nlet topicIdGen = 0\n\n// the dirty topic queue waiting for collection\nconst collectQueue: Topic[] = []\n\n// the dirty topic queue waiting for notification\nconst dirtyQueue: Topic[] = []\n\n// flags of topic\nconst TOPIC_ENABLED_FLAG = 0x1, // topic is enabled\n\tTOPIC_LISTEN_FLAG = 0x2, // topic is listend\n\tTOPIC_SUB_FLAG = 0x4 // topic has subtopic\n\n/**\n * @ignore\n */\nclass Topic {\n\treadonly __id: number\n\n\t// parent topic\n\treadonly __parent: Topic\n\n\t// own observer\n\treadonly __owner: Observer<any>\n\n\t// watch property\n\treadonly __prop: string\n\n\t// binded observer\n\t__observer: Observer<any>\n\n\t// property path\n\t__path: string[]\n\n\t// listeners\n\t__listeners: FnList<ObserverCallback<any>>\n\n\t// the original value before change\n\t__original: any\n\n\t// collected dirty value: [new value, original value, force notify]\n\t__dirty: [any, any, boolean]\n\n\t// subtopics\n\t__subs: Topic[]\n\n\t// cache of subtopics\n\t__subCache: { [key: string]: Topic }\n\n\t// flags: TOPIC_ENABLED_FLAG | TOPIC_LISTEN_FLAG | TOPIC_SUB_FLAG\n\t__state: number\n\n\t/**\n\t * create a Topic\n\t * @param owner\t\town observer\n\t * @param prop\t\twatch property\n\t * @param parent\tparent topic\n\t */\n\tconstructor(owner: Observer<any>, prop: string, parent?: Topic) {\n\t\tthis.__state = 0\n\t\tthis.__original = V // special object indicates that the topic has not changed\n\t\tthis.__owner = owner\n\t\tthis.__prop = prop\n\t\tthis.__parent = parent\n\t\tthis.__id = topicIdGen++\n\t}\n\n\t/**\n\t * add listener\n\t * @param path\t\tpath of topic\n\t * @param cb\t\tobserve callback\n\t * @param scope\t\tscope of the callback\n\t * @return listen-id | undefined\n\t */\n\t__listen(path: string[], cb: ObserverCallback<any>, scope: any): string {\n\t\tlet { __listeners: listeners } = this\n\t\tif (!listeners) {\n\t\t\tthis.__listeners = listeners = new FnList<ObserverCallback<any>>()\n\t\t\tthis.__path = path\n\t\t}\n\t\tconst id = listeners.add(cb, scope)\n\t\tid && (this.__state |= TOPIC_LISTEN_FLAG | TOPIC_ENABLED_FLAG)\n\t\treturn id\n\t}\n\n\t/**\n\t * remove listener by callback\n\t * @param cb\t\tobserve callback\n\t * @param scope\t\tscope of the callback\n\t */\n\t__unlisten(cb: ObserverCallback<any>, scope: any) {\n\t\tconst { __listeners: listeners } = this\n\t\tif (listeners) {\n\t\t\tlisteners.remove(cb, scope)\n\t\t\tthis.____unlisten(listeners)\n\t\t}\n\t}\n\n\t/**\n\t * remove listener by listen-id\n\t * @param id\tlisten-id\n\t */\n\t__unlistenId(id: string) {\n\t\tconst { __listeners: listeners } = this\n\t\tif (listeners) {\n\t\t\tlisteners.removeId(id)\n\t\t\tthis.____unlisten(listeners)\n\t\t}\n\t}\n\n\t/**\n\t * Clear all unlistening leaf topics (!TOPIC_LISTEN_FLAG && !TOPIC_SUB_FLAG)\n\t * @param listeners\tlisteners\n\t */\n\tprivate ____unlisten(listeners: FnList<ObserverCallback<any>>) {\n\t\tif (!listeners.size()) {\n\t\t\t// this topic has no listeners, clear the listen flag\n\t\t\tvar topic: Topic = this,\n\t\t\t\tparent: Topic\n\t\t\ttopic.__state &= ~TOPIC_LISTEN_FLAG\n\t\t\twhile (topic.__state === TOPIC_ENABLED_FLAG) {\n\t\t\t\t// the topic has no listeners and subtopics\n\t\t\t\t//  - unbind the observer on the topic\n\t\t\t\t//  - clear topic state\n\t\t\t\t//  - remove from the parent topic\n\t\t\t\ttopic.__bind()\n\t\t\t\ttopic.__state = 0\n\t\t\t\tif (!(parent = topic.__parent)) break\n\t\t\t\tparent.__removeSub(topic)\n\t\t\t\ttopic = parent // re-check the parent topic\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * bind observer\n\t * @param observer new observer\n\t */\n\t__bind(observer?: Observer<any>) {\n\t\tconst { __observer: org } = this\n\t\tif (org !== observer) {\n\t\t\torg && org.__unwatchTopic(this) // unbind old observer\n\t\t\tif (observer) {\n\t\t\t\tconst err: Error = observer.__watchTopic(this)\n\t\t\t\tif (err) {\n\t\t\t\t\tconst path = this.__getPath()\n\t\t\t\t\terr.message = `observer[${formatPath(path)}]: can not watch ${formatPath(\n\t\t\t\t\t\tpath.slice(-1)\n\t\t\t\t\t)} on ${toStrType(observer.target)}${\n\t\t\t\t\t\tpath.length > 1 ? `[${formatPath(path.slice(0, -1))}]` : ''\n\t\t\t\t\t}, ${err.message}.`\n\t\t\t\t\tthrow err\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.__observer = observer\n\t\t}\n\t}\n\n\t/**\n\t * get a subtopic from the cache\n\t * @param prop property\n\t */\n\t__getSub(prop: string): Topic {\n\t\tconst { __subCache: subCache } = this\n\t\treturn subCache && subCache[prop]\n\t}\n\n\t/**\n\t * get or create a subtopic on the cache\n\t * @param subProp\tproperty of the subtopic\n\t * @return subtopic\n\t */\n\t__addSub(subProp: string): Topic {\n\t\tconst subCache: { [key: string]: Topic } =\n\t\t\t\tthis.__subCache || ((this.__subs = []), (this.__subCache = create(null))),\n\t\t\tsub: Topic = subCache[subProp] || (subCache[subProp] = new Topic(this.__owner, subProp, this))\n\n\t\tif (!(sub.__state & TOPIC_ENABLED_FLAG)) {\n\t\t\t// init the subtopic\n\n\t\t\tconst { __subs: subs, __observer: observer } = this\n\n\t\t\t// 1. bind observer\n\t\t\tif (observer) {\n\t\t\t\tconst { __prop: prop } = this\n\n\t\t\t\tvar subObserver: Observer<any>\n\n\t\t\t\tif (subs[0]) {\n\t\t\t\t\tsubObserver = subs[0].__observer\n\t\t\t\t} else if (!isArrayChangeProp(observer, prop)) {\n\t\t\t\t\tconst subTarget = observer.target[prop]\n\t\t\t\t\tif (isObserverTarget(subTarget)) {\n\t\t\t\t\t\tsubObserver = __loadSubObserver(observer, prop, subTarget)\n\t\t\t\t\t}\n\t\t\t\t\t//#if _DEBUG\n\t\t\t\t\telse if (!isNil(subTarget)) {\n\t\t\t\t\t\tsub.__ignorePath(2, toStrType(subTarget))\n\t\t\t\t\t}\n\t\t\t\t\t//#endif\n\t\t\t\t}\n\t\t\t\t//#if _DEBUG\n\t\t\t\telse {\n\t\t\t\t\tsub.__ignorePath(2, 'Array')\n\t\t\t\t}\n\t\t\t\t//#endif\n\t\t\t\tsub.__bind(subObserver)\n\t\t\t}\n\n\t\t\t// 2. attach subtopic\n\t\t\tsub.__state |= TOPIC_ENABLED_FLAG\n\t\t\tsubs.push(sub)\n\t\t}\n\n\t\tthis.__state |= TOPIC_SUB_FLAG | TOPIC_ENABLED_FLAG\n\n\t\treturn sub\n\t}\n\n\t/**\n\t * remove the subtopic from the subs\n\t * @param topic topic\n\t */\n\t__removeSub(topic: Topic) {\n\t\tconst { __subs: subs } = this\n\t\tconst l = subs.length\n\t\tlet i = l\n\t\twhile (i--) {\n\t\t\tif (topic === subs[i]) {\n\t\t\t\tsubs.splice(i, 1)\n\t\t\t\tl === 1 && (this.__state &= ~TOPIC_SUB_FLAG)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tassert('un-attached topic')\n\t}\n\n\t//#if _DEBUG\n\tprivate __ignorePath(i: number, type: string, msg?: string) {\n\t\tconst path = this.__getPath()\n\t\tconsole.warn(\n\t\t\t`observer[{}]: ignore {} on {}{}{}.`,\n\t\t\tformatPath(path),\n\t\t\tformatPath(path.slice(-i)),\n\t\t\ttype,\n\t\t\tpath.length > i ? `[${formatPath(path.slice(0, -i))}]` : '',\n\t\t\tmsg || '',\n\t\t\tthis.__owner.target\n\t\t)\n\t}\n\n\tprivate __ignoreSubPaths(subs: Topic[], len: number, type: string) {\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tsubs[i].__ignorePath(2, type)\n\t\t}\n\t}\n\n\t//#endif\n\n\tprivate __getPath() {\n\t\tlet path: string[] = this.__path\n\t\tif (!path) {\n\t\t\tconst { __parent: parent, __prop: prop } = this\n\t\t\tthis.__path = path = parent ? parent.__getPath().concat(prop) : [prop]\n\t\t}\n\t\treturn path\n\t}\n\n\t/**\n\t * mark the change in topic\n\t *\n\t * @param original original value\n\t */\n\t__update(original: any) {\n\t\tif (this.__original === V) {\n\t\t\tthis.__original = original\n\n\t\t\t// add to collect queue\n\t\t\tconst l = collectQueue.length\n\t\t\tcollectQueue[l] = this\n\t\t\t!l && nextTick(collect)\n\t\t}\n\t}\n\n\t/**\n\t * collect the dirty topics(this topic and subtopics) from collectQueue\n\t * may collected by parent-topic\n\t */\n\t__collect() {\n\t\tconst { __original: original } = this\n\t\tif (original !== V) {\n\t\t\tconst { __observer: observer } = this\n\n\t\t\tthis.__original = V\n\n\t\t\tobserver && this.____collect(observer, observer.target, original, false)\n\t\t}\n\t\t// this topic has been collected, retains its dirty value\n\t}\n\n\t/**\n\t * collect the dirty topics(this topic and subtopics)\n\t * - collect from collectQueue\n\t * \t1. this topic has been collected, stop collect\n\t * \t2. save the dirty value when the topic has a listener\n\t * \t3. clean the change state\n\t * \t4. collect the subtopics\n\t *\t\tuse this original value when subtopic has not changed\n\t *\t\tuse the subtopic's original value when subtopic is changed\n\t * \t\tclean the change state\n\t *\t\treplace the new value on subtopics\n\t * - re-collect by parent-topic (this does not happen after the topics are sorted by ID before collection)\n\t * \t1. replace the new value and discard the original value(keep the existing original value)\n\t * \t2. re-collect subtopics\n\t *\n\t * @param observer \tobserver of this topic\n\t * @param target \tnew target of this topic\n\t * @param original \toriginal value of this topic\n\t * @param force  \tforce notify\n\t */\n\tprivate ____collect(observer: Observer<any>, target: any, original: any, force: boolean) {\n\t\tconst { __state: flags, __prop: prop } = this\n\t\tlet dirty: [any, any, boolean?],\n\t\t\tsubTarget: any = V // lazy load the sub-target\n\n\t\tif (flags & TOPIC_LISTEN_FLAG) {\n\t\t\tif (!(dirty = this.__dirty)) {\n\t\t\t\tthis.__dirty = dirty = [, original, force]\n\t\t\t\tdirtyQueue.push(this)\n\t\t\t} else if (force) {\n\t\t\t\tdirty[2] = force\n\t\t\t\t// if this topic has been changed and collected, retains its original value\n\t\t\t}\n\t\t\t// set the new value\n\t\t\tdirty[0] = observer && isArrayChangeProp(observer, prop) ? target : (subTarget = getValue(target, prop))\n\t\t}\n\n\t\tif (flags & TOPIC_SUB_FLAG) {\n\t\t\tsubTarget === V && (subTarget = getValue(target, prop))\n\n\t\t\tconst { __subs: subs } = this\n\t\t\tconst l = subs.length\n\n\t\t\tvar subObserver: Observer<any>,\n\t\t\t\torgSubObserver: Observer<any>,\n\t\t\t\tsub: Topic,\n\t\t\t\tsubOriginal: any,\n\t\t\t\ti = 0\n\n\t\t\tif (observer) {\n\t\t\t\tif (!isArrayChangeProp(observer, prop)) {\n\t\t\t\t\tif (isObserverTarget(subTarget)) {\n\t\t\t\t\t\tsubObserver = __loadSubObserver(observer, prop, subTarget)\n\t\t\t\t\t\tif (proxyEnable) {\n\t\t\t\t\t\t\tsubTarget = subObserver.target\n\t\t\t\t\t\t\tdirty && (dirty[0] = subObserver.proxy) // update dirty proxy\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//#if _DEBUG\n\t\t\t\t\telse if (!isNil(subTarget)) {\n\t\t\t\t\t\tthis.__ignoreSubPaths(subs, l, toStrType(subTarget))\n\t\t\t\t\t}\n\t\t\t\t\t//#endif\n\t\t\t\t}\n\t\t\t\t//#if _DEBUG\n\t\t\t\telse {\n\t\t\t\t\tthis.__ignoreSubPaths(subs, l, 'Array')\n\t\t\t\t}\n\t\t\t\t//#endif\n\t\t\t} else if (proxyEnable && dirty) {\n\t\t\t\tdirty[0] = proxy(dirty[0])\n\t\t\t}\n\n\t\t\tfor (; i < l; i++) {\n\t\t\t\tsub = subs[i]\n\t\t\t\torgSubObserver = sub.__observer\n\t\t\t\tif (!subObserver || orgSubObserver != subObserver) {\n\t\t\t\t\tsub.__bind(subObserver)\n\n\t\t\t\t\tif ((subOriginal = sub.__original) === V) {\n\t\t\t\t\t\t// 1. this subtopic has not been changed, using the original value of the current topic\n\t\t\t\t\t\t// *2. this subtopic has been changed and collected, and the collector retains its original value\n\t\t\t\t\t\t// *   this does not happen after the topics are sorted by ID before collection\n\t\t\t\t\t\tsubOriginal = sub.__dirty || isNil(original) ? undefined : original[sub.__prop]\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// this subtopic was changed but not collected, collected in advance\n\t\t\t\t\t\tsub.__original = V\n\t\t\t\t\t}\n\n\t\t\t\t\tsub.____collect(subObserver, subTarget, subOriginal, orgSubObserver != subObserver)\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (dirty && proxyEnable) {\n\t\t\tdirty[0] = proxy(dirty[0])\n\t\t}\n\t}\n}\n\nfunction compareTopic(topic1: Topic, topic2: Topic) {\n\treturn topic1.__id - topic2.__id\n}\n\n/**\n * collect the dirty topics on the collectQueue\n */\nexport function collect() {\n\t//#if _DEBUG\n\tconst start = Date.now()\n\t//#endif\n\n\tlet l = collectQueue.length,\n\t\ti = 0\n\n\t// sort by topic id\n\tcollectQueue.sort(compareTopic)\n\n\tfor (; i < l; i++) {\n\t\tcollectQueue[i].__collect()\n\t}\n\n\tcollectQueue.length = 0\n\n\t//#if _DEBUG\n\tconsole.log(\n\t\t`Collect ${dirtyQueue.length} dirty topics from the collection queue (${l}), use ${Date.now() - start}ms`\n\t)\n\t//#endif\n\n\tnotify()\n}\n\n/**\n * notify all of the dirty topics\n */\nfunction notify() {\n\t//#if _DEBUG\n\tconst start = Date.now()\n\tlet topics = 0,\n\t\tlistens = 0\n\t//#endif\n\n\tconst l = dirtyQueue.length\n\tlet topic: Topic,\n\t\towner: Observer<any>,\n\t\tpath: string[],\n\t\tvalue: any,\n\t\toriginal: any,\n\t\tdirty: [any, any, boolean],\n\t\ti = 0\n\n\tfor (; i < l; i++) {\n\t\ttopic = dirtyQueue[i]\n\t\tdirty = topic.__dirty\n\t\tvalue = dirty[0]\n\t\toriginal = dirty[1]\n\n\t\ttopic.__dirty = null // clean the dirty\n\n\t\tif (dirty[2] || value !== original || !isPrimitive(value)) {\n\t\t\t// real dirty\n\t\t\towner = topic.__owner\n\t\t\tpath = topic.__path\n\t\t\ttopic.__listeners.each((fn, scope) => {\n\t\t\t\tscope ? fn.call(scope, path, value, original, owner) : fn(path, value, original, owner)\n\n\t\t\t\t//#if _DEBUG\n\t\t\t\tlistens++\n\t\t\t\t//#endif\n\t\t\t})\n\n\t\t\t//#if _DEBUG\n\t\t\ttopics++\n\t\t\t//#endif\n\t\t}\n\t}\n\n\tdirtyQueue.length = 0\n\n\t//#if _DEBUG\n\tconsole.log(\n\t\t`${listens} listen-callbacks of ${topics}/${l} dirty topics have been notified, use ${Date.now() - start}ms`\n\t)\n\t//#endif\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       Observer                                       *\n *                                                                                      */\n//========================================================================================\n\nlet __original__: any\nfunction __updateTopicCB(topic: Topic) {\n\ttopic.__update(__original__)\n}\n\nclass Watcher extends List<Topic> implements IWatcher {\n\tconstructor() {\n\t\tsuper()\n\t}\n\t/**\n\t * notify topics\n\t *\n\t * @param original the original value\n\t */\n\tnotify(original: any) {\n\t\t__original__ = original\n\t\tthis.eachUnsafe(__updateTopicCB)\n\t\t__original__ = 0\n\t}\n}\n\nclass Observer<T extends ObserverTarget> implements IObserver<T> {\n\t/**\n\t * observer target\n\t */\n\treadonly target: T\n\n\t/**\n\t * observer proxy\n\t */\n\treadonly proxy: T\n\n\t/**\n\t * is array target\n\t */\n\treadonly isArray: boolean\n\n\t/**\n\t * topics\n\t * \t- key: property of topic in the observer's target\n\t * \t- value: topic\n\t */\n\tprivate __topics: { [key: string]: Topic }\n\n\t/**\n\t * watchers\n\t * \t- key: property of watcher in the observer's target\n\t * \t- value: watcher\n\t */\n\tprivate readonly __watchers: { [key: string]: Watcher }\n\n\t/**\n\t * properties of watchers in the observer's target\n\t */\n\tprivate readonly __watcherProps: string[]\n\n\t/**\n\t * create Observer\n\t *\n\t * @param target observer target\n\t */\n\tconstructor(target: T) {\n\t\tconst arrayTarget = isArray(target)\n\n\t\tassert.is(arrayTarget || isObject(target), `the observer's target can only be an object or an array`)\n\n\t\tconst watchers = create(null)\n\t\tthis.__watchers = watchers\n\t\tthis.__watcherProps = []\n\n\t\tthis.isArray = arrayTarget\n\t\tthis.target = target\n\n\t\t// bind observer key on the observer's target\n\t\tdefValue(target, OBSERVER_KEY, this, false, false, false)\n\n\t\tthis.proxy = policy.__createProxy(this, target, arrayTarget)\n\t}\n\n\t/**\n\t * observe changes in the observer's target\n\t *\n\t * @param propPath \tproperty path for observe, parse string path by {@link parsePath}\n\t * @param cb\t\tcallback\n\t * @param scope\t\tscope of callback\n\t * @return listen-id\n\t */\n\tobserve(propPath: string | string[], cb: ObserverCallback<T>, scope?: any): string {\n\t\tconst path: string[] = parsePath(propPath),\n\t\t\ttopics = this.__topics || (this.__topics = create(null)),\n\t\t\tprop0 = path[0]\n\n\t\tlet topic = topics[prop0] || (topics[prop0] = new Topic(this, prop0)),\n\t\t\ti = 1,\n\t\t\tl = path.length\n\n\t\ttopic.__bind(this)\n\t\ttopic.__flags |= TOPIC_ENABLED_FLAG\n\n\t\tfor (; i < l; i++) {\n\t\t\ttopic = topic.__addSub(path[i])\n\t\t}\n\n\t\treturn topic.__listen(path, cb, scope)\n\t}\n\n\t/**\n\t * get listen-id of callback in the observer's target\n\t *\n\t * @param propPath \tproperty path for observe, parse string path by {@link parsePath}\n\t * @param cb\t\tcallback\n\t * @param scope\t\tscope of callback\n\t * @return listen-id\n\t */\n\tobserved(propPath: string | string[], cb: ObserverCallback<T>, scope?: any): string {\n\t\tconst topic = this.__getTopic(parsePath(propPath))\n\t\tlet listeners: FnList<ObserverCallback<any>>\n\t\treturn topic && (listeners = topic.__listeners) && listeners.has(cb, scope)\n\t}\n\n\t/**\n\t * has listen-id in the observer's target\n\t *\n\t * @param propPath \tproperty path for observe, parse string path by {@link parsePath}\n\t * @param id\t\tlisten-id\n\t * @return listen-id\n\t */\n\tobservedId(propPath: string | string[], id: string): boolean {\n\t\tconst topic = this.__getTopic(parsePath(propPath))\n\t\tlet listeners: FnList<ObserverCallback<any>>\n\t\treturn topic && (listeners = topic.__listeners) && listeners.hasId(id)\n\t}\n\n\t/**\n\t * cancel observing the changes in the observer's target\n\t *\n\t * @param propPath\tproperty path for unobserve, parse string path by {@link parsePath}\n\t * @param cb\t\tcallback\n\t * @param scope\t\tscope of callback\n\t */\n\tunobserve(propPath: string | string[], cb: ObserverCallback<T>, scope?: any) {\n\t\tconst topic = this.__getTopic(parsePath(propPath))\n\t\ttopic && topic.__unlisten(cb, scope)\n\t}\n\n\t/**\n\t * cancel observing the changes in the observer's target by listen-id\n\t *\n\t * @param propPath\tproperty path for unobserve, parse string path by {@link parsePath}\n\t * @param id \t\tlisten-id\n\t */\n\tunobserveId(propPath: string | string[], id: string) {\n\t\tconst topic = this.__getTopic(parsePath(propPath))\n\t\ttopic && topic.__unlistenId(id)\n\t}\n\n\t/**\n\t * notify change on the property\n\t *\n\t * @param prop\t\tthe property\n\t * @param original \tthe original value\n\t */\n\tnotify(prop: string, original: any) {\n\t\tconst watcher = this.__watchers[prop]\n\t\twatcher && watcher.notify(original)\n\t}\n\n\t/**\n\t * notify the observer that properties in the target have changed\n\t *\n\t * @param props \t\tnotify properties, notify all watchers when the props is null or undefined\n\t * @param getOriginal\tget the original value\n\t * @param execludes\t\tdo not notify watchers in execludes\n\t */\n\tnotifies(props: string[], getOriginal: (prop: string, ob: Observer<T>) => any, execludes?: { [key: string]: any }) {\n\t\tprops || (props = this.__watcherProps)\n\t\tconst { __watchers: watchers } = this\n\t\tlet prop: string,\n\t\t\twatcher: Watcher,\n\t\t\ti = props.length,\n\t\t\torigin: any\n\t\tif (execludes) {\n\t\t\twhile (i--) {\n\t\t\t\tprop = props[i]\n\t\t\t\tif (!execludes[prop] && (watcher = watchers[prop]) && watcher.size()) {\n\t\t\t\t\torigin = getOriginal(prop, this)\n\t\t\t\t\torigin !== SKIP && watcher.notify(origin)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile (i--) {\n\t\t\t\tprop = props[i]\n\t\t\t\tif ((watcher = watchers[prop]) && watcher.size()) {\n\t\t\t\t\torigin = getOriginal(prop, this)\n\t\t\t\t\torigin !== SKIP && watcher.notify(origin)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * watch the topic\n\t *\n\t * @private\n\t * @param topic topic\n\t * @return is successful\n\t */\n\t__watchTopic(topic: Topic): Error {\n\t\tconst { __watchers: watchers } = this\n\t\tconst { __prop: prop } = topic\n\t\tlet watcher: Watcher = watchers[prop],\n\t\t\terr: Error | void\n\t\tif (!watcher) {\n\t\t\twatchers[prop] = watcher = new Watcher()\n\t\t\tthis.__watcherProps.push(prop)\n\t\t\terr = policy.__watch(this as IObserver<T>, prop, watcher)\n\t\t}\n\t\twatcher.add(topic)\n\t\treturn err as Error\n\t}\n\n\t/**\n\t * unwatched the topic\n\t *\n\t * @private\n\t * @param topic topic\n\t */\n\t__unwatchTopic(topic: Topic) {\n\t\tthis.__watchers[topic.__prop].remove(topic)\n\t}\n\n\t/**\n\t * get topic by property path\n\t *\n\t * @param path property path of topic, parse string path by {@link parsePath}\n\t * @return topic | undefined\n\t */\n\tprivate __getTopic(path: string[]) {\n\t\tconst { __topics: topics } = this\n\t\tlet topic: Topic\n\t\tif (topics && (topic = topics[path[0]])) {\n\t\t\tfor (var i = 1, l = path.length; i < l; i++) {\n\t\t\t\tif (!(topic = topic.__getSub(path[i]))) break\n\t\t\t}\n\t\t}\n\t\treturn topic\n\t}\n\n\t/**\n\t * get the value at path of target object\n\t *\n\t * @param propPath \tproperty path of target object, parse string path by {@link parsePath}\n\t * @return the value\n\t */\n\tget(propPath: string | string[]): any {\n\t\treturn $get(this.target, propPath)\n\t}\n\n\t/**\n\t * set the value at path of target object\n\t *\n\t * @param propPath \tproperty path for target object, parse string path by {@link parsePath}\n\t * @param value\t\tthe value\n\t */\n\tset(propPath: string | string[], value: any) {\n\t\t$set(this.proxy, propPath, value)\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\ttoJSON() {}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        policy                                        *\n *                                                                                      */\n//========================================================================================\n\nconst policy: ObservePolicy = proxyPolicy() || accessorPolicy() || vbPolicy()\n\nassert.is(policy, 'The observer module is not supported.')\n\n//#if _DEBUG\nconsole.info(`the observer policy: ${policy.__name} -> `, policy)\n//#endif\n\nif (!policy.__createProxy) policy.__createProxy = (observer, target) => target\nif (!policy.__watch) policy.__watch = () => {}\n\nexport const proxyEnable = policy.__proxy\n\nlet __getObserver: <T extends ObserverTarget>(target: T) => Observer<T> = target => {\n\tconst ob = target[OBSERVER_KEY]\n\tif (ob && (ob.target === target || ob.proxy === target)) return ob\n}\n\n/**\n * get or create sub-observer (well fix proxy value)\n *\n * @param observer \tobserver\n * @param prop\t\tproperty of the observer's target\n * @param target\ttarget = observer.target[prop]\n * @return sub-observer\n */\nlet __loadSubObserver: <T extends ObserverTarget>(observer: Observer<any>, prop: string, target: T) => Observer<T> = (\n\tobserver,\n\tprop,\n\ttarget\n) => {\n\tconst subObserver: Observer<any> = __getObserver(target) || new Observer(target)\n\tif (subObserver.proxy !== target) observer.target[prop] = subObserver.proxy\n\treturn subObserver\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                          API                                         *\n *                                                                                      */\n//========================================================================================\n\n/**\n * get the original object of the observer on the object\n *\n * @param object the object\n * @return the original object | the object\n */\nlet source: <T extends ObserverTarget>(obj: T) => T = <T>(obj: T): T => {\n\tconst observer = obj && __getObserver(obj)\n\treturn observer ? observer.target : obj\n}\n\n/**\n * get the proxy object for the observer on the object\n *\n * @param object the object\n * @return the proxy object | the object\n */\nlet proxy: <T extends ObserverTarget>(obj: T) => T = <T>(obj: T): T => {\n\tconst observer = obj && __getObserver(obj)\n\treturn observer ? observer.proxy : obj\n}\n\n/**\n * support equals function between observer objects\n */\nlet $eq: (o1: any, o2: any) => boolean = (o1, o2) => {\n\treturn eq(o1, o2) || (o1 && o2 && (o1 = __getObserver(o1)) ? o1 === __getObserver(o2) : false)\n}\n\n/**\n * get the value at path of object\n *\n * @param obj \t\tthe object\n * @param path\t\tproperty path of object, parse string path by {@link parsePath}\n * @return the value | the proxy of value\n */\nlet $get: (obj: any, path: string | string[]) => any = (obj, path) => proxy(get(obj, path))\n\n/**\n * set the value at path of object\n *\n * @param obj \t\tthe object\n * @param path\t\tproperty path of object, parse string path by {@link parsePath}\n * @param value \tvalue\n */\nlet $set: (obj: any, path: string | string[], value: any) => void = (obj, path, value) => {\n\tpath = parsePath(path)\n\tconst l = path.length - 1\n\tlet i = 0,\n\t\tv: any\n\tfor (; i < l; i++) {\n\t\tv = obj[path[i]]\n\t\tobj = v === null || v === undefined ? (proxy(obj)[path[i]] = {}) : v\n\t}\n\tproxy(obj)[path[i]] = proxy(value)\n}\n\n// optimize on Non-Proxy policy \nif (!proxyEnable) {\n\t__getObserver = target => {\n\t\tconst oserver = target[OBSERVER_KEY]\n\t\tif (oserver && oserver.target === target) return oserver\n\t}\n\n\t__loadSubObserver = (observer, prop, target) => {\n\t\treturn __getObserver(target) || new Observer(target)\n\t}\n\n\tsource = obj => obj\n\n\tproxy = source\n\n\t$eq = eq\n\n\t$get = get\n\n\t$set = set\n}\n\n/**\n * get or create observer on object\n *\n * @param target \tthe target object\n * @return the observer\n */\nexport function observer<T extends ObserverTarget>(target: T): IObserver<T> {\n\treturn __getObserver(target) || new Observer(target)\n}\n\n/**\n * get or create observer on object\n *\n * @param target \tthe target object\n * @return the proxy object\n */\nexport function observable<T extends ObserverTarget>(target: T): T {\n\treturn observer(target).proxy\n}\n\n/**\n * observe changes in the target object\n *\n * @param target \tthe target object\n * @param propPath \tproperty path of object, parse string path by {@link parsePath}\n * @param cb\t\tcallback\n * @param scope\t\tscope of callback\n * @return listen-id\n */\nexport function observe<T extends ObserverTarget>(\n\ttarget: T,\n\tpropPath: string | string[],\n\tcb: ObserverCallback<T>,\n\tscope?: any\n): string {\n\tconst __observer = observer(target)\n\treturn __observer.observe(propPath, cb, scope)\n}\n\n/**\n * get listen-id of callback in the target object\n *\n * @param target \tthe target object\n * @param propPath \tproperty path of object, parse string path by {@link parsePath}\n * @param cb\t\tcallback\n * @param scope\t\tscope of callback\n * @return listen-id\n */\nexport function observed<T extends ObserverTarget>(\n\ttarget: T,\n\tpropPath: string | string[],\n\tcb: ObserverCallback<T>,\n\tscope?: any\n): string {\n\tconst __observer = __getObserver(target)\n\treturn __observer && __observer.observed(propPath, cb, scope)\n}\n\n/**\n * has listen-id in the target object\n *\n * @param target \tthe target object\n * @param propPath \tproperty path of object, parse string path by {@link parsePath}\n * @param id\t\tlisten-id\n */\nexport function observedId<T extends ObserverTarget>(target: T, propPath: string | string[], id: string): boolean {\n\tconst __observer = __getObserver(target)\n\treturn __observer && __observer.observedId(propPath, id)\n}\n\n/**\n * cancel observing the changes in the target object\n *\n * @param target \tthe target object\n * @param propPath \tproperty path of object, parse string path by {@link parsePath}\n * @param cb\t\tcallback\n * @param scope\t\tscope of callback\n */\nexport function unobserve<T extends ObserverTarget>(\n\ttarget: T,\n\tpropPath: string | string[],\n\tcb: ObserverCallback<T>,\n\tscope?: any\n) {\n\tconst __observer = __getObserver(target)\n\t__observer && __observer.unobserve(propPath, cb, scope)\n}\n\n/**\n * cancel observing the changes in the target object by listen-id\n *\n * @param target \tthe target object\n * @param propPath \tproperty path of object, parse string path by {@link parsePath}\n * @param listenId\tlisten-id\n */\nexport function unobserveId<T extends ObserverTarget>(target: T, propPath: string | string[], listenId: string) {\n\tconst __observer = __getObserver(target)\n\t__observer && __observer.unobserveId(propPath, listenId)\n}\n\n/**\n * get existing observer on object\n *\n * @return existing observer\n */\nexport const getObserver: <T extends ObserverTarget>(target: T) => IObserver<T> = __getObserver\n\nexport { source, proxy, $eq, $get, $set }\n","/**\n * Observe implementation on the Proxy of ES6\n * @module observer\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Mar 19 2019 14:12:23 GMT+0800 (China Standard Time)\n * @modified Wed Apr 10 2019 12:56:14 GMT+0800 (China Standard Time)\n */\n\nimport { IObserver, ObserverTarget, ARRAY_CHANGE, ARRAY_LENGTH } from './IObserver'\nimport { ObservePolicy } from './ObservePolicy'\nimport { T_UNDEF } from '../util/consts'\n\n/**\n * @ignore\n */\nexport default function(): ObservePolicy {\n\tif (typeof Proxy !== T_UNDEF)\n\t\treturn {\n\t\t\t__name: 'Proxy',\n\t\t\t__proxy: 'proxy',\n\t\t\t__createProxy<T extends ObserverTarget>(observer: IObserver<T>, target: T, isArray: boolean): T {\n\t\t\t\tlet setter: (source: ObserverTarget, prop: string, value: any) => boolean\n\t\t\t\tif (isArray) {\n\t\t\t\t\tvar len = target[ARRAY_LENGTH]\n\t\t\t\t\tsetter = (source, prop, value) => {\n\t\t\t\t\t\tif (prop === ARRAY_LENGTH) {\n\t\t\t\t\t\t\tif (len !== value) {\n\t\t\t\t\t\t\t\tobserver.notify(ARRAY_LENGTH, len)\n\t\t\t\t\t\t\t\tobserver.notify(ARRAY_CHANGE, observer.proxy)\n\t\t\t\t\t\t\t\tlen = value\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar orginal = source[prop],\n\t\t\t\t\t\t\t\tchanged = 0\n\t\t\t\t\t\t\tif (orginal !== value) {\n\t\t\t\t\t\t\t\tobserver.notify(prop, orginal)\n\t\t\t\t\t\t\t\tchanged = 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prop >= len) {\n\t\t\t\t\t\t\t\tobserver.notify(ARRAY_LENGTH, len)\n\t\t\t\t\t\t\t\tlen = target[ARRAY_LENGTH]\n\t\t\t\t\t\t\t\tchanged = 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchanged && observer.notify(ARRAY_CHANGE, observer.proxy)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsource[prop] = value\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsetter = (source, prop, value) => {\n\t\t\t\t\t\tvar orginal = source[prop]\n\t\t\t\t\t\tif (orginal !== value) {\n\t\t\t\t\t\t\tobserver.notify(prop, orginal)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsource[prop] = value\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn new Proxy(target, {\n\t\t\t\t\tset: setter\n\t\t\t\t}) as T\n\t\t\t}\n\t\t}\n}\n","/**\n * Observe implementation on the Object.defineProperty of ES5 or `__defineGetter__` and `__defineSetter__`\n * @module observer\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Mar 19 2019 14:12:23 GMT+0800 (China Standard Time)\n * @modified Wed Apr 10 2019 13:07:06 GMT+0800 (China Standard Time)\n */\n\nimport { IObserver, IWatcher, ARRAY_CHANGE, ObserverTarget, ARRAY_LENGTH } from './IObserver'\nimport { ObservePolicy } from './ObservePolicy'\nimport { propAccessor, defAccessor } from '../util'\nimport { applyArrayHooks } from './arrayHook'\n\n/**\n * @ignore\n */\nexport default function(): ObservePolicy {\n\tif (propAccessor)\n\t\treturn {\n\t\t\t__name: 'Accessor',\n\t\t\t__createProxy<T extends ObserverTarget>(observer: IObserver<T>, target: T, isArray: boolean): T {\n\t\t\t\tisArray && applyArrayHooks(target as any[])\n\t\t\t\treturn target\n\t\t\t},\n\t\t\t__watch<T extends ObserverTarget>(observer: IObserver<T>, prop: string, watcher: IWatcher): Error {\n\t\t\t\tconst { target } = observer\n\t\t\t\tlet setter: (newValue: any) => void\n\t\t\t\tif (!observer.isArray) {\n\t\t\t\t\tsetter = (newValue: any) => {\n\t\t\t\t\t\tif (value !== newValue) {\n\t\t\t\t\t\t\twatcher.notify(value)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalue = newValue\n\t\t\t\t\t}\n\t\t\t\t} else if (prop !== ARRAY_CHANGE && prop !== ARRAY_LENGTH) {\n\t\t\t\t\tsetter = (newValue: any) => {\n\t\t\t\t\t\tif (value !== newValue) {\n\t\t\t\t\t\t\twatcher.notify(value)\n\t\t\t\t\t\t\tobserver.notify(ARRAY_CHANGE, target)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalue = newValue\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tvar value: any = target[prop]\n\t\t\t\ttry {\n\t\t\t\t\tdefAccessor(target, prop, () => value, setter, true, false)\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn e\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n"],"names":["P_CTOR","P_PROTOTYPE","T_BOOL","T_FN","T_NUM","T_STRING","T_UNDEF","GLOBAL","window","global","self","EMPTY_FN","NULL_CTOR","DKeyMap","DKeys","addDKey","key","push","addDKeys","args","arguments","l","length","i","getDKeys","getCtor","o","C","Object","toString","prototype","toStr","obj","call","toStrType","match","eq","o1","o2","isNull","isUndef","undefined","isNil","isBool","mkIsPrimitive","isNum","isStr","isFn","isInt","isPrimitive","type","isBoolean","mkIs","Boolean","isNumber","Number","isString","String","isDate","Date","isReg","RegExp","isArray","Array","isTypedArray","ArrayBuffer","isView","isArrayLike","NodeList","HTMLCollection","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","len","isObj","isObject","Type","blankStrReg","isBlank","test","createFn","body","name","Function","join","applyScope","concat","applyBuilder","maxArgs","scope","offset","cases","slice","applyNoScope","applyScopeN","applyNoScopeN","apply","fn","applyN","_bind","varGenReg","funcProto","bind","argLen","bindPolyfill","this","bindArgs","argOffset","params","stickyReg","sticky","unicodeReg","unicode","REG_ESCAPE","reEscape","str","replace","$getProto","getPrototypeOf","$setProto","setPrototypeOf","prototypeOf","protoProp","protoOf","__setProto","proto","setProto","p","__defineGetter__","__defineSetter__","$defProp","defineProperty","exports","val","get","set","value","s","propDescriptor","e","propAccessor","defProp","prop","desc","TypeError","defValue","enumerable","configurable","writable","defAccessor","__hasOwn","hasOwnProp","__","doCreate","props","k","create","REG_PROPS","deepEq","actual","expected","doDeepEq","doDeepEqObj","eqObj","getTime","eqProps","eqArray","eqTypeArray","cache","charCode","index","charCodeAt","char","code","fromCharCode","cutStr","start","end","substring","cutLStr","substr","TRIM_REG","FIRST_LOWER_LETTER_REG","FIRST_UPPER_LETTER_REG","upper","toUpperCase","lower","toLowerCase","upperFirst","STR_ESCAPE_MAP","STR_ESCAPE","escapeStr","doAssign","target","sources","filter","startOffset","endOffset","source","defaultAssignFilter","assignIfFilter","Control","__desc","STOP","eachProps","callback","own","eachObj","eachArray","array","SKIP","doMapObj","each","copy","v","doMapArray","j","data","mapArray","parseCallback","idx","doIdxOfObj","r","doIdxOfArray","idxOfArray","doReduceObj","accumulator","rs","doReduceArray","defaultObjKeyHandler","defaultObjValueHandler","arr2obj","doArr2Obj","makeArray","mixin","behaviour","Class","PATH_BINDING","pathCache","pathReg","parsePath","propPath","cacheable","path","cidx","exec","lastIndex","SyntaxError","charAt","Error","formatPath","formatPathHandler","pad","chr","leftAlign","__pad","shorten","suffix","thousandSeparate","mkSeparator","binarySeparate","octalSeparate","hexSeparate","group","valReg","reg","numStr","separatorHandler","m","d","PLURAL_REG","pluralHandler","ies","es","ys","SINGULAR_REG","singularHandler","FORMAT_XPREFIX","FORMAT_PLUS","FORMAT_ZERO","FORMAT_SPACE","FORMAT_SEPARATOR","FORMAT_LEFT","FLAG_MAPPING","parseFlags","f","flags","paramPropR","widthR","formatReg","formatters","extendFormatter","fmt","getFormatter","vformat","getParam","defaultGetParam","param","paramProp","width","widx","wprop","fill","precision","pidx","pprop","shortenSuffix","parseParam","parseWidth","w","isFinite","paramIdx","getFormatParam","GET_PARAM_VAR","GET_PROP_VAR","STATE_VAR","createFormatter","getParamCode","getWidthCode","def","strs","formatter","mStart","mEnd","lastIdx","arr","codes","pushStr","append","strFormatter","numFormatter","parseNum","getPrefix","separator","num","prefix","plen","decimalPrefix","BASE_RADIXS","b","u","x","BASE_PREFIXS","baseFormatter","base","n","__toStr","xprefix","floatFormatter","____toStr","toExponential","toFixed","toPrecision","parseFloat","JSON","stringify","c","E","g","G","B","O","X","mkError","Err","msg","msgIdx","popErrStack","err","stack","assert","mkThrowAssertor","th","dmsg","ERROR","expect","message","mkAssertor","condition","split","paramStr","cond","expr","notThrow","UNDEFINED","BOOLEAN","NUMBER","STRING","FUNCTION","mkMsg","to","expectMsg","not","objFormatter","packTypeExpect","all","typeExpect","eql","nul","nil","undef","bool","primitive","number","string","date","typedArray","arrayLike","nan","isNaN","finite","blank","less","greater","range","DEFAULT_BINDING","List","binding","__length","__scaning","__ver","size","has","node","add","__insert","__tail","addFirst","insertAfter","__getNode","insertBefore","addAll","objs","__insertAll","addFirstAll","insertAfterAll","insertBeforeAll","prev","__siblingObj","next","first","__head","last","cb","__doLazyRemove","eachUnsafe","toArray","remove","__remove","clean","__lazyRemove","__clean","__initNode","toJSON","is","siblingIdx","sibling","__doInsert","nodeHead","nodeTail","head","__prev","tail","__doRemove","lazyRemoves","__lazyRemoves","DEFAULT_FN_BINDING","DEFAULT_SCOPE_BINDING","FnList","fnBinding","scopeBinding","__nodeMap","__list","parseScope","list","nodeMap","id","removeId","hasId","fnId","scopeId","DEFAULT_SCOPE_ID","fnIdGenerator","scopeIdGenerator","MutationObserver","textNode","document","createTextNode","flush","observe","characterData","setTimeout","pending","ticks","executeTick","t","nextTick","LINE_REG","Source","buff","__lines","__linePos","position","lines","linePos","escape","line","toSourceStr","escapeSourceStr","sourceStr","eachCharCodes","ignoreCase","eachCharCode","getAnotherCode","MatchError","$ruleErr","capturable","context","rule","pos","startPos","defaultErr","defaultMatch","idGen","Rule","$rule","options","onMatch","onErr","mkErr","error","src","userErr","matched","enter","getStart","startCodes","startCodeTest","startCodeIdx","nextCode","setStartCodes","setCodeIdx","mkExpr","setExpr","EXPECT","getExpr","MatchContext","orgOffset","parent","result","__buff","__offset","__orgOffset","__advanced","__code","__flushCode","__setAdvanced","advanced","notLess","commit","advance","margeState","rollback","checkpoint","resultLen","reset","orgBuff","currPos","nextChar","resultSize","MAX","ComplexRule","repeat","builder","rMin","rMax","notGreater","_this","rmatch","parse","ctx","unshift","init","rules","names","rnames","EXPECTS","__init","getRules","consume","AndRule","testRule","cp","out","OrRule","starts","rStarts","upErr","MatchRule","comsume","CharMatchRule","allows","chars","RegMatchRule","regexp","pick","pattern","multiline","stickyMatch","execMatch","spicker","pickNone","pickTestStr","picker","pickAll","mkPicker","StringMatchRule","discardMatch","mkMatch","defaultMatchCallback","isStrOrCodes","isMatchPattern","parseRuleOptions","strMatch","mkComplexRule","defaultRepeat","_rule","rulesBuilder","OBSERVER_KEY","ARRAY_CHANGE","ARRAY_LENGTH","arrayHooks","ARRAY_LEN_CHANGE","getArrayOriginValue","ob","proxy","applyArrayHooks","hook","pop","splice","notifies","shift","hooker","methods","method","execludes","VBProxy","observer","propMap","__fns","fns","isKey","applyProps","OBJECT_DEFAULT_PROPS","classKey","sort","factoryName","classPool","className","classNameGenerator","parseVB","buffer","CONSTRUCTOR_SCRIPT","VBPROXY_KEY","genClassScript","createVBClass","__source","__observer","__proxy","__props","original","notify","VBPROXY_CTOR_KEY","isObserverTarget","isArrayChangeProp","V","getValue","__original__","topicIdGen","collectQueue","dirtyQueue","Topic","owner","__state","__original","__owner","__prop","__parent","__id","__listen","listeners","__listeners","__path","TOPIC_LISTEN_FLAG","__unlisten","____unlisten","__unlistenId","topic","__bind","__removeSub","org","__unwatchTopic","__watchTopic","__getPath","__getSub","subCache","__subCache","__addSub","subProp","__subs","sub","subs","subObserver","__ignorePath","subTarget","__loadSubObserver","TOPIC_SUB_FLAG","console","warn","__ignoreSubPaths","__update","collect","__collect","____collect","force","dirty","__dirty","orgSubObserver","subOriginal","proxyEnable","compareTopic","topic1","topic2","now","log","topics","listens","__updateTopicCB","Watcher","_List","Observer","arrayTarget","watchers","__watchers","__watcherProps","policy","__createProxy","__topics","prop0","__flags","observed","__getTopic","observedId","unobserve","unobserveId","watcher","getOriginal","origin","__watch","$get","$set","Proxy","__name","setter","orginal","changed","proxyPolicy","newValue","accessorPolicy","VBArray","execScript","vbPolicy","info","__getObserver","oserver","$eq","getObserver","_eachArray","_eachObj","doEach","defaultVal","eacharray","eachobj","doIdxOf","Cls","handler","doObjKeys","doMap","doReduce","listenId","doObjValues"],"mappings":"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"}