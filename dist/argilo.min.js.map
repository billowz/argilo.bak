{"version":3,"file":"argilo.min.js","sources":["/argilo/src/utility/consts.ts","/argilo/src/utility/constructor.ts","/argilo/src/utility/is.ts","/argilo/src/utility/fn.ts","/argilo/src/utility/reg.ts","/argilo/src/utility/prop/hasOwnProp.ts","/argilo/src/utility/proto/polyfill.ts","/argilo/src/utility/prop/polyfill.ts","/argilo/src/utility/create/polyfill.ts","/argilo/src/utility/collection/Control.ts","/argilo/src/utility/collection/each.ts","/argilo/src/utility/collection/map.ts","/argilo/src/utility/collection/idxOf.ts","/argilo/src/utility/collection/reduce.ts","/argilo/src/utility/collection/obj2arr.ts","/argilo/src/utility/collection/arr2obj.ts","/argilo/src/utility/collection/index.ts","/argilo/src/utility/propPath.ts","/argilo/src/utility/string.ts","/argilo/src/utility/format.ts","/argilo/src/utility/assign.ts","/argilo/src/utility/deepEq.ts","/argilo/src/utility/assert.ts","/argilo/src/utility/List/List.ts","/argilo/src/utility/List/FnList.ts","/argilo/src/utility/nextTick.ts","/argilo/src/utility/Source.ts","/argilo/src/utility/AST/util.ts","/argilo/src/utility/mixin.ts","/argilo/src/utility/AST/Rule.ts","/argilo/src/utility/AST/MatchRule.ts","/argilo/src/utility/AST/CharMatchRule.ts","/argilo/src/utility/AST/RegMatchRule.ts","/argilo/src/utility/AST/StringMatchRule.ts","/argilo/src/utility/AST/MatchContext.ts","/argilo/src/utility/AST/ComplexRule.ts","/argilo/src/utility/AST/AndRule.ts","/argilo/src/utility/AST/OrRule.ts","/argilo/src/utility/AST/api.ts","/argilo/src/observer/Observer.ts","/argilo/src/utility/prop/index.ts"],"sourcesContent":["/**\n *\n * @author Tao Zeng (tao.zeng.zt@qq.com)\n * @module utility\n * @created 2018-11-09 15:23:35\n * @modified 2018-11-09 15:23:35 by Tao Zeng (tao.zeng.zt@qq.com)\n */\n\nexport const CONSTRUCTOR = 'constructor'\n\nexport const PROTOTYPE = 'prototype'\n\nexport const PROTO = '__proto__'\n\nexport const HAS_OWN_PROP = 'hasOwnProperty'\n\nexport const TYPE_BOOL = 'boolean'\n\nexport const TYPE_FN = 'function'\n\nexport const TYPE_NUM = 'number'\n\nexport const TYPE_STRING = 'string'\n\nexport const TYPE_UNDEF = 'undefined'\n\nexport const GLOBAL: any =\n\ttypeof window !== TYPE_UNDEF\n\t\t? window\n\t\t: typeof global !== TYPE_UNDEF\n\t\t? global\n\t\t: typeof self !== TYPE_UNDEF\n\t\t? self\n\t\t: {}\n\nexport interface ObjArray {\n\tlength: number\n}\nexport type IArray = any[] | string | IArguments | ObjArray\n\nexport function EMPTY_FN() {}\n","/**\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Sat Feb 16 2019 10:53:30 GMT+0800 (China Standard Time)\n */\n\nimport { TYPE_FN, CONSTRUCTOR } from './consts'\n\nexport function getConstructor(o: any) {\n\tlet C = o[CONSTRUCTOR]\n\treturn typeof C === TYPE_FN ? C : Object\n}\n","/**\n * type checker\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Mon Feb 25 2019 16:59:04 GMT+0800 (China Standard Time)\n */\n\nimport { CONSTRUCTOR, GLOBAL, TYPE_BOOL, TYPE_FN, TYPE_NUM, TYPE_STRING, TYPE_UNDEF } from './consts'\nimport { getConstructor } from './constructor'\n\n/**\n * is equals\n * > o1 === o2 || NaN === NaN\n */\nexport function eq(o1: any, o2: any): boolean {\n\treturn o1 === o2 || (o1 !== o1 && o2 !== o2)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    primitive type                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * is null\n */\nexport function isNull(o: any): boolean {\n\treturn o === null\n}\n\n/**\n * is undefined\n */\nexport function isUndef(o: any): boolean {\n\treturn o === undefined\n}\n\n/**\n * is null or undefined\n */\nexport function isNil(o: any): boolean {\n\treturn o === null || o === undefined\n}\n\n/**\n * is boolean\n */\nexport const isBool: (o: any) => boolean = mkIsPrimitive(TYPE_BOOL)\n\n/**\n * is a number\n */\nexport const isNum: (o: any) => boolean = mkIsPrimitive(TYPE_NUM)\n\n/**\n * is a string\n */\nexport const isStr: (o: any) => boolean = mkIsPrimitive(TYPE_STRING)\n\n/**\n * is a function\n */\nexport const isFn: (o: any) => boolean = mkIsPrimitive(TYPE_FN)\n\n/**\n * is integer number\n */\nexport function isInt(o: any): boolean {\n\treturn o === 0 || (o ? typeof o === TYPE_NUM && o % 1 === 0 : false)\n}\n\n/**\n * is primitive type\n * - null\n * - undefined\n * - boolean\n * - number\n * - string\n * - function\n */\nexport function isPrimitive(o: any): boolean {\n\tif (o === undefined || o === null) {\n\t\treturn true\n\t}\n\tswitch (typeof o) {\n\t\tcase TYPE_BOOL:\n\t\tcase TYPE_NUM:\n\t\tcase TYPE_STRING:\n\t\tcase TYPE_FN:\n\t\t\treturn true\n\t}\n\treturn false\n}\n\nfunction mkIsPrimitive(type: string): (o: any) => boolean {\n\treturn function is(o: any): boolean {\n\t\treturn typeof o === type\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    reference type                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * is instanceof\n */\nexport function instOf(obj: any, Cls: Function): boolean {\n\treturn obj !== undefined && obj !== null && obj instanceof Cls\n}\n\n/**\n * is child instance of Type\n */\nexport function is(o: any, Type: Function | Function[]): boolean {\n\tif (o !== undefined && o !== null) {\n\t\tconst C = o[CONSTRUCTOR] || Object\n\t\tif (Type[CONSTRUCTOR] === Array) {\n\t\t\tvar i = Type.length\n\t\t\twhile (i--) {\n\t\t\t\tif (C === (Type as Function[])[i]) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn C === Type\n\t\t}\n\t}\n\treturn false\n}\n\n/**\n * is boolean or Boolean\n */\nexport const isBoolean: (o: any) => boolean = mkIs(Boolean)\n\n/**\n * is number or Number\n */\nexport const isNumber: (o: any) => boolean = mkIs(Number)\n\n/**\n * is string or String\n */\nexport const isString: (o: any) => boolean = mkIs(String)\n\n/**\n * is Date\n */\nexport const isDate: (o: any) => boolean = mkIs(Date)\n\n/**\n * is RegExp\n */\nexport const isReg: (o: any) => boolean = mkIs(RegExp)\n\n/**\n * is Array\n */\nexport const isArray: (o: any) => boolean = Array.isArray || mkIs(Array)\n\n/**\n * is Typed Array\n */\nexport const isTypedArray: (o: any) => boolean = isFn(ArrayBuffer) ? ArrayBuffer.isView : () => false\n\n/**\n * is Array or pseudo-array\n * - Array\n * - String\n * - IArguments\n * - NodeList\n * - HTMLCollection\n * - Typed Array\n * - {length: int, [length-1]: any}\n */\nexport function isArrayLike(o: any): boolean {\n\tif (o && o[CONSTRUCTOR]) {\n\t\tswitch (o[CONSTRUCTOR]) {\n\t\t\tcase Array:\n\t\t\tcase String:\n\t\t\tcase GLOBAL.NodeList:\n\t\t\tcase GLOBAL.HTMLCollection:\n\t\t\tcase GLOBAL.Int8Array:\n\t\t\tcase GLOBAL.Uint8Array:\n\t\t\tcase GLOBAL.Int16Array:\n\t\t\tcase GLOBAL.Uint16Array:\n\t\t\tcase GLOBAL.Int32Array:\n\t\t\tcase GLOBAL.Uint32Array:\n\t\t\tcase GLOBAL.Float32Array:\n\t\t\tcase GLOBAL.Float64Array:\n\t\t\t\treturn true\n\t\t}\n\t\tconst len = o.length\n\t\treturn typeof len === TYPE_NUM && (len === 0 || (len > 0 && len % 1 === 0 && len - 1 in o))\n\t}\n\treturn o === ''\n}\n\n/**\n * is simple Object\n * TODO object may has constructor property\n */\nexport function isObj(o: any): boolean {\n\treturn o !== undefined && o !== null && getConstructor(o) === Object\n}\n\nfunction mkIs(Type: Function): (o: any) => boolean {\n\treturn function is(o: any): boolean {\n\t\treturn o !== undefined && o !== null && o[CONSTRUCTOR] === Type\n\t}\n}\n\nconst blankStrReg = /^\\s*$/\n/**\n * is empty\n * - string: trim(string).length === 0\n * - array: array.length === 0\n * - pseudo-array: pseudo-array.length === 0\n */\nexport function isBlank(o: any): boolean {\n\tif (o) {\n\t\tif (o[CONSTRUCTOR] === String) {\n\t\t\treturn blankStrReg.test(o)\n\t\t}\n\t\treturn o.length === 0\n\t}\n\treturn true\n}\n","/**\n * Function utilities\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Fri Nov 23 2018 11:18:33 GMT+0800 (China Standard Time)\n */\n\nimport { GLOBAL, PROTOTYPE } from './consts'\nimport { isNil } from './is'\n\n// ========================================================================================\n/*                                                                                      *\n *                                    create function                                   *\n *                                                                                      */\n// ========================================================================================\n\n/**\n * create function by code string\n * @param body\tfunction body\n * @param args\tfunction argument names\n * @param name\tfunction name\n */\nexport function createFn<T extends Function>(body: string, args?: string[], name?: string): T {\n\treturn name\n\t\t? Function(`return function ${name}(${args ? args.join(', ') : ''}){${body}}`)()\n\t\t: applyScope(Function, Function, args && args.length ? args.concat(body) : [body])\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                    function apply                                    *\n *                                                                                      */\n// ========================================================================================\n\n/**\n * generate apply function\n */\nfunction applyBuilder<T extends Function>(maxArgs: number, scope: any, offset: any): T {\n\tscope = scope ? 'scope' : ''\n\toffset = offset ? 'offset' : ''\n\tconst args = new Array(maxArgs + 1)\n\tconst cases = new Array(maxArgs + 1)\n\tfor (let i = 0; i <= maxArgs; i++) {\n\t\targs[i] = `${i || scope ? ', ' : ''}args[${offset ? `offset${i ? ' + ' + i : ''}` : i}]`\n\t\tcases[i] = `case ${i}: return fn${scope && '.call'}(${scope}${args.slice(0, i).join('')});`\n\t}\n\treturn Function(`return function(fn, ${scope && scope + ', '}args${offset && ', offset, len'}){\nswitch(${offset ? 'len' : 'args.length'}){\n${cases.join('\\n')}\n}\n${offset &&\n\t\t`var arr = new Array(len);\nfor(var i=0; i<len; i++) arr[i] = arr[offset + i];`}\nreturn fn.apply(${scope || 'null'}, ${offset ? 'arr' : 'args'});\n}`)()\n}\n\n/**\n * apply function with scope\n * @param fn\ttarget function\n * @param scope\tscope of function\n * @param args\targuments of function\n */\nexport const applyScope: (fn: Function, scope: any, args: any[] | IArguments) => any = applyBuilder(8, 1, 0)\n\n/**\n * apply function without scope\n * @param fn\t\ttarget function\n * @param args\targuments of function\n */\nexport const applyNoScope: (fn: Function, args: any[] | IArguments) => any = applyBuilder(8, 0, 0)\n\n/**\n * apply function with scope\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport const applyScopeN: (\n\tfn: Function,\n\tscope: any,\n\targs: any[] | IArguments,\n\toffset: number,\n\tlen: number\n) => any = applyBuilder(8, 1, 1)\n\n/**\n * apply function without scope\n * @param fn\t\ttarget function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport const applyNoScopeN: (fn: Function, args: any[] | IArguments, offset: number, len: number) => any = applyBuilder(\n\t8,\n\t0,\n\t1\n)\n\n/**\n * apply function\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n */\nexport function apply(fn: Function, scope: any, args: any[] | IArguments): any {\n\tif (scope === undefined || scope === null || scope === GLOBAL) {\n\t\treturn applyNoScope(fn, args || [])\n\t}\n\treturn applyScope(fn, scope, args || [])\n}\n\n/**\n * apply function\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport function applyN(fn: Function, scope: any, args: any[] | IArguments, offset: number, len: number): any {\n\tif (scope === undefined || scope === null || scope === GLOBAL) {\n\t\treturn applyNoScopeN(fn, args, offset, len)\n\t}\n\treturn applyScopeN(fn, scope, args, offset, len)\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                     function name                                    *\n *                                                                                      */\n// ========================================================================================\n\nconst varGenReg = /\\$\\d+$/\n\n/**\n * get function name\n */\nexport function fnName(fn: Function): string {\n\tconst name: string = (fn as any).name\n\treturn name ? name.replace(varGenReg, '') : 'anonymous'\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                         bind                                         *\n *                                                                                      */\n// ========================================================================================\n\nlet _bind\nconst funcProto = Function[PROTOTYPE]\nif (funcProto.bind) {\n\t_bind = function bind<T extends Function>(fn: T, scope: any): T {\n\t\tconst args = arguments,\n\t\t\targLen = args.length\n\t\tif (isNil(scope)) {\n\t\t\treturn argLen > 2 ? bindPolyfill(fn, scope, args, 2) : fn\n\t\t}\n\t\treturn applyScopeN(fn.bind, fn, args, 1, argLen - 1)\n\t}\n} else {\n\tfuncProto.bind = function bind(scope) {\n\t\treturn bindPolyfill(this, scope, arguments, 1)\n\t}\n\t_bind = function bind<T extends Function>(fn: T, scope: any): T {\n\t\treturn bindPolyfill(fn, scope, arguments, 2)\n\t}\n}\n\n/**\n * bind scope or arguments on function\n * - return source function when without arguments and scope is undefined or null\n * - only bind arguments when scope is undefined or null, well can call the new function proxy with some scope\n *\n * @example\n * \t\tfunction example() {\n * \t\t\tconsole.log(this, arguments);\n * \t\t}\n * \t\tvar proxy = bind(example, null) \t// proxy === example\n * \t\tproxy() \t\t\t\t\t\t\t// log: window | undefined, []\n * \t\tproxy.call(1) \t\t\t\t\t\t// log: 1, []\n *\n * \t\tproxy = bind(example, null, 1) \t\t// proxy !== example\n * \t\tproxy() \t\t\t\t\t\t\t// log: window | undefined, [1]\n * \t\tproxy(2) \t\t\t\t\t\t\t// log: window | undefined, [1, 2]\n * \t\tproxy.call(1, 2) \t\t\t\t\t// log: 1, [1, 2]\n *\n * \t\tproxy = bind(example, {}, 1, 2)\t\t// proxy !== example\n * \t\tproxy() \t\t\t\t\t\t\t// log: {}, [1]\n * \t\tproxy(2) \t\t\t\t\t\t\t// log: {}, [1, 2, 2]\n * \t\tproxy.call(1, 2) \t\t\t\t\t// log: {}, [1, 2, 2]\n *\n * @param fn\tsource function\n * @param scope\tbind scope\n * @param args\tbind arguments\n * @return function proxy\n */\nexport const bind: <T extends Function>(fn: T, scope: any, ...args: any[]) => T = _bind\n\n/**\n * bind\n * > not bind scope when scope is null or undefined\n * @param fn\t\tsource function\n * @param scope\t\tbind scope\n * @param args\t\tbind arguments\n * @param argOffset\toffset of args\n * @return function proxy\n */\nfunction bindPolyfill<T extends Function>(fn: T, scope: any, bindArgs: any[] | IArguments, argOffset: number): T {\n\tconst argLen = bindArgs.length - argOffset\n\tif (scope === undefined) {\n\t\tscope = null\n\t}\n\tif (argLen > 0) {\n\t\t// bind with arguments\n\t\treturn function bindProxy() {\n\t\t\tconst args = arguments\n\t\t\tlet i = args.length\n\t\t\tif (i) {\n\t\t\t\tconst params = new Array(argLen + i)\n\t\t\t\twhile (i--) {\n\t\t\t\t\tparams[argLen + i] = args[i]\n\t\t\t\t}\n\t\t\t\ti = argLen\n\t\t\t\twhile (i--) {\n\t\t\t\t\tparams[i] = bindArgs[i + argOffset]\n\t\t\t\t}\n\t\t\t\treturn apply(fn, scope === null ? this : scope, params) // call with scope or this\n\t\t\t}\n\t\t\treturn applyN(fn, scope === null ? this : scope, bindArgs, argOffset, argLen) // call with scope or this\n\t\t} as any\n\t}\n\tif (scope === null) {\n\t\treturn fn\n\t}\n\tif (scope === GLOBAL) {\n\t\t// bind on GLOBAL\n\t\treturn function bindProxy() {\n\t\t\treturn applyNoScope(fn, arguments)\n\t\t} as any\n\t}\n\treturn function bindProxy() {\n\t\treturn applyScope(fn, scope, arguments)\n\t} as any\n}\n","/**\n * regexp utilities\n * @module utility/reg\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Sep 06 2018 18:27:51 GMT+0800 (China Standard Time)\n * @modified Sat Dec 29 2018 19:29:00 GMT+0800 (China Standard Time)\n */\n\nimport { isBool } from './is'\n\n/**\n * whether to support sticky on RegExp\n */\nexport const stickyReg = isBool(/(?:)/.sticky)\n\n/**\n * whether to support unicode on RegExp\n */\nexport const unicodeReg = isBool(/(?:)/.unicode)\n\nconst REG_ESCAPE = /[-\\/\\\\^$*+?.()|[\\]{}]/g\n\n/**\n * escape string for RegExp\n */\nexport function reEscape(str: string): string {\n\treturn str.replace(REG_ESCAPE, '\\\\$&')\n}\n","/**\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:22:57 GMT+0800 (China Standard Time)\n * @modified Sat Dec 29 2018 18:35:40 GMT+0800 (China Standard Time)\n */\n\nimport { PROTOTYPE, HAS_OWN_PROP } from '../consts'\n\nconst __hasOwn = Object[PROTOTYPE][HAS_OWN_PROP]\n\n/**\n * has own property\n */\nexport function hasOwnProp(obj: any, prop: string): boolean {\n\treturn __hasOwn.call(obj, prop)\n}\n","/**\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:23:56 GMT+0800 (China Standard Time)\n * @modified Thu Jan 31 2019 10:10:28 GMT+0800 (China Standard Time)\n */\nimport { CONSTRUCTOR, PROTO, PROTOTYPE } from '../consts'\nimport { hasOwnProp } from '../prop/hasOwnProp'\n\nconst __getProto = Object.getPrototypeOf,\n\t____setProto = Object.setPrototypeOf\n\n/**\n * whether to support Object.getPrototypeOf and Object.setPrototypeOf\n */\nexport const prototypeOf = !!____setProto\n\n/**\n * whether to support `__proto__`\n */\nexport const protoProp = { __proto__: [] } instanceof Array\n\n/**\n * get prototype\n */\nexport const protoOf: (o: any) => any = ____setProto\n\t? __getProto\n\t: __getProto\n\t? function getPrototypeOf(obj) {\n\t\t\treturn obj[PROTO] || __getProto(obj)\n\t  }\n\t: function getPrototypeOf(obj) {\n\t\t\treturn (hasOwnProp(obj, PROTO) ? obj[PROTO] : obj[CONSTRUCTOR][PROTOTYPE]) || null\n\t  }\n\n/**\n * set prototype\n * > properties on the prototype are not inherited on older browsers\n */\nexport const __setProto: <T>(obj: any, proto: any) => any =\n\t____setProto ||\n\tfunction setPrototypeOf(obj, proto) {\n\t\tobj[PROTO] = proto\n\t\treturn obj\n\t}\n\n/**\n * set prototype\n * > the properties on the prototype will be copied on the older browser\n */\nexport const setProto: <T>(obj: any, proto: any) => any =\n\t____setProto ||\n\t(protoProp\n\t\t? __setProto\n\t\t: function setPrototypeOf(obj, proto) {\n\t\t\t\tfor (let p in proto) {\n\t\t\t\t\tif (hasOwnProp(proto, p)) obj[p] = proto[p]\n\t\t\t\t}\n\t\t\t\treturn __setProto(obj, proto)\n\t\t  })\n","/**\n * prop utilities\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:22:57 GMT+0800 (China Standard Time)\n * @modified Sat Dec 29 2018 18:57:40 GMT+0800 (China Standard Time)\n */\nimport { PROTO, PROTOTYPE, HAS_OWN_PROP } from '../consts'\nimport { protoProp } from '../proto'\nimport { hasOwnProp as __hasOwnProp } from './hasOwnProp'\n\n//========================================================================================\n/*                                                                                      *\n *                                     own property                                     *\n *                                                                                      */\n//========================================================================================\n\n/**\n * has own property\n */\nexport const hasOwnProp: (obj: any, prop: string) => boolean = protoProp\n\t? __hasOwnProp\n\t: function hasOwnProp(obj, prop) {\n\t\t\treturn prop !== PROTO && __hasOwnProp(obj, prop)\n\t  }\n\n//========================================================================================\n/*                                                                                      *\n *                                    define property                                   *\n *                                                                                      */\n//========================================================================================\n\nlet __defProp: (o: any, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>) => any = Object.defineProperty\n\nconst { __defineGetter__, __defineSetter__ } = Object[PROTOTYPE] as any\n/**\n * whether to support Object.defineProperty\n */\nexport const propDescriptor: boolean =\n\t__defProp &&\n\t!!(function() {\n\t\ttry {\n\t\t\tvar val: number,\n\t\t\t\tobj: { s?: number } = {}\n\t\t\t__defProp(obj, 's', {\n\t\t\t\tget() {\n\t\t\t\t\treturn val\n\t\t\t\t},\n\t\t\t\tset(value) {\n\t\t\t\t\tval = value\n\t\t\t\t}\n\t\t\t})\n\t\t\tobj.s = 1\n\t\t\treturn obj.s === val\n\t\t} catch (e) {}\n\t})()\n\n/**\n * whether to support `__defineGetter__` and `__defineSetter__`\n */\nexport const propAccessor: boolean = propDescriptor || !!__defineSetter__\n\nif (!propDescriptor)\n\t__defProp = __defineSetter__\n\t\t? function defineProperty(obj, prop, desc) {\n\t\t\t\tconst { get, set } = desc\n\t\t\t\tif ('value' in desc || !(prop in obj)) obj[prop] = desc.value\n\t\t\t\tif (get) __defineGetter__.call(obj, prop, get)\n\t\t\t\tif (set) __defineSetter__.call(obj, prop, set)\n\t\t\t\treturn obj\n\t\t  }\n\t\t: function defineProperty(obj, prop, desc) {\n\t\t\t\tif (desc.get || desc.set)\n\t\t\t\t\tthrow new TypeError('Invalid property descriptor. Accessor descriptors are not supported.')\n\t\t\t\tif ('value' in desc || !(prop in obj)) obj[prop] = desc.value\n\t\t\t\treturn obj\n\t\t  }\n\n/**\n * define property\n */\nexport const defProp = __defProp\n\n/**\n * define property by value\n */\nexport const defPropValue: <V>(\n\tobj: any,\n\tprop: string,\n\tvalue: V,\n\tenumerable?: boolean,\n\tconfigurable?: boolean,\n\twritable?: boolean\n) => V = propDescriptor\n\t? function defPropValue(obj, prop, value, configurable, writable, enumerable) {\n\t\t\t__defProp(obj, prop, {\n\t\t\t\tvalue,\n\t\t\t\tenumerable: enumerable !== false,\n\t\t\t\tconfigurable: configurable !== false,\n\t\t\t\twritable: writable !== false\n\t\t\t})\n\t\t\treturn value\n\t  }\n\t: function defPropValue(obj, prop, value) {\n\t\t\tobj[prop] = value\n\t\t\treturn value\n\t  }\n","/**\n * Object.create polyfill\n * @module utility/create\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:24:47 GMT+0800 (China Standard Time)\n * @modified Sat Dec 29 2018 18:19:24 GMT+0800 (China Standard Time)\n */\n\nimport { PROTOTYPE } from '../consts'\nimport { defProp, hasOwnProp } from '../prop'\nimport { __setProto } from '../proto'\n\nfunction __() {}\n\n/**\n * create shim\n */\nfunction doCreate(o: object | null, props?: PropertyDescriptorMap & ThisType<any>): any {\n\t__[PROTOTYPE] = o\n\tconst obj = new __()\n\t__[PROTOTYPE] = null\n\tif (props) {\n\t\tfor (var k in props) {\n\t\t\tif (hasOwnProp(props, k)) {\n\t\t\t\tdefProp(obj, k, props[k])\n\t\t\t}\n\t\t}\n\t}\n\treturn obj\n}\n\n/**\n * create object\n */\nexport const create =\n\tObject.create ||\n\t(Object.create = Object.getPrototypeOf\n\t\t? doCreate\n\t\t: function create(o: object | null, props?: PropertyDescriptorMap & ThisType<any>): any {\n\t\t\t\tconst obj = doCreate(o, props)\n\t\t\t\t__setProto(obj, o)\n\t\t\t\treturn obj\n\t\t  })\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:10:41 GMT+0800 (China Standard Time)\n * @modified Sat Dec 29 2018 19:37:44 GMT+0800 (China Standard Time)\n */\nexport class Control {\n\tprivate __desc: string\n\n\tconstructor(desc: string) {\n\t\tthis.__desc = desc\n\t}\n\n\ttoString() {\n\t\treturn this.__desc\n\t}\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:10:41 GMT+0800 (China Standard Time)\n * @modified Sat Dec 29 2018 19:34:51 GMT+0800 (China Standard Time)\n */\nimport { Control } from './Control'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { hasOwnProp } from '../prop'\nimport { isArrayLike, isBool } from '../is'\n\n/**\n * STOP Control\n * > stop each/map/indexOf...\n */\nexport const STOP = new Control('STOP')\n//========================================================================================\n/*                                                                                      *\n *                                each object properties                                *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on object\n * - will stop each on return STOP\n */\nexport type EachPropCallback = (prop: string, obj: object) => Control | void\n\n/**\n * each properties\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties, default: true\n * @return stoped property name or false\n */\nexport function eachProps(obj: object, callback: EachPropCallback, own: boolean): false | string\nexport function eachProps(obj: object, callback: EachPropCallback, scope?: any, own?: boolean): false | string\nexport function eachProps(obj: object, callback: EachPropCallback, scope?: any, own?: boolean): false | string {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tlet k: string\n\tif (own === false) {\n\t\tfor (k in obj) if (callback(k, obj) === STOP) return k\n\t} else {\n\t\tfor (k in obj) if (hasOwnProp(obj, k) && callback(k, obj) === STOP) return k\n\t}\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      each object                                     *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on object\n * - will stop each on callback return STOP\n */\nexport type EachObjCallback = (value: any, prop: string, obj: object) => Control | void\n\n/**\n * each object\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties, default: true\n * @return stoped property name or false\n */\nexport function eachObj(obj: object, callback: EachObjCallback, own: boolean): false | string\nexport function eachObj(obj: object, callback: EachObjCallback, scope?: any, own?: boolean): false | string\nexport function eachObj(obj: object, callback: EachObjCallback, scope?: any, own?: boolean): false | string {\n\tconst args = arguments\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tlet k: string\n\tif (own === false) {\n\t\tfor (k in obj) if (callback(obj[k], k, obj) === STOP) return k\n\t} else {\n\t\tfor (k in obj) if (hasOwnProp(obj, k) && callback(obj[k], k, obj) === STOP) return k\n\t}\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      each array                                      *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on array\n * - will stop each on callback return STOP\n */\nexport type EachArrayCallback = (data: any, index: number, array: IArray) => Control | void\n\n/**\n * each array\n * - will stop each on callback return STOP\n * @param array\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @return stoped index or false\n */\nexport function eachArray(array: IArray, callback: EachArrayCallback, scope?: any): false | number {\n\tcallback = bind(callback, scope)\n\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\tif (callback(array[i], i, array) === STOP) return i\n\t}\n\treturn false\n}\n\n/**\n * reverse each array\n * - will stop each on callback return STOP\n * @param array\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @return stoped index or false\n */\nexport function reachArray(array: IArray, callback: EachArrayCallback, scope?: any): false | number {\n\tcallback = bind(callback, scope)\n\tlet i = array.length\n\twhile (i--) if (callback(array[i], i, array) === STOP) return i\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         each                                         *\n *                                                                                      */\n//========================================================================================\n\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: IArray,\n\tcallback: EachArrayCallback,\n\tscope?: any\n): false | number\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object,\n\tcallback: EachObjCallback,\n\town?: boolean\n): false | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object,\n\tcallback: EachObjCallback,\n\tscope?: any,\n\town?: boolean\n): false | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\town?: boolean\n): false | number | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\tscope?: any,\n\town?: boolean\n): false | number | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: any,\n\tcallback: any,\n\tscope?: any,\n\town?: boolean\n): false | number | string {\n\tif (isArrayLike(obj)) return _eachArray(obj, callback, scope)\n\treturn _eachObj(obj, callback, scope, own)\n}\n\n/**\n * each\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties on object, default: true\n * @return stoped index or false\n */\n\nexport function each(obj: IArray, callback: EachArrayCallback, scope?: any): false | number\nexport function each(obj: object, callback: EachObjCallback, own?: boolean): false | string\nexport function each(obj: object, callback: EachObjCallback, scope?: any, own?: boolean): false | string\nexport function each(\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\town?: boolean\n): false | number | string\nexport function each(\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\tscope?: any,\n\town?: boolean\n): false | number | string\nexport function each(obj: any, callback: any, scope?: any, own?: boolean): false | number | string {\n\treturn doEach(eachArray, eachObj, obj, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Sat Dec 29 2018 19:37:30 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './Control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport { create } from '../create'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool } from '../is'\n\n/**\n * SKIP Control\n * > skip map\n */\nexport const SKIP = new Control('SKIP')\n\n//========================================================================================\n/*                                                                                      *\n *                                    map object                                   *\n *                                                                                      */\n//========================================================================================\n\n/**\n * callback on object\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param value\tproperty value\n * @param prop\tproperty name\n * @param obj\tmap target\n */\nexport type MapObjCallback<T> = (callback: any, prop: string, obj: object) => T | Control\n\nexport function doMapObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\town?: boolean\n): { [key: string]: T }\nexport function doMapObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T }\nexport function doMapObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tconst copy: { [key: string]: T } = create(null)\n\teach(\n\t\tobj,\n\t\t(value, prop, obj) => {\n\t\t\tconst v = callback(value, prop, obj)\n\t\t\tif (v === STOP) return STOP\n\t\t\tif (v !== SKIP) copy[prop] = v as T\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn copy\n}\n\n/**\n * object: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param obj\t\tmap target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\tmap own properties, default: true\n */\nexport function mapObj<T>(obj: object, callback: MapObjCallback<T>, own?: boolean): { [key: string]: T }\nexport function mapObj<T>(obj: object, callback: MapObjCallback<T>, scope?: any, own?: boolean): { [key: string]: T }\nexport function mapObj<T>(obj: object, callback: MapObjCallback<T>, scope?: any, own?: boolean): { [key: string]: T } {\n\treturn doMapObj(eachObj, obj, callback, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     indexof Array                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * callback on array\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param data\titem data\n * @param index\titem index\n * @param array\tmap target\n */\nexport type MapArrayCallback<T> = (data: any, index: number, array: IArray) => T | Control\n\nexport function doMapArray<T>(each: typeof eachArray, array: IArray, callback: MapArrayCallback<T>, scope?: any): T[] {\n\tcallback = bind(callback, scope)\n\tconst copy: T[] = []\n\tlet j = 0\n\teach(array, (data, index, array) => {\n\t\tconst v = callback(data, index, array)\n\t\tif (v === STOP) return STOP\n\t\tif (v !== SKIP) copy[j++] = v as T\n\t})\n\treturn copy\n}\n\n/**\n * array: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param array\t\tmap target\n * @param value\t\tcallback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function mapArray<T>(array: IArray, callback: MapArrayCallback<T>, scope?: any): T[] {\n\treturn doMapArray(eachArray, array, callback, scope)\n}\n\n/**\n * revice array: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param array\t\tmap target\n * @param value\t\tmap value of callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function rmapArray<T>(array: IArray, callback: MapArrayCallback<T>, scope?: any): T[] {\n\treturn doMapArray(reachArray, array, callback, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       map                                       *\n *                                                                                      */\n//========================================================================================\n\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray,\n\tcallback: MapArrayCallback<T>,\n\tscope?: any\n): any[]\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\town?: boolean\n): { [key: string]: T }\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T }\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: any,\n\tcallback: any,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | any[] {\n\tif (isArrayLike(obj)) return doMapArray(eacharray, obj, callback, scope)\n\treturn doMapObj(eachobj, obj, callback, scope, own)\n}\n\n/**\n * map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param obj\t\tmap target\n * @param value\t\tmap value of callback\n * @param scope\t\tscope of callback\n * @param own\t\tmap own properties on object, default: true\n * @return array index or property name or -1\n */\nexport function map<T>(obj: IArray, callback: MapArrayCallback<T>, scope?: any): any[]\nexport function map<T>(obj: object, callback: MapObjCallback<T>, own?: boolean): { [key: string]: T }\nexport function map<T>(obj: object, callback: MapObjCallback<T>, scope?: any, own?: boolean): { [key: string]: T }\nexport function map<T>(\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function map<T>(\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function map<T>(obj: object | IArray, callback: any, scope?: any, own?: boolean): { [key: string]: T } | T[] {\n\treturn doMap(eachArray, eachObj, obj, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:38:16 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './Control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool, isFn, eq } from '../is'\n\nfunction parseCallback(value: any, scope: any) {\n\tif (isFn(value)) return bind(value, scope)\n\treturn function defaultHandler(data, idx, obj) {\n\t\treturn eq(data, value)\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    index of object                                   *\n *                                                                                      */\n//========================================================================================\n\n/**\n * indexOf callback on object\n * - will stop find on callback return STOP\n * @param value\tproperty value\n * @param prop\tproperty name\n * @param obj\t\tindexOf target\n * @return\n * - boolean: is finded\n * - void: find next\n * - STOP: stop find\n */\nexport type IdxOfObjCallback = (value: any, prop: string, obj: object) => boolean | Control | void\n\nexport function doIdxOfObj(each: typeof eachObj, obj: object, value: any, own?: boolean): -1 | string\nexport function doIdxOfObj(each: typeof eachObj, obj: object, value: IdxOfObjCallback, own?: boolean): -1 | string\nexport function doIdxOfObj(\n\teach: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback,\n\tscope?: any,\n\town?: boolean\n): -1 | string\n\nexport function doIdxOfObj(\n\teach: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback | any,\n\tscope?: any,\n\town?: boolean\n): -1 | string {\n\tif (isBool(scope)) {\n\t\town = scope\n\t\tscope = null\n\t}\n\tconst callback: IdxOfObjCallback = parseCallback(value, scope)\n\tlet idx: -1 | string = -1\n\teach(\n\t\tobj,\n\t\t(data, prop, obj) => {\n\t\t\tconst r = callback(data, prop, obj)\n\t\t\tif (r === true) {\n\t\t\t\tidx = prop\n\t\t\t\treturn STOP\n\t\t\t} else if (r === STOP) return r\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn idx\n}\n\n/**\n * object: indexOf\n * - will stop find on callback return STOP\n * @param obj\t\tfind target\n * @param callback\tfind value or callback\n * @param scope\t\tscope of callback\n * @param own\t\tfind own properties, default: true\n * @return property name or -1\n */\nexport function idxOfObj(obj: object, value: any, own?: boolean): -1 | string\nexport function idxOfObj(obj: object, value: IdxOfObjCallback, own?: boolean): -1 | string\nexport function idxOfObj(obj: object, value: IdxOfObjCallback, scope?: any, own?: boolean): -1 | string\nexport function idxOfObj(obj: object, value: IdxOfObjCallback | any, scope?: any, own?: boolean): -1 | string {\n\treturn doIdxOfObj(eachObj, obj, value, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     indexof Array                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * indexOf callback on array\n * - will stop find on callback return STOP\n * @param data\titem data\n * @param index\titem index\n * @param array\tindexOf target\n * @return\n * - boolean: is finded\n * - void: find next\n * - STOP: stop find\n */\nexport type IdxOfArrayCallback = (data: any, index: number, array: IArray) => boolean | Control | void\n\nexport function doIdxOfArray(each: typeof eachArray, array: IArray, value: any): number\nexport function doIdxOfArray(each: typeof eachArray, array: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function doIdxOfArray(\n\teach: typeof eachArray,\n\tarray: IArray,\n\tvalue: IdxOfArrayCallback | any,\n\tscope?: any\n): number {\n\tconst callback: IdxOfArrayCallback = parseCallback(value, scope)\n\tlet idx = -1\n\teach(array, (data, index, array) => {\n\t\tconst r = callback(data, index, array)\n\t\tif (r === true) {\n\t\t\tidx = index\n\t\t\treturn STOP\n\t\t} else if (r === STOP) return r\n\t})\n\treturn idx\n}\n\n/**\n * array: indexOf\n * - will stop find on callback return STOP\n * @param array\t\tfind target\n * @param value\t\tfind value or callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function idxOfArray(array: IArray, value: any): number\nexport function idxOfArray(array: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function idxOfArray(array: IArray, value: IdxOfArrayCallback | any, scope?: any): number {\n\treturn doIdxOfArray(eachArray, array, value, scope)\n}\n\n/**\n * revice array: indexOf\n * - will stop find on callback return STOP\n * @param array\t\tfind target\n * @param value\t\tfind value of callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function ridxOfArray(array: IArray, value: any): number\nexport function ridxOfArray(array: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function ridxOfArray(array: IArray, value: IdxOfArrayCallback | any, scope?: any): number {\n\treturn doIdxOfArray(reachArray, array, value, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       index of                                       *\n *                                                                                      */\n//========================================================================================\n// find by value\nexport function doIdxOf(eacharray: typeof eachArray, eachobj: typeof eachObj, obj: IArray, value: any): number\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tvalue: any,\n\town?: boolean\n): string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tvalue: any,\n\town?: boolean\n): number | string\n// find by callback\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray,\n\tvalue: IdxOfArrayCallback,\n\tscope?: any\n): number\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback,\n\town?: boolean\n): -1 | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback,\n\tscope?: any,\n\town?: boolean\n): -1 | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\town?: boolean\n): number | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\tscope?: any,\n\town?: boolean\n): number | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: any,\n\tvalue: any,\n\tscope?: any,\n\town?: boolean\n): number | string {\n\tif (isArrayLike(obj)) return doIdxOfArray(eacharray, obj, value, scope)\n\treturn doIdxOfObj(eachobj, obj, value, scope, own)\n}\n\n/**\n * indexOf\n * - will stop find on callback return STOP\n * @param obj\t\tfind target\n * @param value\t\tfind value of callback\n * @param scope\t\tscope of callback\n * @param own\t\tfind own properties on object, default: true\n * @return array index or property name or -1\n */\nexport function idxOf(obj: IArray, value: any): number | string\nexport function idxOf(obj: object, value: any, own?: boolean): number | string\nexport function idxOf(obj: object | IArray, value: any, own?: boolean): number | string\nexport function idxOf(obj: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function idxOf(obj: object, value: IdxOfObjCallback, own?: boolean): -1 | string\nexport function idxOf(obj: object, value: IdxOfObjCallback, scope?: any, own?: boolean): -1 | string\nexport function idxOf(\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\town?: boolean\n): number | string\nexport function idxOf(\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\tscope?: any,\n\town?: boolean\n): number | string\nexport function idxOf(obj: object | IArray, value: any, scope?: any, own?: boolean): number | string {\n\treturn doIdxOf(eachArray, eachObj, obj, value, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 14:02:39 GMT+0800 (China Standard Time)\n */\nimport { Control } from './Control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool } from '../is'\n\n//========================================================================================\n/*                                                                                      *\n *                                     reduce object                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * reduce callback on object\n * - will stop reduce on return STOP\n */\nexport type ReduceObjCallback<T> = (accumulator: T, value: any, prop: string, obj: object) => T | Control\n\nexport function doReduceObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\town?: boolean\n): T\nexport function doReduceObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduceObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\teach(\n\t\tobj,\n\t\t(value, prop, obj) => {\n\t\t\tconst rs = callback(accumulator, value, prop, obj)\n\t\t\tif (rs === STOP) return STOP\n\t\t\taccumulator = rs as T\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn accumulator\n}\n\n/**\n * reduce object\n * - will stop reduce on callback return STOP\n * @param obj\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n * @param own\t\t\treduce own properties, default: true\n */\nexport function reduceObj<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, own?: boolean)\nexport function reduceObj<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, scope?: any, own?: boolean)\nexport function reduceObj<T>(\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\treturn doReduceObj(eachObj, obj, accumulator, callback, scope, own)\n}\n//========================================================================================\n/*                                                                                      *\n *                                     reduce array                                     *\n *                                                                                      */\n//========================================================================================\n\n/**\n * reduce callback on array\n * - will stop reduce on return STOP\n */\nexport type ReduceArrayCallback<T> = (accumulator: T, data: any, index: number, array: IArray) => T | Control\n\nexport function doReduceArray<T>(\n\teach: typeof eachArray,\n\tarray: IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T>,\n\tscope?: any\n): T {\n\tcallback = bind(callback, scope)\n\teach(array, (data, index, array) => {\n\t\tconst rs = callback(accumulator, data, index, array)\n\t\tif (rs === STOP) return STOP\n\t\taccumulator = rs as T\n\t})\n\treturn accumulator\n}\n\n/**\n * reduce array\n * - will stop reduce on callback return STOP\n * @param array\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n */\nexport function reduceArray<T>(array: IArray, accumulator: T, callback: ReduceArrayCallback<T>, scope?: any): T {\n\treturn doReduceArray(eachArray, array, accumulator, callback, scope)\n}\n\n/**\n * revice reduce array\n * - will stop reduce on callback return STOP\n * @param array\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n */\nexport function rreduceArray<T>(array: IArray, accumulator: T, callback: ReduceArrayCallback<T>, scope?: any): T {\n\treturn doReduceArray(reachArray, array, accumulator, callback, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        reduce                                        *\n *                                                                                      */\n//========================================================================================\n\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T>,\n\tscope?: any\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T> | ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\tif (isArrayLike(obj))\n\t\treturn doReduceArray(eacharray, obj as IArray, accumulator, callback as ReduceArrayCallback<T>, scope)\n\treturn doReduceObj(eachobj, obj as object, accumulator, callback as ReduceObjCallback<T>, scope, own)\n}\n\n/**\n * reduce\n * - will stop reduce on callback return STOP\n * @param obj\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n * @param own\t\t\treduce own properties of reduce object, default: true\n */\nexport function reduce<T>(obj: IArray, accumulator: T, callback: ReduceArrayCallback<T>, scope?: any): T\nexport function reduce<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, own?: boolean): T\nexport function reduce<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, scope?: any, own?: boolean): T\nexport function reduce<T>(\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\town?: boolean\n): T\nexport function reduce<T>(\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function reduce<T>(\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T> | ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\treturn doReduce(eachArray, eachObj, obj, accumulator, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Jul 26 2018 10:47:47 GMT+0800 (China Standard Time)\n * @modified Sat Dec 29 2018 19:34:56 GMT+0800 (China Standard Time)\n */\nimport { Control } from './Control'\nimport { STOP, eachObj, eachProps } from './each'\nimport { SKIP } from './map'\nimport { isBool, isFn } from '../is'\nimport { bind } from '../fn'\n\n//========================================================================================\n/*                                                                                      *\n *                                         keys                                         *\n *                                                                                      */\n//========================================================================================\n\nexport type ObjKeyHandler<T> = (prop: string, obj: object) => T | Control\n\nfunction defaultObjKeyHandler(prop: string, obj: object): any {\n\treturn prop\n}\nexport function doObjKeys<T>(each: typeof eachProps, obj: object, own?: boolean): T[]\nexport function doObjKeys<T>(each: typeof eachProps, obj: object, callback: ObjKeyHandler<T>, own?: boolean): T[]\nexport function doObjKeys<T>(\n\teach: typeof eachProps,\n\tobj: object,\n\tcallback: ObjKeyHandler<T>,\n\tscope?: any,\n\town?: boolean\n): T[]\nexport function doObjKeys<T>(\n\teach: typeof eachProps,\n\tobj: object,\n\tcallback_own?: ObjKeyHandler<T> | boolean,\n\tscope_own?: any,\n\town?: boolean\n): T[]\nexport function doObjKeys<T>(each: typeof eachProps, obj: object): T[] {\n\tconst rs: T[] = [],\n\t\targs = arguments\n\tlet handler: ObjKeyHandler<T> = defaultObjKeyHandler,\n\t\ti = 2,\n\t\tj = 0\n\tif (isFn(args[i])) {\n\t\thandler = args[i++]\n\t\tif (!isBool(args[i])) handler = bind(handler, args[i++])\n\t}\n\teach(\n\t\tobj,\n\t\t(prop, obj) => {\n\t\t\tconst val = handler(prop, obj)\n\t\t\tif (val === STOP) return STOP\n\t\t\tif (val !== SKIP) rs[j++] = val as T\n\t\t},\n\t\tnull,\n\t\targs[i]\n\t)\n\treturn rs\n}\n\n/**\n * @param obj\t\ttarget\n * @param handler\tkey handler\n * @param scope\t\tscope or handler\n * @param own\t\tis get own properties, default: true\n */\nexport function keys<T>(obj: object, own?: boolean): T[]\nexport function keys<T>(obj: object, callback: ObjKeyHandler<T>, own?: boolean): T[]\nexport function keys<T>(obj: object, callback: ObjKeyHandler<T>, scope?: any, own?: boolean): T[]\nexport function keys<T>(obj: object, callback?: ObjKeyHandler<T> | boolean, scope?: any, own?: boolean): T[] {\n\treturn doObjKeys(eachProps, obj, callback, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        values                                        *\n *                                                                                      */\n//========================================================================================\n\nexport type ObjValueHandler<T> = (value: any, prop: string, obj: object) => T | Control\n\nfunction defaultObjValueHandler(value: any, prop: string, obj: object): any {\n\treturn value\n}\nexport function doObjValues<T>(each: typeof eachObj, obj: object, own?: boolean): T[]\nexport function doObjValues<T>(each: typeof eachObj, obj: object, callback: ObjValueHandler<T>, own?: boolean): T[]\nexport function doObjValues<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: ObjValueHandler<T>,\n\tscope?: any,\n\town?: boolean\n): T[]\nexport function doObjValues<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback_own?: ObjValueHandler<T> | boolean,\n\tscope_own?: any,\n\town?: boolean\n): T[]\nexport function doObjValues<T>(each: typeof eachObj, obj: object): T[] {\n\tconst rs: T[] = [],\n\t\targs = arguments\n\tlet handler: ObjValueHandler<T> = defaultObjValueHandler,\n\t\ti = 1,\n\t\tj = 0\n\tif (isFn(args[i])) {\n\t\thandler = args[i++]\n\t\tif (!isBool(args[i])) handler = bind(handler, args[i++])\n\t}\n\teach(\n\t\tobj,\n\t\tfunction(data, prop, obj) {\n\t\t\tconst val = handler(data, prop, obj)\n\t\t\tif (val === STOP) return STOP\n\t\t\tif (val !== SKIP) rs[j++] = val as T\n\t\t},\n\t\tnull,\n\t\targs[i]\n\t)\n\treturn rs\n}\n\n/**\n * @param obj\t\ttarget\n * @param handler\tvalue handler\n * @param scope\t\tscope or handler\n * @param own\t\tis get own properties, default: true\n */\nexport function values<T>(obj: object, own?: boolean): T[]\nexport function values<T>(obj: object, callback: ObjValueHandler<T>, own?: boolean): T[]\nexport function values<T>(obj: object, callback: ObjValueHandler<T>, scope?: any, own?: boolean): T[]\nexport function values<T>(obj: object, callback?: ObjValueHandler<T> | boolean, scope?: any, own?: boolean): T[] {\n\treturn doObjValues(eachObj, obj, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Fri Nov 16 2018 16:29:04 GMT+0800 (China Standard Time)\n * @modified Sat Dec 29 2018 19:33:49 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './Control'\nimport { eachArray } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isFn, isStr, isArray } from '../is'\nimport { create } from '../create'\n\n/**\n * @return STOP or SKIP or [key: string, value: any]\n */\nexport type Arr2ObjCallback = (data: any, index: number, array: IArray) => Control | [string, any]\n\nexport function doArr2Obj(each: typeof eachArray, array: IArray, callback: Arr2ObjCallback, scope?: any): object {\n\tconst obj = create(null)\n\tcallback = bind(callback, scope)\n\teach(array, (data, index, array) => {\n\t\tconst r: Control | [string, any] = callback(data, index, array)\n\t\tif (isArray(r)) {\n\t\t\tobj[r[0]] = r[1]\n\t\t} else {\n\t\t\treturn r as Control\n\t\t}\n\t})\n\treturn obj\n}\n\n/**\n * convert array to object\n */\nexport function arr2obj(array: IArray, callback: Arr2ObjCallback, scope?: any): object {\n\treturn doArr2Obj(eachArray, array, callback, scope)\n}\n\n/**\n * convert array or string to object\n * @param array\n * @param val\tvalue or callback\n * @param split\tsplit char on string\n */\nexport function makeMap(array: IArray, val: Arr2ObjCallback, split?: string): object\nexport function makeMap(array: IArray, val?: any, split?: string): object\nexport function makeMap(array: IArray, val?: any, split?: string): object {\n\tif (isStr(array)) array = (array as string).split(isStr(split) ? split : ',')\n\treturn arr2obj(array, isFn(val) ? val : data => [data, val])\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Nov 15 2018 12:13:54 GMT+0800 (China Standard Time)\n * @modified Tue Dec 04 2018 20:10:32 GMT+0800 (China Standard Time)\n */\n\nexport { STOP, eachProps, eachArray, eachObj, each } from './each'\nexport { SKIP, mapArray, mapObj, map } from './map'\nexport { idxOfArray, idxOfObj, idxOf } from './idxOf'\nexport { reduceArray, reduceObj, reduce } from './reduce'\nexport { keys, values } from './obj2arr'\nexport { arr2obj, makeMap } from './arr2obj'\nexport function makeArray<T>(len: number, callback: (index: number) => T): T[] {\n\tconst array = new Array(len)\n\tlet i = len\n\twhile (i--) array[i] = callback(i)\n\treturn array\n}\n","/**\n * @module utility/prop\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Fri Nov 30 2018 14:41:02 GMT+0800 (China Standard Time)\n * @modified Sat Feb 23 2019 10:45:54 GMT+0800 (China Standard Time)\n */\n\nimport { create } from './create'\nimport { isArray } from './is'\nimport { mapArray } from './collection'\n\nconst pathCache: { [key: string]: string[] } = create(null)\n\n// (^ | .) prop | (index | \"string prop\" | 'string prop')\nconst pathReg = /(?:^|\\.)([a-zA-Z$_][\\w$]*)|\\[\\s*(?:(\\d+)|\"((?:[^\\\\\"]|\\\\.)*)\"|'((?:[^\\\\']|\\\\.)*)')\\s*\\]/g\n\nexport function parsePath(propPath: string | string[], cacheable?: boolean): string[] {\n\tlet path: string[]\n\tif (isArray(propPath)) {\n\t\tpath = propPath as string[]\n\t} else if ((path = pathCache[propPath as string])) {\n\t\treturn path\n\t} else {\n\t\tpath = []\n\t\tvar match: string[],\n\t\t\tidx = 0,\n\t\t\tcidx: number,\n\t\t\ti = 0\n\t\twhile ((match = pathReg.exec(propPath as string))) {\n\t\t\tcidx = pathReg.lastIndex\n\t\t\tif (cidx !== idx + match[0].length)\n\t\t\t\tthrow new SyntaxError(\n\t\t\t\t\t`Invalid Path: \"${propPath}\", unkown character[${(propPath as string).charAt(\n\t\t\t\t\t\tidx\n\t\t\t\t\t)}] at offset:${idx}`\n\t\t\t\t)\n\t\t\tpath[i++] = match[1] || match[2] || match[3] || match[4]\n\t\t\tidx = cidx\n\t\t}\n\t\tif (cacheable !== false && i) {\n\t\t\tpathCache[propPath as string] = path\n\t\t}\n\t}\n\tif (!path.length) throw new Error(`Empty Path: ${propPath}`)\n\treturn path\n}\n\nexport function formatPath(path: string | (string[] & { path?: string })): string {\n\treturn isArray(path)\n\t\t? (path as string[] & { path?: string }).path ||\n\t\t\t\t((path as string[] & { path?: string }).path = mapArray(path, formatPathHandler).join(''))\n\t\t: (path as string)\n}\n\nfunction formatPathHandler(prop: string): string {\n\treturn `[\"${String(prop).replace(\"'\", '\\\\\"')}\"]`\n}\n\nexport function get(obj: any, path: string | string[]): any {\n\tpath = parsePath(path)\n\tconst l = path.length - 1\n\tlet i = 0\n\tfor (; i < l; i++) if ((obj = obj[path[i]]) === null || obj === undefined) return\n\tif (obj && ~l) return obj[path[i]]\n}\n\nexport function set(obj: any, path: string | string[], value: any) {\n\tpath = parsePath(path)\n\tconst l = path.length - 1\n\tlet i = 0\n\tfor (; i < l; i++) obj = obj[path[i]] || (obj[path[i]] = {})\n\t~l && (obj[path[i]] = value)\n}\n","/**\n * String utilities\n * @module utility/string\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Tue Mar 05 2019 18:59:22 GMT+0800 (China Standard Time)\n */\nconst toString = Object.prototype.toString\nexport function toStr(obj: any): String {\n\treturn toString.call(obj)\n}\n\nexport function toStrType(obj: any) {\n\treturn toString.call(obj).match(/^\\[object ([^\\]]+)\\]$/)[1]\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       char code                                      *\n *                                                                                      */\n//========================================================================================\n\n/**\n * get char code\n * > string.charCodeAt\n */\nexport function charCode(str: string, index?: number): number {\n\treturn str.charCodeAt(index || 0)\n}\n\n/**\n * get char by char code\n * > String.fromCharCode\n */\nexport function char(code: number): string {\n\treturn String.fromCharCode(code)\n}\n\nexport function cutStr(str: string, start: number, end?: number) {\n\treturn str.substring(start, end)\n}\n\nexport function cutLStr(str: string, start: number, len?: number) {\n\treturn str.substr(start, len)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         trim                                         *\n *                                                                                      */\n//========================================================================================\n\nconst TRIM_REG = /(^\\s+)|(\\s+$)/g\n\n/**\n * trim\n */\nexport function trim(str: string): string {\n\treturn str.replace(TRIM_REG, '')\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         case                                         *\n *                                                                                      */\n//========================================================================================\n\nconst FIRST_LOWER_LETTER_REG = /^[a-z]/,\n\tFIRST_UPPER_LETTER_REG = /^[A-Z]/\n\nexport function upper(str: string): string {\n\treturn str.toUpperCase()\n}\n\nexport function lower(str: string): string {\n\treturn str.toLowerCase()\n}\n\nexport function upperFirst(str: string): string {\n\treturn str.replace(FIRST_LOWER_LETTER_REG, upper)\n}\n\nexport function lowerFirst(str: string): string {\n\treturn str.replace(FIRST_UPPER_LETTER_REG, lower)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        escape                                        *\n *                                                                                      */\n//========================================================================================\n\nconst STR_ESCAPE_MAP = {\n\t\t'\\n': '\\\\n',\n\t\t'\\t': '\\\\t',\n\t\t'\\f': '\\\\f',\n\t\t'\"': '\\\\\"',\n\t\t\"'\": \"\\\\'\"\n\t},\n\tSTR_ESCAPE = /[\\n\\t\\f\"']/g\n\nexport function escapeStr(str: string): string {\n\treturn str.replace(STR_ESCAPE, str => STR_ESCAPE_MAP[str])\n}\n","/**\n * @module utility/format\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 03 2018 19:46:41 GMT+0800 (China Standard Time)\n * @modified Fri Feb 22 2019 11:37:25 GMT+0800 (China Standard Time)\n */\n\nimport { createFn } from './fn'\nimport { isFn } from './is'\nimport { get, parsePath } from './propPath'\nimport { create } from './create'\nimport { charCode, upper, escapeStr, cutStr } from './string'\n\n//========================================================================================\n/*                                                                                      *\n *                                     pad & shorten                                    *\n *                                                                                      */\n//========================================================================================\n\nexport function pad(str: string, len: number, chr?: string, leftAlign?: boolean | number): string {\n\treturn len > str.length ? __pad(str, len, chr, leftAlign) : str\n}\n\nexport function shorten(str: string, len: number, suffix?: string): string {\n\treturn len < str.length ? ((suffix = suffix || ''), str.substr(0, len - suffix.length) + suffix) : str\n}\n\nfunction __pad(str: string, len: number, chr: string, leftAlign: boolean | number): string {\n\tconst pad = new Array(len - str.length + 1).join(chr || ' ')\n\treturn leftAlign ? str + pad : pad + str\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       Separator                                      *\n *                                                                                      */\n//========================================================================================\n\nexport const thousandSeparate = mkSeparator(3),\n\tbinarySeparate = mkSeparator(8, '01'),\n\toctalSeparate = mkSeparator(4, '0-7'),\n\thexSeparate = mkSeparator(4, '\\\\da-fA-F')\n\nfunction mkSeparator(group: number, valReg?: string): (numStr: string) => string {\n\tvalReg = valReg || '\\\\d'\n\tconst reg = new RegExp(\n\t\t`^(?:[+-]|\\\\s+|0[xXbBoO])|([${valReg}])(?=([${valReg}]{${group}})+(?![${valReg}]))|[^${valReg}].*`,\n\t\t'g'\n\t)\n\treturn numStr => numStr.replace(reg, separatorHandler)\n}\nfunction separatorHandler(m, d) {\n\treturn d ? d + ',' : m\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                   plural & singular                                  *\n *                                                                                      */\n//========================================================================================\n\nconst PLURAL_REG = /([a-zA-Z]+)([^aeiou])y$|([sxzh])$|([aeiou]y)$|([^sxzhy])$/\nexport function plural(str: string): string {\n\treturn str.replace(PLURAL_REG, pluralHandler)\n}\nfunction pluralHandler(m, v, ies, es, ys, s) {\n\treturn v + (ies ? ies + 'ies' : es ? es + 'es' : (ys || s) + 's')\n}\n\nconst SINGULAR_REG = /([a-zA-Z]+)([^aeiou])ies$|([sxzh])es$|([aeiou]y)s$|([^sxzhy])s$/\nexport function singular(str: string): string {\n\treturn str.replace(SINGULAR_REG, singularHandler)\n}\nfunction singularHandler(m, v, ies, es, ys, s) {\n\treturn v + (ies ? ies + 'y' : es || ys || s)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     format flags                                     *\n *                                                                                      */\n//========================================================================================\n\ntype FormatFlags = number\n\nexport const FORMAT_XPREFIX: FormatFlags = 0x1\nexport const FORMAT_PLUS: FormatFlags = 0x2\nexport const FORMAT_ZERO: FormatFlags = 0x4\nexport const FORMAT_SPACE: FormatFlags = 0x8\nexport const FORMAT_SEPARATOR: FormatFlags = 0x10\nexport const FORMAT_LEFT: FormatFlags = 0x20\n\nconst FLAG_MAPPING = {\n\t'#': FORMAT_XPREFIX,\n\t'+': FORMAT_PLUS,\n\t'0': FORMAT_ZERO,\n\t' ': FORMAT_SPACE,\n\t',': FORMAT_SEPARATOR,\n\t'-': FORMAT_LEFT\n}\nfunction parseFlags(f: string): FormatFlags {\n\tlet flags: FormatFlags = 0\n\tif (f) {\n\t\tvar i = f.length\n\t\twhile (i--) flags |= FLAG_MAPPING[f.charAt(i)]\n\t}\n\treturn flags\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      format Rule                                     *\n *                                                                                      */\n//========================================================================================\n\n//   0      1      2     3     4       5       6           7         8      9           10             11             12        13\n// [match, expr, index, prop, flags, width, width-idx, width-prop, fill, precision, precision-idx, precision-prop, shorten-suffix, type]\nconst paramIdxR = `(\\\\d+|\\\\$|@)`,\n\tparamPropR = `(?:\\\\{((?:[a-zA-Z$_][\\\\w$_]*|\\\\[(?:\\\\d+|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)*\"|'(?:[^\\\\\\\\']|\\\\\\\\.)*')\\\\])(?:\\\\.[a-zA-Z$_][\\\\w$_]*|\\\\[(?:\\\\d+|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)*\"|'(?:[^\\\\\\\\']|\\\\\\\\.)*')\\\\])*)\\\\})`,\n\twidthR = `(?:([1-9]\\\\d*)|&${paramIdxR}${paramPropR})`,\n\tfillR = `(?:=(.))`,\n\tshortenSuffixR = `(?:=\"((?:[^\\\\\\\\\"]|\\\\\\\\.)*)\")`,\n\tformatReg = new RegExp(\n\t\t`\\\\\\\\.|(\\\\{${paramIdxR}?${paramPropR}?(?::([#,+\\\\- 0]*)(?:${widthR}${fillR}?)?(?:\\\\.${widthR}${shortenSuffixR}?)?)?([a-zA-Z_][a-zA-Z0-9_$]*)?\\\\})`,\n\t\t'g'\n\t)\n\n//========================================================================================\n/*                                                                                      *\n *                                      Formatters                                      *\n *                                                                                      */\n//========================================================================================\n\ntype FormatCallback = (\n\tval: any,\n\tflags: FormatFlags,\n\twidth: number,\n\tfill: string,\n\tprecision: number,\n\tshortenSuffix: string\n) => string\n\nconst formatters: {\n\t[k: string]: FormatCallback\n} = create(null)\n\nexport function extendFormatter(obj: { [key: string]: FormatCallback }) {\n\tvar fmt, name\n\tfor (name in obj) {\n\t\tfmt = obj[name]\n\t\tisFn(fmt) && (formatters[name] = fmt)\n\t}\n}\n\nexport function getFormatter(name: string): FormatCallback {\n\tconst f = formatters[name || 's']\n\tif (f) return f\n\tthrow new Error(`Invalid Formatter: ${name}`)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                           format by every parameter object                           *\n *                                                                                      */\n//========================================================================================\n\n/**\n * Syntax:\n * @example\n * \t'{'\n * \t\t(<parameter>)?\n * \t\t(\n * \t\t\t':'\n * \t\t\t(<flags>)?\n * \t\t\t(\n * \t\t\t\t<width> ('=' <fill-char>)?\n * \t\t\t)?\n * \t\t\t(\n * \t\t\t\t'.'\n * \t\t\t\t<precision> ('=' '\"' <shorten-suffix> '\"')?\n * \t\t\t)?\n * \t\t)?\n * \t\t(<type>)?\n * \t'}'\n *\n * - parameter\n * \t\t- {}\t\t\t\t\tformat by next unused argument\n * \t\t- {<number>}\t\t\tformat by arguments[number]\n * \t\t- {@}\t\t\t\t\tformat by current used argument\n * \t\t- {$}\t\t\t\t\tformat by next unused argument\n * \t\t- {{name}}\t\t\t\tformat by \"name\" property on next unused argument\n * \t\t- {<number>{name}}\t\tformat by \"name\" property on arguments[number]\n * \t\t- {@{name}}\t\t\t\tformat by \"name\" property on current used argument\n * \t\t- {${name}}\t\t\t\tformat by \"name\" property on next unused argument\n * @example\n * \t\tformat('<{} {}>', 'abc')\t\t\t\t// return \"<abc undefined>\"\n * \t\tformat('<{$} {$}>', 'abc')\t\t\t\t// return \"<abc undefined>\"\n * \t\tformat('<{@} {} {@}>', 'abc')\t\t\t// return \"<abc abc abc>\"\n * \t\tformat('<{0} {} {0}>', 'abc')\t\t\t// return \"<abc abc abc>\"\n * \t\tformat('<{0{value}} {${value}} {@{value}} {{value.a}}>', {value: 'abc'}, {value: {a: 'cbd'}})\n * \t\t// return \"<abc abc abc bcd>\"\n * \t\tformat('<{0{[0]}} {${[0]}} {@{[0]}} {{[0].a}}>', ['abc'], [{a: 'cbd'}])\n * \t\t// return \"<abc abc abc bcd>\"\n *\n * - flags\n * \t\t- {:#}    \tFORMAT_XPREFIX\n * \t\t\t\t\tensure the leading \"0\" for any octal\n * \t\t\t\t\tprefix non-zero hexadecimal with \"0x\" or \"0X\"\n * \t\t\t\t\tprefix non-zero binary with \"0b\" or \"0B\"\n * \t\t- {:+}    \tFORMAT_PLUS\n * \t\t\t\t\tForces to preceed the result with a plus or minus sign (+ or -) even for positive numbers.\n * \t\t\t\t\tBy default, only negative numbers are preceded with a - sign\n * \t\t- {:0}\t\tFORMAT_ZERO\n * \t\t\t\t\tLeft-pads the number with zeroes (0) instead of spaces when padding is specified\n * \t\t- {: }   \tFORMAT_SPACE\n * \t\t\t\t\tIf no sign is going to be written, a blank space is inserted before the value\n * \t\t- {:,}\t\tFORMAT_SEPARATOR\n * \t\t\t\t\tuse thousand separator on decimal number\n * \t\t\t\t\thexadecimal number: FFFFFFFF => FFFF,FFFF\n * \t\t\t\t\toctal number: 77777777 => 7777,7777\n * \t\t\t\t\tbinary number: 1111111111111111 => 11111111,11111111\n * \t\t{:-}    \tFORMAT_LEFT\n * \t\t\t\t\tLeft-justify within the given field width; Right justification is the default\n * @example\n * \t\tformat('<{: d}>',  12);\t\t// return \"< 12>\"\n *\t\tformat('<{: d}>',   0);\t\t// return \"< 0>\"\n *\t\tformat('<{: d}>', -12);\t\t// return \"<-12>\"\n *\t\tformat('<{:+d}>',  12);\t\t// return \"<+12>\"\n *\t\tformat('<{:+d}>',   0);\t\t// return \"<+0>\"\n *\t\tformat('<{:+d}>', -12);\t\t// return \"<-12>\"\n *\t\tformat('<{:6s}>',  12);\t\t// return \"<    12>\"\n *\t\tformat('<{:-6s}>', 12);\t\t// return \"<12    >\"\n *\t\tformat('<{:#o}>',  12);\t\t// return \"<014>\"\n *\t\tformat('<{:#x}>',  12);\t\t// return \"<0xc>\"\n *\t\tformat('<{:#X}>',  12);\t\t// return \"<0XC>\"\n *\t\tformat('<{:#b}>',  12);\t\t// return \"<0b1100>\"\n *\t\tformat('<{:#B}>',  12);\t\t// return \"<0B1100>\"\n\n * - width\n * \t\tMinimum number of characters to be printed.\n * \t\tIf the value to be printed is shorter than this number, the result is padded with pad char(default is space).\n * \t\tThe value is not truncated even if the result is larger.\n *\t\t- width value\n * \t\t\t{:<number>}\n * \t\t\t{:&@}\n * \t\t\t{:&$}\n * \t\t\t{:&<number>}\n * \t\t\t{:&@{<prop>}}\n * \t\t\t{:&${<prop>}}\n * \t\t\t{:&<number>{<prop>}}\n *\t\t- pad char\n * \t\t\t{:&@=<pad-char>}\n * \t\t\t{:&$=<pad-char>}\n * \t\t\t{:&<number>=<pad-char>}\n * \t\t\t{:&@{<prop>}=<pad-char>}\n * \t\t\t{:&${<prop>}=<pad-char>}\n * \t\t\t{:&<number>{<prop>}=<pad-char>}\n * @example\n * - precision\n * \t\tFor integer specifiers (d,  o, u, x, X): precision specifies the minimum number of digits to be written.\n * \t\tIf the value to be written is shorter than this number, the result is padded with leading zeros.\n * \t\tThe value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0.\n * \t\tFor a, A, e, E, f and F specifiers: this is the number of digits to be printed after the decimal point (by default, this is 6).\n * \t\tFor g and G specifiers: This is the maximum number of significant digits to be printed.\n * \t\tFor s: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered.\n * \t\tIf the period is specified without an explicit value for precision, 0 is assumed.\n * \t\t- precision value\n * \t\t\t{:.<number>}\n * \t\t\t{:.&@}\n * \t\t\t{:.&$}\n * \t\t\t{:.&<number>}\n * \t\t\t{:.&@{<prop>}}\n * \t\t\t{:.&${<prop>}}\n * \t\t\t{:.&<number>{<prop>}}\n * \t\t- shorten suffix\n * \t\t\t{:.&@=\"<suffix>\"}\n * \t\t\t{:.&$=\"<suffix>\"}\n * \t\t\t{:.&<number>=\"<suffix>\"}\n * \t\t\t{:.&@{<prop>}=\"<suffix>\"}\n * \t\t\t{:.&${<prop>}=\"<suffix>\"}\n * \t\t\t{:.&<number>{<prop>}=\"<suffix>\"}\n * - type\n * \t\t- default types\n *\t\t\t- {c}\t\tCharacter\n * \t\t\t- {s}\t\tString\n * \t\t\t- {j}\t\tJSON String\n * \t\t\t- {y}\t\tDate Year\n * \t\t\t- {m}\t\tDate Month\n * \t\t\t- {w}\t\tDate Weekly\n * \t\t\t- {W}\t\tDate Weekly\n * \t\t\t- {D}\t\tDate\n * \t\t\t- {H}\t\tDate\n * \t\t\t- {M}\t\tDate\n * \t\t\t- {S}\t\tDate\n * \t\t\t- {d} \t\tSigned decimal integer\n *\t\t\t- {u}\t\tUnsigned decimal integer\n *\t\t\t- {o}\t\tUnsigned octal\n *\t\t\t- {x}\t\tUnsigned hexadecimal integer\n *\t\t\t- {X}\t\tUnsigned hexadecimal integer (uppercase)\n *\t\t\t- {f}\t\tDecimal floating point, lowercase,\n *\t\t\t- {e}\t\tScientific notation (mantissa/exponent), lowercase\n *\t\t\t- {E}\t\tScientific notation (mantissa/exponent), uppercase\n *\t\t\t- {g}\t\tUse the shortest representation: %e or %f\n *\t\t\t- {G}\t\tUse the shortest representation: %E or %F\n * - Rules\n * \t\t- property-path\n * \t\t\t\t(\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t[a-zA-Z$_][\\w$_]*|\n * \t\t\t\t\t\t\\[\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\\d+|\n * \t\t\t\t\t\t\t\"(?:[^\\\\\"]|\\\\.)*\"|\n * \t\t\t\t\t\t\t'(?:[^\\\\']|\\\\.)*'\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t\\]\n * \t\t\t\t\t)\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t\\.[a-zA-Z$_][\\w$_]*|\n * \t\t\t\t\t\t\\[\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\\d+|\n * \t\t\t\t\t\t\t\"(?:[^\\\\\"]|\\\\.)*\"|\n * \t\t\t\t\t\t\t'(?:[^\\\\']|\\\\.)*'\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t\\]\n * \t\t\t\t\t)*\n * \t\t\t\t)\n * \t\t- expression\n * \t\t\t/\\\\.|\t\t\t\t\t\t\t\t\t\t\t\t// escape\n * \t\t\t(\t\t\t\t\t\t\t\t\t\t\t\t\t// 1: expression\n * \t\t\t\t\\{\n * \t\t\t\t(\\d+|\\$|@)?\t\t\t\t\t\t\t\t\t\t// 2: parameter index\n * \t\t\t\t(?:\\{<property-path>\\})?\t\t\t\t\t\t// 3: property path of parameter\n * \t\t\t\t(?:\n * \t\t\t\t\t:\n * \t\t\t\t\t([#,+\\- ]*)\t\t\t\t\t\t\t\t\t// 4: flags\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t(\\d+)|\t\t\t\t\t\t\t\t// 5: width\n * \t\t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\t&\n * \t\t\t\t\t\t\t\t(\\d+|\\$|@)\t\t\t\t\t\t// 6: parameter index of width\n * \t\t\t\t\t\t\t\t(?:\\{<property-path>\\})?\t\t// 7: property path of width parameter\n * \t\t\t\t\t\t\t)\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t(?:=(.))?\t\t\t\t\t\t\t\t// 8: pad fill\n * \t\t\t\t\t)?\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t\\.\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t(\\d+)|\t\t\t\t\t\t\t\t// 9: width\n * \t\t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\t&\n * \t\t\t\t\t\t\t\t(\\d+|\\$|@)\t\t\t\t\t\t// 10: parameter index of width\n * \t\t\t\t\t\t\t\t(?:\\{<property-path>\\})?\t\t// 11: property path of width parameter\n * \t\t\t\t\t\t\t)\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t=\n * \t\t\t\t\t\t\t\"\n * \t\t\t\t\t\t\t((?:[^\\\\\"]|\\\\.)*)\t\t\t\t\t// 12: shorten su\n * \t\t\t\t\t\t\t\"\n * \t\t\t\t\t\t)\n * \t\t\t\t\t)?\n * \t\t\t\t)?\n * \t\t\t\t([a-zA-Z_][a-zA-Z0-9_$]*)?\t\t\t\t\t\t// 13: data type\n * \t\t\t\t\\}\n * \t\t\t)/\n * @param fmt \t\tformat String\n * @param args\t\tformat arguments\n * @param offset\tstart offset of arguments\n * @param getParam\tget parameter on arguments callback\n */\nexport function vformat<T>(fmt: string, args: T, offset?: number, getParam?: (args: T, idx: number) => any): string {\n\toffset = offset || 0\n\tconst start = offset\n\tgetParam = getParam || defaultGetParam\n\treturn fmt.replace(formatReg, function(\n\t\ts,\n\t\tm,\n\t\tparam,\n\t\tparamProp,\n\t\tflags,\n\t\twidth,\n\t\twidx,\n\t\twprop,\n\t\tfill,\n\t\tprecision,\n\t\tpidx,\n\t\tpprop,\n\t\tshortenSuffix,\n\t\ttype\n\t) {\n\t\tif (!m) return s.charAt(1)\n\t\treturn getFormatter(type)(\n\t\t\tparseParam(param || '$', paramProp),\n\t\t\tparseFlags(flags),\n\t\t\tparseWidth(width, widx, wprop) || 0,\n\t\t\tfill,\n\t\t\tparseWidth(precision, pidx, pprop),\n\t\t\tshortenSuffix\n\t\t)\n\t})\n\n\tfunction parseWidth<T>(width: string, idx: string, prop: string): number {\n\t\tif (width) return (width as any) >> 0\n\t\tif (idx) {\n\t\t\tconst w = parseParam(idx, prop) >> 0\n\t\t\tif (isFinite(w)) return w\n\t\t}\n\t}\n\n\tfunction parseParam<T>(paramIdx: string, prop: string): any {\n\t\tlet param = getParam(\n\t\t\targs,\n\t\t\tparamIdx === '$'\n\t\t\t\t? offset++\n\t\t\t\t: paramIdx === '@'\n\t\t\t\t? offset === start\n\t\t\t\t\t? offset\n\t\t\t\t\t: offset - 1\n\t\t\t\t: (paramIdx as any) >> 0\n\t\t)\n\t\treturn prop ? get(param, prop) : param\n\t}\n}\n\nfunction defaultGetParam(args: any, idx: number) {\n\treturn args[idx]\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        format                                        *\n *                                                                                      */\n//========================================================================================\n\n/**\n * @see vformat\n * @param fmt\tformat string\n * @param args\tformat arguments\n */\nexport function format(fmt: string, ...args: any): string\nexport function format(fmt: string): string {\n\treturn vformat(fmt, arguments, 0, getFormatParam)\n}\n\nfunction getFormatParam(args: IArguments, idx: number) {\n\treturn args[idx + 1]\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       formatter                                      *\n *                                                                                      */\n//========================================================================================\n\nconst GET_PARAM_VAR = 'getp',\n\tGET_PROP_VAR = 'get',\n\tSTATE_VAR = 'state'\nfunction createFormatter(m: string[], getParam?: (args: IArguments, idx: number) => any) {\n\treturn createFn(\n\t\t`return function(args, ${STATE_VAR}){\nreturn fmt(${getParamCode(m[2] || '$', m[3])},\n\"${parseFlags(m[4])}\",\n${getWidthCode(m[5], m[6], m[7], '0')},\n\"${m[8] ? escapeStr(m[8]) : ' '}\",\n${getWidthCode(m[9], m[10], m[11], 'void 0')},\n\"${m[12] ? escapeStr(m[12]) : ''}\");\n}`,\n\t\t['fmt', GET_PROP_VAR, GET_PARAM_VAR]\n\t)(getFormatter(m[13]), get, getParam)\n}\n\nfunction getWidthCode(width: string, idx: string, prop: string, def: string): string {\n\treturn width ? width : idx ? getParamCode(idx, prop) : def\n}\n\nfunction getParamCode(idx: string, prop: string): string {\n\tlet code = `${GET_PARAM_VAR}(args, ${\n\t\tidx === '$'\n\t\t\t? `${STATE_VAR}[0]++`\n\t\t\t: idx === '@'\n\t\t\t? `${STATE_VAR}[0] === ${STATE_VAR}[1] ? ${STATE_VAR}[0] : ${STATE_VAR}[0] - 1`\n\t\t\t: idx\n\t})`\n\tif (prop) {\n\t\tconst path = parsePath(prop)\n\t\tvar i = path.length\n\t\tconst strs = new Array(i)\n\t\twhile (i--) strs[i] = `\"${escapeStr(path[i])}\"`\n\t\treturn `${GET_PROP_VAR}(${code}, [${strs.join(', ')}])`\n\t}\n\treturn code\n}\n/**\n * @see vformat\n * @param fmt\t\tformat string\n * @param offset\tstart offset of arguments\n * @param getParam\tget parameter on arguments callback\n */\nexport function formatter(\n\tfmt: string,\n\toffset?: number,\n\tgetParam?: (args: IArguments, idx: number) => any\n): (...args: any[]) => string {\n\tlet m,\n\t\tlastIdx = 0,\n\t\tmStart,\n\t\tmEnd,\n\t\tarr = [],\n\t\tcodes = [],\n\t\ti = 0\n\toffset = offset || 0\n\twhile ((m = formatReg.exec(fmt))) {\n\t\tmEnd = formatReg.lastIndex\n\t\tmStart = mEnd - m[0].length\n\t\tlastIdx < mStart && pushStr(cutStr(fmt, lastIdx, mStart), 0)\n\t\tif (m[1]) {\n\t\t\tcodes[i] = `arr[${i}](arguments, ${STATE_VAR})`\n\t\t\tarr[i++] = createFormatter(m, getParam || defaultGetParam)\n\t\t} else {\n\t\t\tpushStr(m[0].charAt(1), i)\n\t\t}\n\t\tlastIdx = mEnd\n\t}\n\tlastIdx < fmt.length && pushStr(cutStr(fmt, lastIdx), i)\n\treturn createFn(`return function(){var ${STATE_VAR} = [${offset}, ${offset}]; return ${codes.join(' + ')}}`, [\n\t\t'arr'\n\t])(arr)\n\n\tfunction pushStr(str, append) {\n\t\tif (append && arr[i - 1].match) {\n\t\t\tarr[i - 1] += str\n\t\t} else {\n\t\t\tcodes[i] = `arr[${i}]`\n\t\t\tarr[i++] = str\n\t\t}\n\t}\n}\n/*\nsetTimeout(() => {\n\tvar f,\n\t\tn = 100000\n\tconsole.time()\n\tfor (var i = 0; i < n; i++) {\n\t\tf = formatter(`{:.10=\"...\"}`)\n\t}\n\tconsole.timeEnd()\n\tconsole.time()\n\tfor (var i = 0; i < n; i++) {\n\t\tf('abbdddded')\n\t}\n\tconsole.timeEnd()\n\tconsole.time()\n\tfor (var i = 0; i < n; i++) {\n\t\tformat(`{:.10=\"...\"}`, 'abbdddded')\n\t}\n\tconsole.timeEnd()\n\tconsole.log(formatter(`{:.10=\"...\"}`).toString())\n}) */\n//========================================================================================\n/*                                                                                      *\n *                                  default formatters                                  *\n *                                                                                      */\n//========================================================================================\n\nfunction strFormatter(toStr: (val: any, flags: FormatFlags) => string): FormatCallback {\n\treturn function(val, flags, width, fill, precision, shortenSuffix) {\n\t\tconst str = toStr(val, flags)\n\t\treturn width > str.length\n\t\t\t? __pad(str, width, fill, flags & FORMAT_LEFT)\n\t\t\t: shorten(str, precision, shortenSuffix)\n\t}\n}\n\nfunction numFormatter(\n\tparseNum: (val: any) => number,\n\tgetPrefix: (num: number, flags: FormatFlags) => string,\n\ttoStr: (num: number, flags: FormatFlags, precision: number) => string,\n\tseparator: (numStr: string) => string\n): FormatCallback {\n\treturn function(val, flags, width, fill, precision) {\n\t\tconst num = parseNum(val)\n\t\tif (!isFinite(num)) return String(num)\n\n\t\tconst prefix = getPrefix(num, flags),\n\t\t\tplen = prefix.length\n\t\tlet str = toStr(num < 0 ? -num : num, flags, precision)\n\n\t\treturn flags & FORMAT_ZERO\n\t\t\t? ((str = prefix + pad(str, width - plen, '0')), flags & FORMAT_SEPARATOR ? separator(str) : str)\n\t\t\t: (flags & FORMAT_SEPARATOR && (str = separator(str)), pad(prefix + str, width, fill, flags & FORMAT_LEFT))\n\t}\n}\n\nfunction decimalPrefix(num: number, flags: FormatFlags): string {\n\treturn num < 0 ? '-' : flags & FORMAT_PLUS ? '+' : flags & FORMAT_SPACE ? ' ' : ''\n}\n\n// base formatter \nconst BASE_RADIXS = {\n\tb: [2, binarySeparate],\n\to: [8, octalSeparate],\n\tu: [10, thousandSeparate],\n\tx: [16, hexSeparate]\n}\nconst BASE_PREFIXS = ['0b', '0o', '0x']\nfunction baseFormatter(type: string): FormatCallback {\n\tconst base = BASE_RADIXS[type.toLowerCase()],\n\t\tn = base[0],\n\t\t__toStr = num => num.toString(n),\n\t\ttoStr = type === 'X' ? num => upper(__toStr(num)) : __toStr\n\tlet xprefix = n === 10 ? '' : BASE_PREFIXS[n >> 3]\n\tcharCode(type) < 96 && (xprefix = upper(xprefix))\n\treturn numFormatter(v => v >>> 0, (num, flags) => (flags & FORMAT_XPREFIX ? xprefix : ''), toStr, base[1])\n}\n\n// float formatter \nfunction floatFormatter(type: string): FormatCallback {\n\tconst ____toStr = upper(type) === 'E' ? toExponential : type === 'f' ? toFixed : toPrecision,\n\t\t__toStr = (num, flags, precision) => ____toStr(num, precision) || String(num),\n\t\ttoStr = charCode(type) > 96 ? __toStr : (num, flags, precision) => upper(__toStr(num, flags, precision))\n\treturn numFormatter(parseFloat, decimalPrefix, toStr, thousandSeparate)\n}\n\nfunction toExponential(num: number, precision: number): string {\n\treturn num.toExponential(precision)\n}\nfunction toPrecision(num: number, precision: number): string {\n\treturn precision && num.toPrecision(precision)\n}\nfunction toFixed(num: number, precision: number): string {\n\treturn precision >= 0 && num.toFixed(precision)\n}\n\n// register formatters \nextendFormatter({\n\ts: strFormatter(toStr),\n\tj: strFormatter(v =>\n\t\tv === undefined || isFn(v) || (v.toJSON && v.toJSON() === undefined) ? toStr(v) : JSON.stringify(v)\n\t),\n\tc(val: any) {\n\t\tconst num = val >> 0\n\t\treturn num > 0 ? String.fromCharCode(num) : ''\n\t},\n\td: numFormatter(val => val >> 0, decimalPrefix, toStr, thousandSeparate),\n\te: floatFormatter('e'),\n\tE: floatFormatter('E'),\n\tf: floatFormatter('f'),\n\tg: floatFormatter('g'),\n\tG: floatFormatter('G'),\n\tb: baseFormatter('b'),\n\tB: baseFormatter('B'),\n\to: baseFormatter('o'),\n\tO: baseFormatter('O'),\n\tu: baseFormatter('u'),\n\tx: baseFormatter('x'),\n\tX: baseFormatter('X')\n})\n\nfunction toStr(v: any): string {\n\treturn String(v)\n}\n","/**\n * Object.assign shim\n * @module utility/assign\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:22:13 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 14:03:59 GMT+0800 (China Standard Time)\n */\nimport { hasOwnProp } from './prop'\n\n/**\n * @param prop\n * @param target\n * @param override\n * @return is assign\n */\nexport type AssignFilter = (prop: string, target: any, override: any) => boolean\n\n/**\n *\n * @param target\n * @param overrides\n * @param filter\n * @param startOffset \tstart offset in overrides, default: 0\n * @param endOffset \tend offset in overrides, default: overrides.length-1\n */\nexport function doAssign(\n\ttarget: any,\n\toverrides: object[] | IArguments,\n\tfilter: AssignFilter,\n\tstartOffset?: number,\n\tendOffset?: number\n): any {\n\tif (!target) {\n\t\ttarget = {}\n\t}\n\tconst l = endOffset || overrides.length - 1\n\tlet i = startOffset || 0,\n\t\toverride,\n\t\tprop\n\tfor (; i < l; i++) {\n\t\tif ((override = overrides[i])) {\n\t\t\tfor (prop in override) {\n\t\t\t\tif (filter(prop, target, override)) {\n\t\t\t\t\ttarget[prop] = override[prop]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn target\n}\n\n/**\n * assign properties\n * > Object.assign shim\n */\nexport function assign(target: any, ...args: any[]): any\nexport function assign(target: any): any {\n\treturn doAssign(target, arguments, defaultAssignFilter, 1)\n}\n\n/**\n * assign un-exist properties\n */\nexport function assignIf(target: any, ...args: any[]): any\nexport function assignIf(target: any): any {\n\treturn doAssign(target, arguments, assignIfFilter, 1)\n}\n\n/**\n * default assign filter\n * - property is owner in override\n * @see {AssignFilter}\n */\nexport function defaultAssignFilter(prop: string, target: any, override: any): boolean {\n\treturn hasOwnProp(override, prop)\n}\n\n/**\n * assign if filter\n * - property is owner in override\n * - property not in target object\n * @see {AssignFilter}\n */\nexport function assignIfFilter(prop: string, target: any, override: any): boolean {\n\treturn hasOwnProp(override, prop) && !(prop in target)\n}\n","/**\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:24:47 GMT+0800 (China Standard Time)\n * @modified Tue Feb 19 2019 11:53:18 GMT+0800 (China Standard Time)\n */\nimport { eq, isReg, isTypedArray, isDate, isArray, isPrimitive } from './is'\nimport { hasOwnProp } from './prop'\nimport { create } from './create'\nimport { getConstructor } from './constructor'\n\nconst REG_PROPS = ['source', 'global', 'ignoreCase', 'multiline']\n\nexport function deepEq(actual: any, expected: any): boolean {\n\tif (eq(actual, expected)) return true\n\tif (actual && expected && getConstructor(actual) === getConstructor(expected)) {\n\t\tif (isPrimitive(actual)) return String(actual) === String(expected)\n\t\tif (isDate(actual)) return actual.getTime() === expected.getTime()\n\t\tif (isReg(actual)) return eqProps(actual, expected, REG_PROPS)\n\t\tif (isArray(actual)) return eqArray(actual, expected, deepEq)\n\t\tif (isTypedArray(actual)) return eqArray(actual, expected, eq)\n\t\treturn eqObj(actual, expected)\n\t}\n\treturn false\n}\n\nfunction eqProps(actual: any, expected: any, props: string[]): boolean {\n\tlet i = props.length\n\twhile (i--)\n\t\tif (actual[props[i]] !== expected[props[i]]) {\n\t\t\treturn false\n\t\t}\n\treturn true\n}\n\nfunction eqArray(actual: any, expected: any, eq: (actual: any, expected: any) => boolean) {\n\tlet i = actual.length\n\tif (i !== expected.length) {\n\t\treturn false\n\t}\n\twhile (i--)\n\t\tif (!eq(actual[i], expected[i])) {\n\t\t\treturn false\n\t\t}\n\treturn true\n}\n\nfunction eqObj(actual: any, expected: any): boolean {\n\tconst cache = create(null)\n\tlet k: string\n\tfor (k in actual) {\n\t\tif (notEqObjKey(actual, expected, k)) {\n\t\t\treturn false\n\t\t}\n\t\tcache[k] = true\n\t}\n\tfor (k in expected) {\n\t\tif (!cache[k] && notEqObjKey(actual, expected, k)) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunction notEqObjKey(actual: any, expected: any, k: string): boolean {\n\treturn hasOwnProp(actual, k) ? !hasOwnProp(expected, k) || !deepEq(actual[k], expected[k]) : hasOwnProp(expected, k)\n}\n","/**\n * @module utility/assert\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Nov 28 2018 11:01:45 GMT+0800 (China Standard Time)\n * @modified Tue Feb 19 2019 10:38:22 GMT+0800 (China Standard Time)\n */\n\nimport {\n\teq,\n\tisBool,\n\tisNum,\n\tisStr,\n\tisBoolean,\n\tisNumber,\n\tisString,\n\tisDate,\n\tisNull,\n\tisUndef,\n\tisNil,\n\tisFn,\n\tisInt,\n\tisPrimitive,\n\tisReg,\n\tisArray,\n\tisArrayLike,\n\tisTypedArray,\n\tisObj,\n\tisBlank\n} from '../utility/is'\nimport { create } from './create'\nimport { upperFirst, escapeStr } from '../utility/string'\nimport { createFn } from '../utility/fn'\nimport { eachObj, makeArray } from '../utility/collection'\nimport { formatter } from './format'\nimport { deepEq } from './deepEq'\nimport { TYPE_UNDEF, TYPE_FN, TYPE_STRING, TYPE_NUM, TYPE_BOOL } from './consts'\n\nconst formatters = [],\n\tformatArgHandlers: ((args: any[] | IArguments, offset: number) => any)[] = []\nfunction parseMessage(msg: string, args: any[] | IArguments, msgIdx: number): string {\n\tlet fs = formatters[msgIdx]\n\tif (!fs) {\n\t\tformatArgHandlers[msgIdx] = (args, offset) => args[0][offset >= msgIdx ? offset + 1 : offset]\n\t\tformatters[msgIdx] = fs = create(null)\n\t}\n\treturn (fs[msg] || (fs[msg] = formatter(msg, msgIdx, formatArgHandlers[msgIdx])))(args)\n}\n\nexport interface assert {\n\t(msg?: string, ...args: any[]): never\n\tis(actual: any, msg?: string, ...args: any[]): assert\n\tnot(actual: any, msg?: string, ...args: any[]): assert\n\teq(actual: any, expect: any, msg?: string, ...args: any[]): assert\n\teql(actual: any, expect: any, msg?: string, ...args: any[]): assert\n\tblank(actual: any, msg?: string, ...args: any[]): assert\n\tnul(actual: any, msg?: string, ...args: any[]): assert\n\tnil(actual: any, msg?: string, ...args: any[]): assert\n\tundef(actual: any, msg?: string, ...args: any[]): assert\n\tbool(actual: any, msg?: string, ...args: any[]): assert\n\tnum(actual: any, msg?: string, ...args: any[]): assert\n\tint(actual: any, msg?: string, ...args: any[]): assert\n\tstr(actual: any, msg?: string, ...args: any[]): assert\n\tfn(actual: any, msg?: string, ...args: any[]): assert\n\tprimitive(actual: any, msg?: string, ...args: any[]): assert\n\tboolean(actual: any, msg?: string, ...args: any[]): assert\n\tnumber(actual: any, msg?: string, ...args: any[]): assert\n\tstring(actual: any, msg?: string, ...args: any[]): assert\n\tdate(actual: any, msg?: string, ...args: any[]): assert\n\treg(actual: any, msg?: string, ...args: any[]): assert\n\tarray(actual: any, msg?: string, ...args: any[]): assert\n\ttypedArray(actual: any, msg?: string, ...args: any[]): assert\n\tarrayLike(actual: any, msg?: string, ...args: any[]): assert\n\tobj(actual: any, msg?: string, ...args: any[]): assert\n\tnan(actual: any, msg?: string, ...args: any[]): assert\n\tfinite(actual: number | string, msg?: string, ...args: any[]): assert\n\tless(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\tgreater(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\tmatch(actual: string, expect: any, msg?: string, ...args: any[]): assert\n\trange(actual: number, start: number, end: number, msg?: string, ...args: any[]): assert\n\n\tnotEq(actual: any, expect: any, msg?: string, ...args: any[]): assert\n\tnotEql(actual: any, expect: any, msg?: string, ...args: any[]): assert\n\tnotBlank(actual: any, msg?: string, ...args: any[]): assert\n\tnotNul(actual: any, msg?: string, ...args: any[]): assert\n\tnotNil(actual: any, msg?: string, ...args: any[]): assert\n\tnotUndef(actual: any, msg?: string, ...args: any[]): assert\n\tnotBool(actual: any, msg?: string, ...args: any[]): assert\n\tnotNum(actual: any, msg?: string, ...args: any[]): assert\n\tnotInt(actual: any, msg?: string, ...args: any[]): assert\n\tnotStr(actual: any, msg?: string, ...args: any[]): assert\n\tnotFn(actual: any, msg?: string, ...args: any[]): assert\n\tnotPrimitive(actual: any, msg?: string, ...args: any[]): assert\n\tnotBoolean(actual: any, msg?: string, ...args: any[]): assert\n\tnotNumber(actual: any, msg?: string, ...args: any[]): assert\n\tnotString(actual: any, msg?: string, ...args: any[]): assert\n\tnotDate(actual: any, msg?: string, ...args: any[]): assert\n\tnotReg(actual: any, msg?: string, ...args: any[]): assert\n\tnotArray(actual: any, msg?: string, ...args: any[]): assert\n\tnotTypedArray(actual: any, msg?: string, ...args: any[]): assert\n\tnotArrayLike(actual: any, msg?: string, ...args: any[]): assert\n\tnotObj(actual: any, msg?: string, ...args: any[]): assert\n\tnotNan(actual: any, msg?: string, ...args: any[]): assert\n\tnotFinite(actual: any, msg?: string, ...args: any[]): assert\n\tthrow(fn: () => any, err: Error | string, msg?: string, ...args: any[]): assert\n\tnotThrow(fn: () => any, err: Error | string, msg?: string, ...args: any[]): assert\n\tnotLess(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\tnotGreater(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\tnotMatch(actual: string, expect: any, msg?: string, ...args: any[]): assert\n\tnotRange(actual: number, start: number, end: number, msg?: string, ...args: any[]): assert\n}\n\nexport const assert = function assert(msg?: string): never {\n\tthrow new Error(parseMessage(msg || 'Error', arguments, 0))\n} as assert\n\nfunction catchErr(fn: () => any): Error {\n\ttry {\n\t\tfn()\n\t} catch (e) {\n\t\treturn e\n\t}\n}\n\nfunction checkErr(expect: Error | string, err: Error): boolean {\n\tlet msg = isStr(expect) ? (expect as string) : (expect as Error).message\n\treturn msg === err.message\n}\nconst ERROR = new Error()\nconst throwMsg = mkMsg(objFormatter(1), 'throw')\nassert.throw = function(fn: () => any, expect: Error | string, msg?: string): assert {\n\tconst err = catchErr(fn)\n\tif (!err || (expect && !checkErr(expect, err))) {\n\t\targuments[0] = err\n\t\t!expect && (arguments[2] = ERROR)\n\t\tthrow new Error(parseMessage(msg || throwMsg[0], arguments, 2))\n\t}\n\treturn assert\n}\n\nassert.notThrow = function(fn: () => any, expect: Error | string, msg?: string): assert {\n\tconst err = catchErr(fn)\n\tif (err && (!expect || !checkErr(expect, err))) {\n\t\targuments[0] = err\n\t\t!expect && (arguments[2] = ERROR)\n\t\tthrow new Error(parseMessage(msg || throwMsg[0], arguments, 2))\n\t}\n\treturn assert\n}\n\nfunction extendAssert<T extends Function>(\n\tname: string,\n\tcondition: string | ((...args: any) => boolean) | [string | ((...args: any) => boolean), string?],\n\targs: string | number | string[],\n\tdmsg: string,\n\tErr?: { new (message?: string): Error }\n): T {\n\tconst params: string[] = isStr(args)\n\t\t\t? (args as string).split(/,/g)\n\t\t\t: isNum(args)\n\t\t\t? makeArray(args as number, i => `arg${i + 1}`)\n\t\t\t: (args as string[]),\n\t\tparamStr = params.join(', '),\n\t\tcond = isArray(condition) ? condition[0] : condition,\n\t\texpr = (isArray(condition) ? condition[1] : '') + (isStr(cond) ? `(${cond})` : `cond(${paramStr})`)\n\n\treturn (assert[name] = createFn(\n\t\t`return function assert${upperFirst(name)}(${paramStr}, msg){\n\tif (${expr})\n\t\tthrow new Err(parseMsg(msg || dmsg, arguments, ${params.length}));\n\treturn assert;\n}`,\n\t\t['Err', 'parseMsg', 'dmsg', 'cond', 'assert']\n\t)(Err || Error, parseMessage, dmsg, cond, assert))\n}\n\ntype APIDescriptor = [\n\tstring | ((...args: any) => boolean), // condition\n\tstring | number | string[], // arguments\n\t[string, string], // expect or [err msg, not err msg]\n\t({ new (message?: string): Error })?\n]\n\n// [condition, argcount?, [msg, not msg], Error]\nfunction extendAsserts(apis: { [method: string]: APIDescriptor }) {\n\teachObj(apis, (desc: APIDescriptor, name) => {\n\t\tconst condition = desc[0],\n\t\t\targs = desc[1],\n\t\t\tmsg = desc[2],\n\t\t\tErr = desc[3] || TypeError\n\n\t\tmsg[0] && extendAssert(name, [condition, '!'], args, msg[0], Err)\n\t\tmsg[1] && extendAssert('not' + upperFirst(name), condition, args, msg[1], Err)\n\t})\n}\n\nconst UNDEFINED = TYPE_UNDEF,\n\tBOOLEAN = TYPE_BOOL,\n\tNUMBER = TYPE_NUM,\n\tSTRING = TYPE_STRING,\n\tFUNCTION = TYPE_FN,\n\tNULL = 'null',\n\tINTEGER = 'integer',\n\tARRAY = 'Array',\n\tTYPED_ARRAY = 'TypedArray'\n\nextendAssert('is', '!o', 'o', expectMsg('Exist'))\nextendAssert('not', 'o', 'o', expectMsg('Not Exist'))\nextendAsserts({\n\teq: [eq, 2, mkMsg(objFormatter(1))],\n\teql: [deepEq, 2, mkMsg(objFormatter(1))],\n\tnul: [isNull, 1, mkMsg(NULL)],\n\tnil: [isNil, 1, mkMsg(typeExpect(NULL, UNDEFINED))],\n\tundef: [isUndef, 1, mkMsg(UNDEFINED)],\n\tbool: [isBool, 1, mkMsg(BOOLEAN)],\n\tnum: [isNum, 1, mkMsg(NUMBER)],\n\tint: [isInt, 1, mkMsg(INTEGER)],\n\tstr: [isStr, 1, mkMsg(STRING)],\n\tfn: [isFn, 1, mkMsg(FUNCTION)],\n\tprimitive: [\n\t\tisPrimitive,\n\t\t1,\n\t\tmkMsg(`Primitive type(${typeExpect(NULL, UNDEFINED, BOOLEAN, NUMBER, INTEGER, STRING, FUNCTION)})`)\n\t],\n\tboolean: [isBoolean, 1, mkMsg(packTypeExpect(BOOLEAN))],\n\tnumber: [isNumber, 1, mkMsg(packTypeExpect(NUMBER))],\n\tstring: [isString, 1, mkMsg(packTypeExpect(STRING))],\n\tdate: [isDate, 1, mkMsg('Date')],\n\treg: [isReg, 1, mkMsg('RegExp')],\n\tarray: [isArray, 1, mkMsg(ARRAY)],\n\ttypedArray: [isTypedArray, 1, mkMsg('TypedArray')],\n\tarrayLike: [\n\t\tisArrayLike,\n\t\t1,\n\t\tmkMsg(typeExpect(ARRAY, packTypeExpect(STRING), 'Arguments', TYPED_ARRAY, 'NodeList', 'HTMLCollection'))\n\t],\n\tobj: [isObj, 1, mkMsg('Object')],\n\tnan: [isNaN, 1, mkMsg('NaN')],\n\tfinite: [isFinite, 1, mkMsg('Finite')],\n\tblank: [isBlank, 1, mkMsg('Blank')],\n\tless: ['o<t', 'o,t', mkMsg(objFormatter(1), 'less than')],\n\tgreater: ['o>t', 'o,t', mkMsg(objFormatter(1), 'greater than')],\n\tmatch: ['reg.test(str)', 'str,reg', mkMsg(objFormatter(1), 'match')],\n\trange: ['o>=s&&o<e', 'o,s,e', mkMsg(`[{1} - {2})`)]\n})\n\nfunction mkMsg(expect: string, to?: string): [string, string] {\n\treturn [expectMsg(expect, false, to), expectMsg(expect, true, to)]\n}\nfunction expectMsg(expect: string, not?: boolean, to?: string): string {\n\treturn `Expected ${objFormatter(0)} ${not ? 'not ' : ''}${to || 'to'} ${expect}`\n}\n\nfunction objFormatter(idx: number): string {\n\treturn `{${idx}:.80=\"...\"j}`\n}\n\nfunction packTypeExpect(base: string, all?: boolean): string {\n\treturn all ? typeExpect(base, upperFirst(base)) : upperFirst(base)\n}\nfunction typeExpect(...types: string[]): string\nfunction typeExpect(): string {\n\treturn Array.prototype.join.call(arguments, ' | ')\n}\n","/**\n * Double Linked List\n * @module utility/List\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Fri Mar 08 2019 18:22:58 GMT+0800 (China Standard Time)\n */\n\nimport { bind } from '../fn'\nimport { defPropValue } from '../prop'\nimport { assert } from '../assert'\nimport { EMPTY_FN } from '../consts'\n\nconst DEFAULT_BINDING = '__list__'\n\ninterface ListNode<T> extends Array<any> {\n\t0: T\n\t1?: ListNode<T>\n\t2?: ListNode<T>\n\t3?: List<T>\n\ttoJSON?: () => any\n}\n//type ListNode = [ListElement, IListNode, IListNode, List]\n\nexport class List<T> {\n\tstatic readonly binding: string = DEFAULT_BINDING\n\n\treadonly binding: string\n\tprivate __head?: ListNode<T>\n\tprivate __tail?: ListNode<T>\n\tprivate __length: number = 0\n\tprivate __scaning: boolean = false\n\tprivate __lazyRemoves?: ListNode<T>[]\n\tconstructor(binding?: string) {\n\t\tthis.binding = binding || DEFAULT_BINDING\n\t}\n\tsize(): number {\n\t\treturn this.__length\n\t}\n\thas(obj: T): boolean {\n\t\tconst node: ListNode<T> = obj[this.binding]\n\t\treturn node ? node[0] === obj && node[3] === this : false\n\t}\n\t/**\n\t *\n\t * @param obj\n\t * @return new length\n\t */\n\tadd(obj: T): number {\n\t\treturn this.__insert(obj, this.__tail)\n\t}\n\t/**\n\t *\n\t * @param obj\n\t * @return new length\n\t */\n\taddFirst(obj: T): number {\n\t\treturn this.__insert(obj)\n\t}\n\t/**\n\t *\n\t * @param obj\n\t * @return new length\n\t */\n\tinsertAfter(obj: T, target?: T): number {\n\t\treturn this.__insert(obj, target && this.__getNode(target))\n\t}\n\t/**\n\t *\n\t * @param obj\n\t * @return new length\n\t */\n\tinsertBefore(obj: T, target?: T): number {\n\t\treturn this.__insert(obj, target && this.__getNode(target)[1])\n\t}\n\t/**\n\t *\n\t * @param objs\n\t * @return new length\n\t */\n\taddAll(objs: T[]): number {\n\t\treturn this.__insertAll(objs, this.__tail)\n\t}\n\taddFirstAll(objs: T[]): number {\n\t\treturn this.__insertAll(objs)\n\t}\n\tinsertAfterAll(objs: T[], target?: T): number {\n\t\treturn this.__insertAll(objs, target && this.__getNode(target))\n\t}\n\tinsertBeforeAll(objs: T[], target?: T): number {\n\t\treturn this.__insertAll(objs, target && this.__getNode(target)[1])\n\t}\n\tprev(obj: T): T {\n\t\treturn this.__siblingObj(obj, 1)\n\t}\n\tnext(obj: T): T {\n\t\treturn this.__siblingObj(obj, 2)\n\t}\n\tfirst(): T {\n\t\tconst node: ListNode<T> = this.__head\n\t\treturn node && node[0]\n\t}\n\tlast(): T {\n\t\tconst node: ListNode<T> = this.__tail\n\t\treturn node && node[0]\n\t}\n\teach(cb: (obj: T) => boolean | void, scope?: any) {\n\t\tif (this.__length) {\n\t\t\tassert.not(this.__scaning, 'Nested calls are not allowed.')\n\t\t\tthis.__scaning = true\n\t\t\tcb = bind(cb, scope)\n\t\t\tvar node = this.__head\n\t\t\twhile (node) {\n\t\t\t\tif (node[3] === this && cb(node[0]) === false) break\n\t\t\t\tnode = node[2]\n\t\t\t}\n\t\t\tthis.__doLazyRemove()\n\t\t\tthis.__scaning = false\n\t\t}\n\t}\n\teachUnsafe(cb: (obj: T) => boolean | void, scope?: any) {\n\t\tif (this.__length) {\n\t\t\tvar node = this.__head\n\t\t\twhile (node) {\n\t\t\t\tif (node[3] === this && cb(node[0]) === false) break\n\t\t\t\tnode = node[2]\n\t\t\t}\n\t\t}\n\t}\n\ttoArray(): T[] {\n\t\tconst array: T[] = new Array(this.__length)\n\t\tlet node = this.__head,\n\t\t\ti = 0\n\t\twhile (node) {\n\t\t\tif (node[3] === this) array[i++] = node[0]\n\t\t\tnode = node[2]\n\t\t}\n\t\treturn array\n\t}\n\t/**\n\t *\n\t * @param obj\n\t * @return new length\n\t */\n\tremove(obj: T): number {\n\t\treturn this.__remove(this.__getNode(obj))\n\t}\n\tpop() {}\n\tclean() {\n\t\tif (this.__length) {\n\t\t\tif (this.__scaning) {\n\t\t\t\tvar node = this.__head\n\t\t\t\twhile (node) {\n\t\t\t\t\tnode[3] === this && this.__lazyRemove(node)\n\t\t\t\t\tnode = node[2]\n\t\t\t\t}\n\t\t\t\tthis.__length = 0\n\t\t\t} else {\n\t\t\t\tthis.__clean()\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate __initNode(obj: T): ListNode<T> {\n\t\tconst { binding } = this\n\t\tlet node: ListNode<T> = obj[binding]\n\t\tif (node && node[0] === obj) {\n\t\t\tif (node[3] === this) {\n\t\t\t\tthis.__remove(node)\n\t\t\t\treturn this.__initNode(obj)\n\t\t\t} else if (node[3]) {\n\t\t\t\tassert('Object is still in some List')\n\t\t\t}\n\t\t} else {\n\t\t\tnode = [obj]\n\t\t\tnode.toJSON = EMPTY_FN\n\t\t\tdefPropValue(obj, binding, node, false)\n\t\t}\n\t\tnode[3] = this\n\t\treturn node\n\t}\n\n\tprivate __getNode(obj: T): ListNode<T> {\n\t\tconst node: ListNode<T> = obj[this.binding]\n\t\tassert.is(node && node[3] === this, 'Object is not in this List')\n\t\treturn node\n\t}\n\n\tprivate __siblingObj(obj: T, siblingIdx: number): T {\n\t\tconst node: ListNode<T> = this.__getNode(obj)\n\t\tlet sibling: ListNode<T> = node[siblingIdx]\n\t\tif (sibling) {\n\t\t\twhile (!sibling[3]) {\n\t\t\t\tsibling = sibling[siblingIdx]\n\t\t\t\tif (!sibling) return\n\t\t\t}\n\t\t\treturn sibling[0]\n\t\t}\n\t}\n\n\tprivate __doInsert(nodeHead: ListNode<T>, nodeTail: ListNode<T>, len: number, prev?: ListNode<T>): number {\n\t\tlet next: ListNode<T>\n\t\tnodeHead[1] = prev\n\t\tif (prev) {\n\t\t\tnodeTail[2] = next = prev[2]\n\t\t\tprev[2] = nodeHead\n\t\t} else {\n\t\t\tnodeTail[2] = next = this.__head\n\t\t\tthis.__head = nodeHead\n\t\t}\n\t\tif (next) next[1] = nodeTail\n\t\telse this.__tail = nodeTail\n\t\treturn (this.__length += len)\n\t}\n\n\tprivate __insert(obj: T, prev?: ListNode<T>): number {\n\t\tconst node = this.__initNode(obj)\n\t\treturn this.__doInsert(node, node, 1, prev)\n\t}\n\n\tprivate __insertAll(objs: T[], prev?: ListNode<T>): number {\n\t\tlet l = objs.length\n\t\tif (l) {\n\t\t\tconst head = this.__initNode(objs[0])\n\t\t\tvar __prev = head,\n\t\t\t\ttail = head,\n\t\t\t\ti = 1\n\t\t\tfor (; i < l; i++) {\n\t\t\t\ttail = this.__initNode(objs[i])\n\t\t\t\ttail[1] = __prev\n\t\t\t\t__prev[2] = tail\n\t\t\t\t__prev = tail\n\t\t\t}\n\t\t\treturn this.__doInsert(head, tail, l, prev)\n\t\t}\n\t\treturn -1\n\t}\n\n\tprivate __remove(node: ListNode<T>): number {\n\t\tthis.__scaning ? this.__lazyRemove(node) : this.__doRemove(node)\n\t\treturn --this.__length\n\t}\n\n\tprivate __lazyRemove(node: ListNode<T>): void {\n\t\tconst { __lazyRemoves: lazyRemoves } = this\n\t\tnode[0][this.binding] = undefined // unbind this node\n\t\tnode[3] = null\n\t\tif (lazyRemoves) {\n\t\t\tlazyRemoves.push(node)\n\t\t} else {\n\t\t\tthis.__lazyRemoves = [node]\n\t\t}\n\t}\n\n\tprivate __doLazyRemove() {\n\t\tconst { __lazyRemoves: lazyRemoves } = this\n\t\tif (lazyRemoves) {\n\t\t\tvar len = lazyRemoves.length\n\t\t\tif (len) {\n\t\t\t\tif (this.__length) {\n\t\t\t\t\twhile (len--) this.__doRemove(lazyRemoves[len])\n\t\t\t\t} else {\n\t\t\t\t\tthis.__clean()\n\t\t\t\t}\n\t\t\t\tlazyRemoves.length = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate __doRemove(node: ListNode<T>) {\n\t\tconst prev = node[1],\n\t\t\tnext = node[2]\n\t\tif (prev) {\n\t\t\tprev[2] = next\n\t\t} else {\n\t\t\tthis.__head = next\n\t\t}\n\t\tif (next) {\n\t\t\tnext[1] = prev\n\t\t} else {\n\t\t\tthis.__tail = prev\n\t\t}\n\t\tnode[1] = node[2] = node[3] = null\n\t}\n\n\tprivate __clean() {\n\t\tlet node: ListNode<T>,\n\t\t\tnext = this.__head\n\t\twhile ((node = next)) {\n\t\t\tnext = node[2]\n\t\t\tnode.length = 1\n\t\t}\n\t\tthis.__head = undefined\n\t\tthis.__tail = undefined\n\t\tthis.__length = 0\n\t}\n}\n","/**\n * Function List\n * @module utility/List\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Fri Mar 08 2019 18:24:33 GMT+0800 (China Standard Time)\n */\n\nimport { List } from './List'\nimport { create } from '../create'\nimport { defPropValue } from '../prop'\n\nconst DEFAULT_FN_BINDING = '__flist_id__'\nconst DEFAULT_SCOPE_BINDING = DEFAULT_FN_BINDING\n\ntype FnNode<T extends Function> = [string, T, any, any]\nexport class FnList<T extends Function> {\n\tstatic readonly fnBinding: string = DEFAULT_FN_BINDING\n\tstatic readonly scopeBinding: string = DEFAULT_SCOPE_BINDING\n\n\treadonly fnBinding: string\n\treadonly scopeBinding: string\n\tprivate readonly __list: List<FnNode<T>>\n\tprivate __nodeMap: { [key: string]: FnNode<T> }\n\n\tconstructor(fnBinding?: string, scopeBinding?: string) {\n\t\tthis.__nodeMap = create(null)\n\t\tthis.__list = new List()\n\t\tthis.fnBinding = fnBinding || DEFAULT_FN_BINDING\n\t\tthis.scopeBinding = scopeBinding || DEFAULT_SCOPE_BINDING\n\t}\n\t/**\n\t * add executable function\n\t * @param fn\t\tfunction\n\t * @param scope\t\tscope of function\n\t * @param data\t\tuser data of [function + scope]\n\t * @return executable function id, can remove executable function by id: {@link FnList#removeId}\n\t */\n\tadd(fn: T, scope?: any, data?: any): string {\n\t\tscope = parseScope(scope)\n\t\tconst { __list: list, __nodeMap: nodeMap } = this\n\t\tconst id = this.id(fn, scope)\n\t\tlet node = nodeMap[id]\n\t\tif (!node) {\n\t\t\tnode = [id, fn, scope, data]\n\t\t\tif (list.add(node)) nodeMap[id] = node\n\t\t\treturn id\n\t\t}\n\t}\n\n\t/**\n\t * remove executable function by id\n\t *\n\t * @param id\n\t */\n\tremoveId(id: string): number {\n\t\tconst { __list: list, __nodeMap: nodeMap } = this\n\t\tconst node = nodeMap[id]\n\t\tif (node) {\n\t\t\tnodeMap[id] = undefined\n\t\t\treturn list.remove(node)\n\t\t}\n\t\treturn -1\n\t}\n\tremove(fn: T, scope?: any): number {\n\t\treturn this.removeId(this.id(fn, parseScope(scope)))\n\t}\n\thas(fn: T, scope?: any): boolean {\n\t\treturn !!this.__nodeMap[this.id(fn, parseScope(scope))]\n\t}\n\tsize(): number {\n\t\treturn this.__list.size()\n\t}\n\tclean() {\n\t\tthis.__nodeMap = create(null)\n\t\tthis.__list.clean()\n\t}\n\teach(cb: (fn: T, scope: any, data: any, __node: FnNode<T>) => boolean | void, scope?: any) {\n\t\tcb = cb.bind(scope)\n\t\tthis.__list.each(node => cb(node[1], node[2], node[3], node))\n\t}\n\teachUnsafe(cb: (fn: T, scope: any, data: any, __node: FnNode<T>) => boolean | void, scope?: any) {\n\t\tthis.__list.eachUnsafe(node => cb(node[1], node[2], node[3], node))\n\t}\n\tid(fn: T, scope?: any): string {\n\t\tconst { fnBinding, scopeBinding } = this\n\n\t\tlet fnId = fn[fnBinding],\n\t\t\tscopeId = scope ? scope[scopeBinding] : DEFAULT_SCOPE_ID\n\t\tif (!fnId) fnId = defPropValue(fn, fnBinding, ++fnIdGenerator, false, false, false)\n\t\tif (!scopeId) scopeId = defPropValue(scope, scopeBinding, ++scopeIdGenerator, false, false, false)\n\t\treturn `${fnId}#${scopeId}`\n\t}\n}\n\nconst DEFAULT_SCOPE_ID = 1\nlet scopeIdGenerator = 1,\n\tfnIdGenerator = 0\n\nfunction parseScope(scope: any): any {\n\treturn !scope ? undefined : scope\n}\n","/**\n * String format\n * @module utility/nextTick\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Thu Jan 31 2019 16:34:55 GMT+0800 (China Standard Time)\n */\nimport { FnList } from './List'\nimport { TYPE_FN } from './consts'\n\nconst ticks = new FnList()\nlet pending = false\nlet next: () => void\n\nfunction executeTick(fn: Function, scope?: any) {\n\tscope ? fn.call(scope) : fn()\n}\n\nfunction flush() {\n\tticks.each(executeTick)\n\tticks.clean()\n\tpending = false\n}\n\nif (typeof MutationObserver === TYPE_FN) {\n\t// chrome18+, safari6+, firefox14+,ie11+,opera15\n\tvar counter = 0,\n\t\tobserver = new MutationObserver(flush),\n\t\ttextNode = document.createTextNode(counter + '')\n\tobserver.observe(textNode, {\n\t\tcharacterData: true\n\t})\n\tnext = function() {\n\t\ttextNode.data = counter + ''\n\t\tcounter = counter ? 0 : 1\n\t}\n} else {\n\tnext = function() {\n\t\tsetTimeout(flush, 0)\n\t}\n}\n\nexport function nextTick(fn: Function, scope?: any) {\n\tticks.add(fn, scope)\n\tif (!pending) {\n\t\tpending = true\n\t\tnext()\n\t}\n}\n\nexport function clearTick(fn: Function, scope?: any) {\n\tticks.remove(fn, scope)\n}\n","/**\n * @module utility/Source\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 17 2018 10:41:21 GMT+0800 (China Standard Time)\n * @modified Sat Dec 22 2018 14:37:32 GMT+0800 (China Standard Time)\n */\n\nimport { pad } from './format'\nimport { escapeStr } from './string'\n\nconst LINE_REG = /([^\\n]+)?(\\n|$)/g\nexport class Source {\n\treadonly buff: string\n\treadonly len: number\n\tprivate __lines: ([number, string])[]\n\tprivate __linePos: number\n\tconstructor(buff: string) {\n\t\tthis.buff = buff\n\t\tthis.len = buff.length\n\t\tthis.__lines = []\n\t\tthis.__linePos = 0\n\t}\n\tposition(offset: number): [number, number, string] {\n\t\tconst { buff, len, __lines: lines, __linePos: linePos } = this\n\t\tlet i = lines.length,\n\t\t\tp: number\n\t\tif (offset < linePos) {\n\t\t\twhile (i--) {\n\t\t\t\tp = offset - lines[i][0]\n\t\t\t\tif (p >= 0) return [i + 1, p, lines[i][1]]\n\t\t\t}\n\t\t} else {\n\t\t\tif (linePos < len) {\n\t\t\t\tvar m: string[]\n\t\t\t\tLINE_REG.lastIndex = p = linePos\n\t\t\t\twhile ((m = LINE_REG.exec(buff))) {\n\t\t\t\t\tlines[i++] = [p, m[1] || '']\n\t\t\t\t\tp = LINE_REG.lastIndex\n\t\t\t\t\tif (!p || offset < p) break\n\t\t\t\t}\n\t\t\t\tthis.__linePos = p || len\n\t\t\t}\n\t\t\treturn i ? [i, (offset > len ? len : offset) - lines[i - 1][0], lines[i - 1][1]] : [1, 0, '']\n\t\t}\n\t}\n\tsource(escape?: boolean): string {\n\t\tconst { buff } = this\n\t\tlet line = 1,\n\t\t\ttoSourceStr = escape ? escapeSourceStr : sourceStr\n\n\t\treturn buff.replace(LINE_REG, (m, s, t) => pad(String(line++), 3) + ': ' + toSourceStr(m, s, t))\n\t}\n}\n\nfunction sourceStr(m: string, s: string, t: string) {\n\treturn m || ''\n}\n\nfunction escapeSourceStr(m: string, s: string, t: string) {\n\treturn s ? escapeStr(s) + t : t\n}\n","/**\n * utilities for ast builder\n *\n * @module utility/AST\n * @author Tao Zeng (tao.zeng.zt@qq.com)\n * @created 2018-11-09 13:22:51\n * @modified 2018-11-09 13:22:51 by Tao Zeng (tao.zeng.zt@qq.com)\n */\nimport { isStr, isArray, isInt, isNum } from '../is'\nimport { charCode } from '../string'\n\nexport function genCharCodes(start: number | string, end: number | string, ignoreCase?: boolean) {\n\tlet s: number = isNum(start) ? (start as number) : charCode(start as string),\n\t\te: number = isNum(end) ? (end as number) : charCode(end as string),\n\t\tcodes: number[] = new Array(e - s),\n\t\ti = 0\n\tif (ignoreCase) {\n\t\tvar c: number\n\t\tfor (; s <= e; s++) {\n\t\t\tcodes[i++] = s\n\t\t\tc = getAnotherCode(s)\n\t\t\tcodes[i++] = c\n\t\t}\n\t} else {\n\t\tfor (; s <= e; s++) codes[i++] = s\n\t}\n\treturn codes\n}\n\n/**\n * each char codes\n */\nexport function eachCharCodes(codes: number | string | any[], ignoreCase: boolean, cb: (code: number) => void) {\n\tlet i: number\n\tif (isStr(codes)) {\n\t\ti = (codes as any).length\n\t\twhile (i--) eachCharCode(charCode(codes as any, i), ignoreCase, cb)\n\t} else if (isArray(codes)) {\n\t\ti = (codes as any).length\n\t\twhile (i--) eachCharCodes((codes as any)[i], ignoreCase, cb)\n\t} else if (isInt(codes)) {\n\t\teachCharCode(codes as any, ignoreCase, cb)\n\t}\n}\nfunction eachCharCode(code: number, ignoreCase: boolean, cb: (code: number) => void): void {\n\tcb(code)\n\tif (ignoreCase) {\n\t\tvar c = getAnotherCode(code)\n\t\tc && cb(c)\n\t}\n}\n\nfunction getAnotherCode(code: number) {\n\treturn code <= 90 ? (code >= 65 ? code + 32 : 0) : code <= 122 ? code - 32 : 0\n}\n","/**\n * @module utility/mixin\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 18 2018 16:41:03 GMT+0800 (China Standard Time)\n * @modified Fri Dec 21 2018 10:24:24 GMT+0800 (China Standard Time)\n */\n\nimport { hasOwnProp } from './prop'\n\nexport function mixin<B>(behaviour: B) {\n\treturn function mixin<M extends B, T extends { new (...args: Array<any>): M }>(Class: T) {\n\t\tconst proto = Class.prototype\n\t\tfor (var k in behaviour) if (hasOwnProp(behaviour, k)) proto[k] = behaviour[k]\n\t\treturn Class\n\t}\n}\n","/**\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:06:22 GMT+0800 (China Standard Time)\n * @modified Sat Dec 22 2018 17:53:14 GMT+0800 (China Standard Time)\n */\nimport { MatchContext } from './MatchContext'\nimport { eachCharCodes } from './util'\nimport { assert } from '../assert'\nimport { isBool } from '../is'\nimport { mixin } from '../mixin'\n\n@mixin({ $ruleErr: true })\nexport class MatchError {\n\treadonly $ruleErr: boolean\n\treadonly rule: Rule\n\treadonly context: MatchContext\n\treadonly source: MatchError\n\treadonly target: MatchError\n\tcapturable: boolean\n\treadonly pos: number\n\tmsg: string\n\tconstructor(msg: string, capturable: boolean, source: MatchError, context: MatchContext, rule: Rule) {\n\t\t!isBool(capturable) && (capturable = rule.capturable)\n\t\tthis.capturable = capturable && source ? source.capturable : capturable\n\t\tthis.msg = msg\n\t\tthis.source = source\n\t\tthis.target = source ? source.target : this\n\t\tthis.context = context\n\t\tthis.rule = rule\n\t\tthis.pos = context.startPos()\n\t}\n\tposition(): [number, number, string] {\n\t\treturn this.context.source.position(this.pos)\n\t}\n}\n\nexport type onMatchCallback = (data: any, len: number, context: MatchContext, rule: Rule) => MatchError | string | void\nexport type onErrorCallback = (err: MatchError, context: MatchContext, rule: Rule) => MatchError | string | void\n\nfunction defaultErr(err: MatchError) {\n\treturn err\n}\n\nfunction defaultMatch(data: any, len: number, context: MatchContext) {\n\tcontext.add(data)\n}\n\nexport type RuleOptions = {\n\t/**\n\t * error is capturable\n\t */\n\tcapturable?: boolean\n\t/**\n\t * matched callback\n\t */\n\tmatch?: (data: any, len: number, context: MatchContext, rule: Rule) => MatchError | string | void\n\t/**\n\t * error callback\n\t */\n\terr?: (err: MatchError, context: MatchContext, rule: Rule) => MatchError | string | void\n}\n\nlet idGen = 0\n/**\n * Abstract Rule\n */\n@mixin({ $rule: true })\nexport class Rule {\n\treadonly $rule: boolean\n\t// rule type (for debug)\n\ttype: string\n\t// rule id\n\treadonly id: number\n\t// rule name\n\treadonly name: string\n\t// error is capturable\n\treadonly capturable: boolean\n\t// rule expression (for debug)\n\tprotected expr: string\n\t// rule EXPECT content (for debug)\n\tprotected EXPECT: string\n\t// matched callback\n\treadonly onMatch: onMatchCallback\n\t// error callback\n\treadonly onErr: onErrorCallback\n\t// index of start codes\n\tprotected startCodeIdx: any[]\n\t// start codes\n\tprotected startCodes: number[]\n\n\t/**\n\t * @param name\t\t\trule name\n\t * @param capturable\terror is capturable\n\t * @param onMatch\t\tcallback on matched, allow modify the match result or return an error\n\t * @param onErr\t\t\tcallback on Error, allow to ignore error or modify error message or return new error\n\t */\n\tconstructor(name: string, options: RuleOptions) {\n\t\tthis.id = idGen++\n\t\tthis.name = name\n\t\tthis.capturable = options.capturable !== false\n\t\tthis.onMatch = options.match || defaultMatch\n\t\tthis.onErr = options.err || defaultErr\n\t}\n\n\t/**\n\t * create Error\n\t * @param msg \t\t\terror message\n\t * @param context \t\tmatch context\n\t * @param capturable \tis capturable error\n\t * @param src \t\t\tsource error\n\t */\n\tmkErr(msg: string, context: MatchContext, capturable?: boolean, source?: MatchError): MatchError {\n\t\treturn new MatchError(msg, capturable, source, context, this)\n\t}\n\n\t/**\n\t * match fail\n\t * @param msg \t\t\terror message\n\t * @param context \t\tmatch context\n\t * @param capturable \tis capturable error\n\t * @param src \t\t\tsource error\n\t * @return Error|void: may ignore Error in the error callback\n\t */\n\tprotected error(msg: string, context: MatchContext, src?: MatchError, capturable?: boolean): MatchError {\n\t\tconst err = this.mkErr(msg, context, capturable, src)\n\t\tconst userErr = this.onErr(err, context, this)\n\t\tif (userErr) return (userErr as any).$ruleErr ? (userErr as MatchError) : ((err[0] = String(userErr)), err)\n\t}\n\n\t/**\n\t * match success\n\t * > attach the matched result by match callback\n\t * @param data \t\tmatched data\n\t * @param len  \t\tmatched data length\n\t * @param context \tmatch context\n\t * @return Error|void: may return Error in the match callback\n\t */\n\tprotected matched(data: any, len: number, context: MatchContext): MatchError {\n\t\tconst err = this.onMatch(data, len, context, this)\n\t\tif (err) return (err as any).$ruleErr ? (err as MatchError) : this.mkErr(String(err), context, false)\n\t}\n\n\tprotected enter(context: MatchContext) {\n\t\treturn context.create()\n\t}\n\n\t/**\n\t * match\n\t * @param context match context\n\t */\n\tmatch(context: MatchContext): MatchError {\n\t\treturn assert()\n\t}\n\n\t/**\n\t * get start char codes\n\t */\n\tgetStart(stack?: number[]): number[] {\n\t\treturn this.startCodes\n\t}\n\n\t/**\n\t * prepare test before match\n\t */\n\ttest(context: MatchContext): boolean {\n\t\treturn true\n\t}\n\n\tprotected startCodeTest(context: MatchContext): boolean {\n\t\treturn this.startCodeIdx[context.nextCode()]\n\t}\n\n\tprotected setStartCodes(start: number | string | any[], ignoreCase?: boolean) {\n\t\tconst codes: number[] = [],\n\t\t\tindex: number[] = []\n\t\teachCharCodes(start, ignoreCase, code => {\n\t\t\tif (!index[code]) {\n\t\t\t\tcodes.push(code)\n\t\t\t\tindex[code] = code\n\t\t\t}\n\t\t})\n\t\tthis.startCodes = codes\n\t\tthis.setCodeIdx(index)\n\t}\n\n\tprotected setCodeIdx(index: any[]) {\n\t\tif (index.length > 1) {\n\t\t\tthis.startCodeIdx = index\n\t\t\tthis.test = this.startCodeTest\n\t\t}\n\t}\n\n\t// for debug \n\t/**\n\t * make rule expression\n\t * @param expr expression text\n\t */\n\tprotected mkExpr(expr: string): string {\n\t\treturn `<${this.type}: ${expr}>`\n\t}\n\n\t/**\n\t * set rule expression\n\t * \t\t1. make rule expression\n\t * \t\t2. make Expect text\n\t */\n\tprotected setExpr(expr: string) {\n\t\tthis.expr = this.mkExpr(expr)\n\t\tthis.EXPECT = `Expect: ${expr}`\n\t}\n\n\tgetExpr(stack?: number[]): string {\n\t\treturn this.name || this.expr\n\t}\n\n\t/**\n\t * toString by name or expression\n\t */\n\ttoString(): string {\n\t\treturn this.getExpr()\n\t}\n}\n","/**\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:06:22 GMT+0800 (China Standard Time)\n * @modified Sat Dec 22 2018 15:11:19 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, MatchError, RuleOptions } from './Rule'\nimport { MatchContext } from './MatchContext'\n\n/**\n * Match Rule Interface\n */\nexport class MatchRule extends Rule {\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param start \t\tstart char codes, prepare test by start char codes before match\n\t * @param ignoreCase\tignore case for the start char codes\n\t * @param options\t\tRule Options\n\t */\n\tconstructor(name: string, start: number | string | any[], ignoreCase: boolean, options: RuleOptions) {\n\t\tsuper(name, options)\n\t\tthis.setStartCodes(start, ignoreCase)\n\t}\n\n\t/**\n\t * consume matched result\n\t * @param data \t\tmatched result\n\t * @param len \t\tmatched chars\n\t * @param context \tmatch context\n\t */\n\tcomsume(data: string | string[], len: number, context: MatchContext): MatchError {\n\t\tcontext.advance(len)\n\t\treturn this.matched(data, len, context)\n\t}\n}\n","/**\n *\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 11 2018 15:36:42 GMT+0800 (China Standard Time)\n * @modified Sat Dec 22 2018 14:53:49 GMT+0800 (China Standard Time)\n */\n\nimport { RuleOptions } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { MatchRule } from './MatchRule'\nimport { char } from '../string'\nimport { mixin } from '../mixin'\n\n/**\n * match a character in the allowed list\n * > well match any character if the allowed list is empty\n *\n * > must call test() before match\n */\n@mixin({ type: 'Character' })\nexport class CharMatchRule extends MatchRule {\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param allows \t\tallowed character codes for match\n\t * \t\t\t\t\t\twell match any character if the allowed list is empty\n\t * @param ignoreCase\tignore case for the allowed character codes\n\t * @param options\t\tRule Options\n\t */\n\tconstructor(name: string, allows: number | string | any[], ignoreCase: boolean, options: RuleOptions) {\n\t\tsuper(name, allows, ignoreCase, options)\n\n\t\t// generate expression for debug\n\t\tconst codes = this.startCodes\n\t\tlet i = codes.length,\n\t\t\texpr = '*'\n\t\tif (i) {\n\t\t\tconst chars = []\n\t\t\twhile (i--) chars[i] = char(codes[i])\n\t\t\texpr = `\"${chars.join('\" | \"')}\"`\n\t\t}\n\t\tthis.setExpr(expr)\n\t}\n\tmatch(context: MatchContext) {\n\t\treturn this.comsume(context.nextChar(), 1, context)\n\t}\n}\n","/**\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 11 2018 15:36:42 GMT+0800 (China Standard Time)\n * @modified Fri Dec 28 2018 20:09:06 GMT+0800 (China Standard Time)\n */\n\nimport { MatchError, RuleOptions } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { MatchRule } from './MatchRule'\nimport { stickyReg } from '../reg'\nimport { isInt } from '../is'\nimport { createFn } from '../fn'\nimport { mapArray } from '../collection'\nimport { mixin } from '../mixin'\nimport { create } from '../create'\nimport { cutLStr } from '../string'\n\n/**\n * match string by RegExp\n *\n * optimization:\n * - Priority use sticky mode {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky}\n *\n */\n@mixin({ type: 'RegExp' })\nexport class RegMatchRule extends MatchRule {\n\treadonly regexp: RegExp\n\treadonly pick: boolean | number\n\tprivate picker: (m: string[]) => string | string[]\n\tprivate spicker: (buff: string, start: number, end: number) => string\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param regexp\t\tregular\n\t * @param pick\t\t\tpick regular matching results\n\t * \t\t\t\t\t\t    0: pick results[0] (optimize: test and substring in sticky mode)\n\t * \t\t\t\t\t\t  > 0: pick results[{pick}]\n\t * \t\t\t\t\t\t  < 0: pick first non-blank string from 1 to -{pick} index on results\n\t * \t\t\t\t\t\t true: pick results\n\t * \t\t\t\t\t\tfalse: not pick result, result is null (optimize: just test string in sticky mode)\n\t * @param start\t\t\tstart character codes in the regular, optimize performance by start character codes\n\t * @param capturable\terror is capturable\n\t * @param onMatch\t\tmatch callback\n\t * @param onErr\t\t\terror callback\n\t */\n\tconstructor(\n\t\tname: string,\n\t\tregexp: RegExp,\n\t\tpick: boolean | number,\n\t\tstart: number | string | any[],\n\t\toptions: RuleOptions\n\t) {\n\t\tpick = pick === false || isInt(pick) ? pick : !!pick || 0\n\n\t\tconst sticky = stickyReg && !pick, // use exec mode when need pick match group data\n\t\t\tpattern = regexp.source,\n\t\t\tignoreCase = regexp.ignoreCase\n\n\t\t// always wrapping in a none capturing group preceded by '^' to make sure\n\t\t// matching can only work on start of input. duplicate/redundant start of\n\t\t// input markers have no meaning (/^^^^A/ === /^A/)\n\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky\n\t\t// When the y flag is used with a pattern, ^ always matches only at the\n\t\t// beginning of the input, or (if multiline is true) at the beginning of a\n\t\t// line.\n\t\tregexp = new RegExp(\n\t\t\tsticky ? pattern : `^(?:${pattern})`,\n\t\t\t(ignoreCase ? 'i' : '') + (regexp.multiline ? 'm' : '') + (sticky ? 'y' : '')\n\t\t)\n\n\t\tsuper(name, start, ignoreCase, options)\n\n\t\tthis.regexp = regexp\n\t\tthis.pick = pick\n\t\tthis.match = sticky ? this.stickyMatch : this.execMatch\n\n\t\tsticky ? (this.spicker = pick === false ? pickNone : pickTestStr) : (this.picker = mkPicker(pick))\n\n\t\tthis.setExpr(pattern)\n\t}\n\t/**\n\t * match on sticky mode\n\t */\n\tstickyMatch(context: MatchContext): MatchError {\n\t\tconst reg = this.regexp,\n\t\t\tbuff = context.buff(),\n\t\t\tstart = context.offset()\n\t\treg.lastIndex = start\n\t\tlet len: number\n\t\treturn reg.test(buff)\n\t\t\t? ((len = reg.lastIndex - start), this.comsume(this.spicker(buff, start, len), len, context))\n\t\t\t: this.error(this.EXPECT, context)\n\t}\n\t/**\n\t * match on exec mode\n\t */\n\texecMatch(context: MatchContext): MatchError {\n\t\tconst m = this.regexp.exec(context.buff(true))\n\t\treturn m ? this.comsume(this.picker(m), m[0].length, context) : this.error(this.EXPECT, context)\n\t}\n}\n\nconst cache = create(null)\nfunction mkPicker(pick: number | boolean): (m: string[]) => string | string[] {\n\treturn (\n\t\tcache[pick as any] ||\n\t\t(cache[pick as any] =\n\t\t\tpick === false\n\t\t\t\t? pickNone\n\t\t\t\t: pick === true\n\t\t\t\t? pickAll\n\t\t\t\t: pick >= 0\n\t\t\t\t? createFn(`return m[${pick}]`, ['m'], `pick_${pick}`)\n\t\t\t\t: createFn(\n\t\t\t\t\t\t`return ${mapArray(new Array(-pick), (v, i) => `m[${i + 1}]`).join(' || ')}`,\n\t\t\t\t\t\t['m'],\n\t\t\t\t\t\t`pick_1_${-pick}`\n\t\t\t\t  ))\n\t)\n}\n\nfunction pickNone(): string {\n\treturn null\n}\n\nfunction pickAll(m: string[]): string[] {\n\treturn m\n}\n\nfunction pickTestStr(buff: string, start: number, end: number): string {\n\treturn cutLStr(buff, start, end)\n}\n","/**\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 11 2018 15:36:42 GMT+0800 (China Standard Time)\n * @modified Sat Dec 22 2018 15:10:52 GMT+0800 (China Standard Time)\n */\n\nimport { RuleOptions } from './Rule'\nimport { RegMatchRule } from './RegMatchRule'\nimport { reEscape } from '../reg'\nimport { mixin } from '../mixin'\nimport { charCode } from '../string'\n\n@mixin({ type: 'String' })\nexport class StringMatchRule extends RegMatchRule {\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param str \t\t\tmatch string\n\t * @param ignoreCase\tignore case\n\t * @param options\t\tRule Options\n\t */\n\tconstructor(name: string, str: string, ignoreCase: boolean, options: RuleOptions) {\n\t\tsuper(name, new RegExp(reEscape(str), ignoreCase ? 'i' : ''), 0, charCode(str), options)\n\t\tthis.setExpr(str)\n\t}\n}\n","/**\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 11 2018 15:36:42 GMT+0800 (China Standard Time)\n * @modified Sat Dec 22 2018 16:32:31 GMT+0800 (China Standard Time)\n */\nimport { Source } from '../Source'\nimport { char, charCode, cutStr } from '../string'\nimport { assert } from '../assert'\n\nexport type CheckPoint = [number, number]\n/**\n * Match Context of Rule\n */\nexport class MatchContext {\n\t// start offset of original buff\n\treadonly source: Source\n\n\t// parent context\n\treadonly parent: MatchContext\n\n\t// matched result list\n\tresult: any[]\n\n\tdata: any\n\n\t// template buff\n\tprivate __buff: string\n\n\t// current offset of template buff\n\tprivate __offset: number\n\n\t// current offset of original buff\n\tprivate __orgOffset: number\n\n\t// advanced characters\n\tprivate __advanced: number\n\n\t// cached character\n\tprivate __code: number\n\n\tconstructor(source: Source, buff: string, offset: number, orgOffset: number, parent?: MatchContext) {\n\t\tthis.source = source\n\t\tthis.parent = parent\n\t\tthis.result = []\n\t\tthis.__buff = buff\n\t\tthis.__offset = offset\n\t\tthis.__orgOffset = orgOffset\n\t\tthis.__advanced = 0\n\t\tparent ? ((this.__code = parent.__code), (this.data = parent.data)) : this.__flushCode()\n\t}\n\n\tprivate __flushCode() {\n\t\tconst { __buff: buff, __offset: offset } = this\n\t\tthis.__code = offset < buff.length ? charCode(buff, offset) : 0\n\t}\n\n\t/**\n\t * create sub Context\n\t */\n\tcreate() {\n\t\treturn new MatchContext(this.source, this.__buff, this.__offset, this.__orgOffset + this.__advanced, this)\n\t}\n\n\tprivate __setAdvanced(advanced: number) {\n\t\tassert.notLess(advanced, 0)\n\n\t\tconst offset = this.__offset - this.__advanced + advanced\n\t\tif (offset < 0) {\n\t\t\tthis.__buff = this.source.buff\n\t\t\tthis.__offset = this.__orgOffset + advanced\n\t\t}\n\t\tthis.__advanced = advanced\n\t\tthis.__offset = offset\n\t\tthis.__flushCode()\n\t}\n\n\t/**\n\t * commit context state to parent context\n\t */\n\tcommit() {\n\t\tconst { __advanced: advanced } = this\n\t\tthis.parent.advance(advanced)\n\t\tthis.__orgOffset += advanced\n\t\tthis.__advanced = 0\n\t\tthis.data = null\n\t}\n\n\t/**\n\t * marge context state\n\t */\n\tmargeState(context: MatchContext) {\n\t\tthis.__setAdvanced(context.__orgOffset + context.__advanced - this.__orgOffset)\n\t}\n\n\t/**\n\t * rollback state and result\n\t * @param checkpoint \trollback to checkpoint\n\t */\n\trollback(checkpoint?: CheckPoint) {\n\t\tlet advanced = 0,\n\t\t\tresultLen = 0\n\n\t\tcheckpoint && ((advanced = checkpoint[0]), (resultLen = checkpoint[1]))\n\n\t\tthis.__setAdvanced(advanced)\n\n\t\tconst { result } = this\n\t\tif (result.length > resultLen) result.length = resultLen\n\t}\n\n\t/**\n\t * get a check point\n\t */\n\tcheckpoint(): CheckPoint {\n\t\treturn [this.__advanced, this.result.length]\n\t}\n\n\t/**\n\t * advance buffer position\n\t */\n\tadvance(i: number) {\n\t\tthis.__offset += i\n\t\tthis.__advanced += i\n\t\tthis.__flushCode()\n\t}\n\n\t/**\n\t * advanced buff length\n\t */\n\tadvanced(): number {\n\t\treturn this.__advanced\n\t}\n\n\t/**\n\t * get buffer\n\t * @param reset reset buffer string from 0\n\t */\n\tbuff(reset?: boolean): string {\n\t\tlet { __buff: buff } = this\n\t\tif (reset) {\n\t\t\tthis.__buff = buff = cutStr(buff, this.__offset)\n\t\t\tthis.__offset = 0\n\t\t}\n\t\treturn buff\n\t}\n\n\torgBuff() {\n\t\treturn this.source.buff\n\t}\n\n\toffset(): number {\n\t\treturn this.__offset\n\t}\n\n\tstartPos(): number {\n\t\treturn this.__orgOffset\n\t}\n\n\tcurrPos(): number {\n\t\treturn this.__orgOffset + this.__advanced\n\t}\n\n\tpos(): [number, number] {\n\t\tconst { __orgOffset: offset } = this\n\t\treturn [offset, offset + this.__advanced]\n\t}\n\n\t/**\n\t * get next char code\n\t * @return number char code number\n\t */\n\tnextCode() {\n\t\treturn this.__code\n\t}\n\n\tnextChar() {\n\t\treturn char(this.__code)\n\t}\n\n\t// result opeartions \n\t/**\n\t * append result\n\t */\n\tadd(data: any) {\n\t\tconst { result } = this\n\t\tresult[result.length] = data\n\t}\n\n\t/**\n\t * append resultset\n\t */\n\taddAll(data: any[]) {\n\t\tconst { result } = this\n\t\tconst len = result.length\n\t\tlet i = data.length\n\t\twhile (i--) result[len + i] = data[i]\n\t}\n\n\t/**\n\t * get result size\n\t */\n\tresultSize() {\n\t\treturn this.result.length\n\t}\n}\n","/**\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:06:22 GMT+0800 (China Standard Time)\n * @modified Sat Dec 22 2018 15:24:21 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, MatchError, onMatchCallback, onErrorCallback, RuleOptions } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { assert } from '../assert'\nimport { idxOfArray } from '../collection'\nimport { pad } from '../format'\nimport { escapeStr } from '../string'\nimport { Source } from '../Source'\n\nexport type ComplexRuleBuilder = (rule: Rule) => Rule[]\n\nconst MAX = -1 >>> 0\n/**\n * Abstract Complex Rule\n */\nexport class ComplexRule extends Rule {\n\treadonly split: string\n\tprivate builder: ComplexRuleBuilder\n\tprotected EXPECTS: string[]\n\tprotected rules: Rule[]\n\tprotected readonly rMin: number\n\tprotected readonly rMax: number\n\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param builder \t\tcallback of build rules\n\t * @param options\t\tRule Options\n\t */\n\tconstructor(name: string, repeat: [number, number], builder: ComplexRuleBuilder, options: RuleOptions) {\n\t\tsuper(name, options)\n\n\t\tlet [rMin, rMax] = repeat\n\n\t\trMin < 0 && (rMin = 0)\n\t\trMax <= 0 && (rMax = MAX)\n\n\t\tassert.notGreater(rMin, rMax)\n\n\t\tthis.rMin = rMin\n\t\tthis.rMax = rMax\n\n\t\tthis.builder = builder\n\n\t\tif (rMin !== rMax || rMin !== 1) {\n\t\t\tthis.match = this.rmatch\n\n\t\t\t// for debug\n\t\t\tthis.type = `${this.type}[${rMin}${rMin === rMax ? '' : ` - ${rMax === MAX ? 'MAX' : rMax}`}]`\n\t\t}\n\t}\n\tparse(buff: string, data?: any): any[] {\n\t\tconst ctx = new MatchContext(new Source(buff), buff, 0, 0)\n\t\tctx.data = data\n\t\tlet err = this.match(ctx)\n\t\tif (err) {\n\t\t\tconst msg = []\n\t\t\tvar pos: [number, number, string]\n\t\t\tdo {\n\t\t\t\tpos = err.position()\n\t\t\t\tmsg.unshift(\n\t\t\t\t\t`[${pad(String(pos[0]), 3)}:${pad(String(pos[1]), 2)}] - ${err.rule.toString()}: ${\n\t\t\t\t\t\terr.msg\n\t\t\t\t\t} on \"${escapeStr(pos[2])}\"`\n\t\t\t\t)\n\t\t\t} while ((err = err.source))\n\t\t\tmsg.push('[Source]', ctx.source.source())\n\t\t\tthrow new SyntaxError(msg.join('\\n'))\n\t\t}\n\t\treturn ctx.result\n\t}\n\tinit(): ComplexRule {\n\t\tconst rules = this.builder(this)\n\t\tlet i = rules && rules.length\n\n\t\tassert.is(i, `Require Complex Rules`)\n\n\t\tthis.rules = rules\n\n\t\t// generate expression and expect string for debug\n\t\tconst names = this.rnames(rules)\n\t\tthis.setExpr(names.join(this.split))\n\t\twhile (i--) names[i] = `Expect[${i}]: ${names[i]}`\n\t\tthis.EXPECTS = names\n\n\t\tthis.__init(rules)\n\n\t\tthis.builder = null\n\n\t\treturn this\n\t}\n\t__init(rules: Rule[]) {}\n\n\tprotected rmatch(context: MatchContext): MatchError {\n\t\treturn assert()\n\t}\n\n\tprotected setCodeIdx(index: any[]) {\n\t\tthis.rMin && super.setCodeIdx(index)\n\t}\n\n\tgetRules(): Rule[] {\n\t\treturn this.rules || (this.init(), this.rules)\n\t}\n\n\tgetStart(stack?: number[]): number[] {\n\t\tconst { id, startCodes } = this\n\t\treturn startCodes\n\t\t\t? startCodes\n\t\t\t: (stack && ~idxOfArray(stack, id)) || this.rules\n\t\t\t? []\n\t\t\t: (this.init(), this.startCodes)\n\t}\n\n\tconsume(context: MatchContext): MatchError {\n\t\tconst err = this.matched(context.result, context.advanced(), context.parent)\n\t\t!err && context.commit()\n\t\treturn err\n\t}\n\n\t// for debug\n\tprivate rnames(rules: Rule[], stack?: number[]): string[] {\n\t\tlet i = rules.length\n\t\tconst names: string[] = new Array(i),\n\t\t\tid = this.id\n\t\twhile (i--) names[i] = rules[i].getExpr(stack ? stack.concat(id) : [id])\n\t\treturn names\n\t}\n\n\tgetExpr(stack?: number[]): string {\n\t\tconst { id, name } = this\n\t\tlet i: number\n\n\t\treturn name\n\t\t\t? name\n\t\t\t: stack\n\t\t\t? ~(i = idxOfArray(stack, id))\n\t\t\t\t? `<${this.type} -> $${stack[i]}>`\n\t\t\t\t: this.mkExpr(this.rnames(this.getRules(), stack).join(this.split))\n\t\t\t: this.expr\n\t}\n}\n","/**\n *\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 27 2018 19:05:48 GMT+0800 (China Standard Time)\n * @modified Sat Dec 22 2018 15:56:09 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, MatchError } from './Rule'\nimport { MatchContext, CheckPoint } from './MatchContext'\nimport { ComplexRule } from './ComplexRule'\nimport { mixin } from '../mixin'\n\n/**\n * AND Complex Rule\n */\n@mixin({ type: 'And', split: ' ' })\nexport class AndRule extends ComplexRule {\n\t__init(rules: Rule[]) {\n\t\tthis.setStartCodes(rules[0].getStart([this.id]))\n\t}\n\tmatch(context: MatchContext): MatchError {\n\t\tconst rules = this.getRules(),\n\t\t\tlen = rules.length,\n\t\t\tctx = context.create()\n\t\tlet err: MatchError,\n\t\t\ti: number = 0\n\t\tfor (; i < len; i++) if ((err = this.testRule(rules[i], i, ctx))) return err\n\t\treturn this.consume(ctx)\n\t}\n\tprotected rmatch(context: MatchContext): MatchError {\n\t\tconst { rMin, rMax } = this\n\t\tconst rules = this.getRules(),\n\t\t\tlen = rules.length,\n\t\t\tctx = context.create()\n\n\t\tlet err: MatchError,\n\t\t\trepeat: number = 0,\n\t\t\ti: number,\n\t\t\tcp: CheckPoint\n\n\t\tout: for (; repeat < rMax; repeat++) {\n\t\t\tcp = ctx.checkpoint()\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tif ((err = this.testRule(rules[i], i, ctx))) {\n\t\t\t\t\tif (repeat < rMin) return err\n\t\t\t\t\tctx.rollback(cp)\n\t\t\t\t\tbreak out\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.consume(ctx)\n\t}\n\ttestRule(rule: Rule, i: number, ctx: MatchContext): MatchError {\n\t\tlet err: MatchError\n\t\tif (!rule.test(ctx)) {\n\t\t\treturn this.error(this.EXPECTS[i], ctx)\n\t\t} else if ((err = rule.match(ctx))) {\n\t\t\treturn this.error(this.EXPECTS[i], ctx, err)\n\t\t}\n\n\t\t// return (!rule.test(ctx) || (err = rule.match(ctx))) && (err = this.error(this.EXPECTS[i], ctx, err))\n\t}\n}\n","/**\n *\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 27 2018 19:05:48 GMT+0800 (China Standard Time)\n * @modified Sat Dec 22 2018 17:47:30 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, MatchError } from './Rule'\nimport { MatchContext, CheckPoint } from './MatchContext'\nimport { ComplexRule } from './ComplexRule'\nimport { eachCharCodes } from './util'\nimport { mixin } from '../mixin'\n\n/**\n * OR Complex Rule\n */\n@mixin({ type: 'Or', split: ' | ' })\nexport class OrRule extends ComplexRule {\n\tindex: Rule[][]\n\t__init(rules: Rule[]) {\n\t\tconst { id } = this\n\t\tconst len = rules.length,\n\t\t\tstarts: number[] = [], // all distinct start codes\n\t\t\trStarts: number[][] = [], // start codes per rule\n\t\t\tindex: Rule[][] = [\n\t\t\t\t[] // rules which without start code\n\t\t\t]\n\n\t\tlet i: number, j: number, k: Rule[] & { idx: number }, codes: number[]\n\n\t\t// get start codes of all rules\n\t\tfor (i = 0; i < len; i++) {\n\t\t\trStarts[i] = [] // init rule start codes\n\t\t\teachCharCodes(rules[i].getStart([id]), false, code => {\n\t\t\t\trStarts[i].push(code) // append to rule start codes\n\t\t\t\tif (!index[code]) {\n\t\t\t\t\tindex[code] = [] // init start code index\n\t\t\t\t\tstarts.push(code) // append to all start codes\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\t// fill index\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tcodes = rStarts[i] // append rule to start code index by rule start codes\n\t\t\tif (!codes.length) {\n\t\t\t\t// rule without start code\n\t\t\t\tindex[0].push(rules[i]) // append rule to index[0]\n\t\t\t\tcodes = starts // append rule to start code index by all start codes\n\t\t\t}\n\n\t\t\t// append rule to start code index (by rule start codes or all start codes)\n\t\t\tj = codes.length\n\t\t\twhile (j--) {\n\t\t\t\tk = index[codes[j]] as Rule[] & { idx: number }\n\t\t\t\tif (k.idx !== i) {\n\t\t\t\t\t// deduplication\n\t\t\t\t\tk.push(rules[i]) // append rules[i] to start code index[codes[j]]\n\t\t\t\t\tk.idx = i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// rule have unkown start code when got unkown start code from any rules\n\t\tconst startCodes = !index[0].length && starts\n\t\tthis.startCodes = startCodes || []\n\t\tstartCodes && this.setCodeIdx(index)\n\t\tthis.index = index\n\t}\n\n\tmatch(context: MatchContext): MatchError {\n\t\tconst index = this.index || (this.init(), this.index),\n\t\t\trules: Rule[] = index[context.nextCode()] || index[0],\n\t\t\tlen = rules.length,\n\t\t\tctx = context.create()\n\n\t\tlet err: MatchError,\n\t\t\tupErr: MatchError,\n\t\t\ti = 0\n\n\t\tfor (; i < len; i++) {\n\t\t\terr = rules[i].match(ctx) || this.consume(ctx)\n\t\t\tif (!err) return\n\t\t\tif (!err.capturable) {\n\t\t\t\tupErr = err\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif (!upErr || err.pos >= upErr.pos) upErr = err\n\t\t\tctx.rollback()\n\t\t}\n\t\treturn this.error(this.EXPECT, ctx, upErr)\n\t}\n\n\tprotected rmatch(context: MatchContext): MatchError {\n\t\tconst { rMin, rMax } = this\n\t\tconst index = this.index || (this.init(), this.index),\n\t\t\tctx = context.create()\n\n\t\tlet rules: Rule[],\n\t\t\tlen: number,\n\t\t\terr: MatchError,\n\t\t\tupErr: MatchError,\n\t\t\trepeat: number = 0,\n\t\t\ti: number,\n\t\t\tcp: CheckPoint\n\n\t\tout: for (; repeat < rMax; repeat++) {\n\t\t\trules = index[ctx.nextCode()] || index[0]\n\t\t\tupErr = null\n\t\t\tif ((len = rules.length)) {\n\t\t\t\tcp = ctx.checkpoint()\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\terr = rules[i].match(ctx)\n\t\t\t\t\tif (!err) continue out\n\t\t\t\t\tif (!err.capturable) {\n\t\t\t\t\t\tupErr = err\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tif (!upErr || err.pos >= upErr.pos) upErr = err\n\t\t\t\t\tctx.rollback(cp)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (repeat < rMin || (upErr && !upErr.capturable)) return this.error(this.EXPECT, ctx, upErr)\n\t\t\tbreak\n\t\t}\n\t\treturn this.consume(ctx)\n\t}\n}\n","/**\n * AST Parser API\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:58:52 GMT+0800 (China Standard Time)\n * @modified Sat Dec 22 2018 15:45:10 GMT+0800 (China Standard Time)\n */\n\nimport { ComplexRuleBuilder } from './ComplexRule'\nimport { isObj, isReg, isStr, isBool, isNum, isInt, isArray, isArrayLike, isFn } from '../is'\nimport { makeMap, mapArray, SKIP } from '../collection'\nimport { CharMatchRule } from './CharMatchRule'\nimport { StringMatchRule } from './StringMatchRule'\nimport { RegMatchRule } from './RegMatchRule'\nimport { onMatchCallback, onErrorCallback, Rule, MatchError, RuleOptions } from './Rule'\nimport { MatchRule } from './MatchRule'\nimport { AndRule } from './AndRule'\nimport { OrRule } from './OrRule'\nimport { assert } from '../assert'\nimport { MatchContext } from './MatchContext'\nimport { EMPTY_FN } from '../consts'\n\n//========================================================================================\n/*                                                                                      *\n *                                      match tools                                     *\n *                                                                                      */\n//========================================================================================\n\nexport const discardMatch: onMatchCallback = EMPTY_FN\n\nexport function appendMatch(data: any, len: number, context: MatchContext) {\n\tcontext.addAll(data)\n}\nexport function attachMatch(\n\tcallback: (data: any, len: number, context: MatchContext, rule: Rule) => any\n): onMatchCallback\nexport function attachMatch(val: any): onMatchCallback\nexport function attachMatch(val: any) {\n\tconst callback: (data: any, len: number, context: MatchContext, rule: Rule) => any = isFn(val) ? val : () => val\n\treturn (data: any, len: number, context: MatchContext, rule: Rule) => {\n\t\tcontext.add(callback(data, len, context, rule))\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       match api                                      *\n *                                                                                      */\n//========================================================================================\n\nexport function match(desc: MatchRuleDescriptor): MatchRule\n\n// named regexp match api \n// pick, start, cap\n// pick, cap\n// pick, start\n// pick\n// start, cap\n// start\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tpick?: boolean | number,\n\tstartCodes?: number | string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tstartCodes: number | string | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tstartCodes: string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tstartCodes: string | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(name: string, pattern: RegExp, onMatch: onMatchCallback, onErr?: onErrorCallback): MatchRule\n\n// regexp match api \nexport function match(\n\tpattern: RegExp,\n\tpick?: boolean | number,\n\tstartCodes?: number | string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tstartCodes: number | string | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tstartCodes: string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tstartCodes: string | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(pattern: RegExp, onMatch: onMatchCallback, onErr?: onErrorCallback): MatchRule\n\n// named string match api \nexport function match(\n\tname: string,\n\tpattern: number | string | any[],\n\tignoreCase?: boolean,\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(\n\tname: string,\n\tpattern: number | string | any[],\n\tignoreCase: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(\n\tname: string,\n\tpattern: number | string | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\n// string match api \nexport function match(\n\tpattern: number | string | any[],\n\tignoreCase?: boolean,\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(\n\tpattern: number | string | any[],\n\tignoreCase: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(pattern: number | string | any[], onMatch: onMatchCallback, onErr?: onErrorCallback): MatchRule\n\nexport function match(): MatchRule {\n\treturn mkMatch(arguments)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     and rule api                                     *\n *                                                                                      */\n//========================================================================================\n\n// and \nexport function and(desc: ComplexRuleDescriptor): AndRule\nexport function and(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(\n\trules: ((rule: Rule) => any[]) | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(rules: ((rule: Rule) => any[]) | any[], onMatch: onMatchCallback, onErr?: onErrorCallback): AndRule\nexport function and(): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [1, 1])\n}\n\n// and any \nexport function any(desc: ComplexRuleDescriptor): AndRule\nexport function any(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function any(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function any(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function any(rules: ((rule: Rule) => any[]) | any[], onMatch: onMatchCallback, onErr?: onErrorCallback): AndRule\nexport function any(): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [0, -1])\n}\n\n// and many \nexport function many(desc: ComplexRuleDescriptor): AndRule\nexport function many(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function many(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function many(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function many(rules: ((rule: Rule) => any[]) | any[], onMatch: onMatchCallback, onErr?: onErrorCallback): AndRule\nexport function many(): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [1, -1])\n}\n\n// and option \nexport function option(desc: ComplexRuleDescriptor): AndRule\nexport function option(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function option(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function option(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function option(\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function option(): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [0, 1])\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      or rule api                                     *\n *                                                                                      */\n//========================================================================================\n\n// or \nexport function or(desc: ComplexRuleDescriptor): OrRule\nexport function or(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(\n\trules: ((rule: Rule) => any[]) | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(rules: ((rule: Rule) => any[]) | any[], onMatch: onMatchCallback, onErr?: onErrorCallback): OrRule\nexport function or(): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [1, 1])\n}\n\n// or any \nexport function anyOne(desc: ComplexRuleDescriptor): OrRule\nexport function anyOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function anyOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function anyOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function anyOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function anyOne(): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [0, -1])\n}\n\n// or many \nexport function manyOne(desc: ComplexRuleDescriptor): OrRule\nexport function manyOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function manyOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function manyOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function manyOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function manyOne(): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [1, -1])\n}\n\n// or option \nexport function optionOne(desc: ComplexRuleDescriptor): OrRule\nexport function optionOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function optionOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function optionOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function optionOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function optionOne(): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [0, 1])\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                  Match Rule Builder                                  *\n *                                                                                      */\n//========================================================================================\n\nexport type MatchRuleDescriptor = {\n\tname?: string\n\tpattern: RegExp | number | string | any[]\n\tpick?: boolean | number\n\tstartCodes?: number | string | any[]\n\tignoreCase?: boolean\n} & RuleOptions\n\nfunction mkMatch(args: IArguments | any[], defaultMatchCallback?: onMatchCallback): MatchRule {\n\tlet name: string,\n\t\tpattern: number | string | any[],\n\t\tregexp: RegExp,\n\t\tpick: boolean | number = 0,\n\t\tstartCodes: number | string | any[],\n\t\tignoreCase: boolean = false,\n\t\toptions: RuleOptions\n\tif (isObj(args[0])) {\n\t\tconst desc = args[0] as MatchRuleDescriptor,\n\t\t\tp = desc.pattern\n\t\tif (isReg(p)) {\n\t\t\tregexp = p as RegExp\n\t\t\tpick = desc.pick\n\t\t\tstartCodes = desc.startCodes\n\t\t} else if (isStrOrCodes(p)) {\n\t\t\tpattern = p as number | string | any[]\n\t\t\tignoreCase = desc.ignoreCase\n\t\t}\n\t\tname = desc.name\n\t\toptions = desc\n\t} else {\n\t\tvar i = 1\n\t\tif (isStr(args[0]) && isMatchPattern(args[1])) {\n\t\t\tname = args[0]\n\t\t\tisReg(args[1]) ? (regexp = args[1]) : (pattern = args[1])\n\t\t\ti = 2\n\t\t} else if (isMatchPattern(args[0])) {\n\t\t\tisReg(args[0]) ? (regexp = args[0]) : (pattern = args[0])\n\t\t}\n\n\t\tif (regexp) {\n\t\t\tif (isBool(args[i]) || isInt(args[i])) pick = args[i++]\n\t\t\tif (isStrOrCodes(args[i])) startCodes = args[i++]\n\t\t} else {\n\t\t\tif (isBool(args[i])) ignoreCase = args[i++]\n\t\t}\n\t\toptions = parseRuleOptions(args, i)\n\t}\n\n\t!options.match && (options.match = defaultMatchCallback)\n\n\treturn regexp\n\t\t? new RegMatchRule(name, regexp, options.match === discardMatch ? false : pick, startCodes, options)\n\t\t: pattern\n\t\t? strMatch(name, pattern, ignoreCase, options)\n\t\t: assert('invalid match rule {j}', args)\n}\n\nfunction isStrOrCodes(pattern): boolean {\n\treturn isStr(pattern) || isNum(pattern) || isArray(pattern)\n}\n\nfunction isMatchPattern(pattern): boolean {\n\treturn isReg(pattern) || isStrOrCodes(pattern)\n}\n\nfunction strMatch(name: string, pattern: string | number | any[], ignoreCase: boolean, options: RuleOptions) {\n\tconst C = isStr(pattern) && (pattern as string).length > 1 ? StringMatchRule : CharMatchRule\n\treturn new C(name, pattern, ignoreCase, options)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                 complex rule builder                                 *\n *                                                                                      */\n//========================================================================================\n\nexport type ComplexRuleDescriptor = {\n\tname?: string\n\trules: ((rule: Rule) => any[]) | any[]\n\trepeat?: [number, number]\n\tcapturable?: boolean\n\tonMatch?: onMatchCallback\n\tonErr?: onErrorCallback\n} & RuleOptions\n\nfunction mkComplexRule<T extends AndRule | OrRule>(\n\targs: IArguments,\n\tRule: typeof AndRule | typeof OrRule,\n\tdefaultRepeat: [number, number]\n): T {\n\tlet name: string,\n\t\tbuilder: ComplexRuleBuilder,\n\t\trules: ((rule: Rule) => any[]) | any[],\n\t\trepeat: [number, number],\n\t\toptions: RuleOptions\n\tif (isObj(args[0])) {\n\t\tconst desc = args[0] as ComplexRuleDescriptor,\n\t\t\tr = desc.rules\n\t\tif (isArray(r) || isFn(r)) rules = r\n\t\trepeat = desc.repeat\n\t\tname = desc.name\n\t\toptions = desc\n\t} else {\n\t\tvar i = 0\n\t\tif (isStr(args[i])) name = args[i++]\n\t\tif (isArray(args[i]) || isFn(args[i])) rules = args[i++]\n\t\tif (isArray(args[i])) repeat = args[i++]\n\t\toptions = parseRuleOptions(args, i)\n\t}\n\tif (!repeat) repeat = defaultRepeat\n\tif (rules) {\n\t\tbuilder = rulesBuilder(rules)\n\t\treturn new Rule(name, repeat, builder, options) as T\n\t}\n}\n\nfunction rulesBuilder(rules: ((rule: Rule) => any[]) | any[]): (rule: Rule) => Rule[] {\n\treturn function(_rule) {\n\t\treturn mapArray(isFn(rules) ? (rules as ((rule: Rule) => any[]))(_rule) : rules, (r, i) => {\n\t\t\tif (!r) return SKIP\n\t\t\tlet rule: Rule = r.$rule ? r : mkMatch(isArray(r) ? r : [r], discardMatch)\n\t\t\tassert.is(rule, '{}: Invalid Rule Configuration on index {d}: {j}', _rule, i, r)\n\t\t\treturn rule\n\t\t})\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         tools                                        *\n *                                                                                      */\n//========================================================================================\n\nfunction parseRuleOptions(args: IArguments | any[], i: number) {\n\tconst options: RuleOptions = {}\n\tif (isBool(args[i])) options.capturable = args[i++]\n\toptions.match = args[i++]\n\toptions.err = args[i]\n\treturn options\n}\n","/**\n * @module observer\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Dec 26 2018 13:59:10 GMT+0800 (China Standard Time)\n * @modified Sun Mar 10 2019 11:04:55 GMT+0800 (China Standard Time)\n */\n\nimport {\n\tmapArray,\n\tapplyScope,\n\tdefPropValue,\n\tcreate,\n\tisArray,\n\tFnList,\n\tList,\n\tparsePath,\n\tformatPath,\n\tisObj,\n\tisPrimitive,\n\tnextTick,\n\tisNil,\n\ttoStrType,\n\tmap\n} from '../utility'\nimport { PROTOTYPE } from '../utility/consts'\nimport { assert } from '../utility/assert'\n\nexport type ObserverTarget = any[] | {}\n\n/**\n * @param path \t\tthe observe path\n * @param value \tnew value\n * @param original\toriginal value. the original value is {@link MISS} when the dirty collector loses the original value\n */\nexport type ObserverCallback = (path: string[], value: any, original: any, observer: Observer) => void\n\n/**\n * the property of observe an array change\n */\nexport const ARRAY_CHANGE = '$change'\n\n/**\n * The dirty collector lost the original value\n */\nexport const MISS = {}\n\n//========================================================================================\n/*                                                                                      *\n *                                        topic                                       *\n *                                                                                      */\n//========================================================================================\n\nconst V = {}\n\nfunction isObserverTarget(obj: any) {\n\treturn obj && (isArray(obj) || isObj(obj))\n}\n\n/**\n * get or create sub-observer\n * fix proxy value\n * @param observer \tobserver\n * @param prop\t\tproperty of observer target\n * @param target\ttarget = observer.target[prop]\n * @return sub-observer\n */\nfunction loadSubObserver(observer: Observer, prop: string, target: any): Observer {\n\tconst subObserver: Observer = getObserver(target) || observer.observerOf(target)\n\tif (subObserver.proxy !== target) observer.target[prop] = subObserver.proxy\n\treturn subObserver\n}\n\n/**\n * get property value on object\n * @param obj \tobject\n * @param prop \tproperty\n */\nfunction getValue(obj: any, prop: string) {\n\treturn obj === undefined || obj === null ? undefined : obj[prop]\n}\n\n/**\n * get property value on original object\n * check {@link MISS}\n * @param original \tobject\n * @param prop \t\tproperty\n */\nfunction getOriginalValue(original: any, prop: string) {\n\treturn original === undefined || original === null ? undefined : original === MISS ? original : original[prop]\n}\n\n// id generator of topic\nlet topicIdGen = 0\n\nconst collectQueue: Topic[] = [], // the dirty topic queue waiting for collection\n\tdirtyQueue: Topic[] = [] // the dirty topic queue waiting for notification\n\n// flags of topic\nconst TOPIC_ENABLED_FLAG = 0x1, // topic is enabled\n\tTOPIC_LISTEN_FLAG = 0x2, // topic is listend\n\tTOPIC_SUB_FLAG = 0x4 // topic has subtopic\n\n/**\n * @ignore\n */\nclass Topic {\n\treadonly __id: number\n\n\t// parent topic\n\treadonly __parent: Topic\n\n\t// own observer\n\treadonly __owner: Observer\n\n\t// watch property\n\treadonly __prop: string\n\n\t// binded observer\n\t__observer: Observer\n\n\t// property path\n\t__path: string[]\n\n\t// listeners\n\t__listeners: FnList<ObserverCallback>\n\n\t// the original value before change\n\t__original: any\n\n\t// collected dirty value: [new value, original value]\n\t__dirty: [any, any]\n\n\t// subtopics\n\t__subs: Topic[]\n\n\t// cache of subtopics\n\t__subCache: { [key: string]: Topic }\n\n\t// flags: TOPIC_ENABLED_FLAG | TOPIC_LISTEN_FLAG | TOPIC_SUB_FLAG\n\t__flags: number\n\n\t/**\n\t * create a Topic\n\t * @param owner\t\town observer\n\t * @param prop\t\twatch property\n\t * @param parent\tparent topic\n\t */\n\tconstructor(owner: Observer, prop: string, parent?: Topic) {\n\t\tthis.__flags = 0\n\t\tthis.__original = V\n\t\tthis.__owner = owner\n\t\tthis.__prop = prop\n\t\tthis.__parent = parent\n\t\tthis.__id = topicIdGen++\n\t}\n\n\t/**\n\t * add listener\n\t * @param path\t\tpath of topic\n\t * @param cb\t\tobserve callback\n\t * @param scope\t\tscope of the callback\n\t * @return listen-id | undefined\n\t */\n\t__listen(path: string[], cb: ObserverCallback, scope: any) {\n\t\tlet { __listeners: listeners } = this\n\t\tif (!listeners) {\n\t\t\tthis.__listeners = listeners = new FnList<ObserverCallback>()\n\t\t\tthis.__path = path\n\t\t}\n\t\tconst id = listeners.add(cb, scope)\n\t\tid && (this.__flags |= TOPIC_LISTEN_FLAG | TOPIC_ENABLED_FLAG)\n\t\treturn id\n\t}\n\n\t/**\n\t * remove listener by callback\n\t * @param cb\t\tobserve callback\n\t * @param scope\t\tscope of the callback\n\t */\n\t__unlisten(cb: ObserverCallback, scope: any) {\n\t\tconst { __listeners: listeners } = this\n\t\tif (listeners) {\n\t\t\tlisteners.remove(cb, scope)\n\t\t\tthis.____unlisten(listeners)\n\t\t}\n\t}\n\n\t/**\n\t * remove listener by listen-id\n\t * @param id\tlisten-id\n\t */\n\t__unlistenId(id: string) {\n\t\tconst { __listeners: listeners } = this\n\t\tif (listeners) {\n\t\t\tlisteners.removeId(id)\n\t\t\tthis.____unlisten(listeners)\n\t\t}\n\t}\n\n\t/**\n\t * Clear all unlistening leaf topics\n\t * @param listeners\tlisteners\n\t */\n\tprivate ____unlisten(listeners: FnList<ObserverCallback>) {\n\t\tif (!listeners.size()) {\n\t\t\tvar topic: Topic = this,\n\t\t\t\tparent: Topic\n\t\t\ttopic.__flags &= ~TOPIC_LISTEN_FLAG\n\t\t\twhile ((topic.__flags & (TOPIC_SUB_FLAG | TOPIC_LISTEN_FLAG | TOPIC_ENABLED_FLAG)) === TOPIC_ENABLED_FLAG) {\n\t\t\t\ttopic.__bind()\n\t\t\t\ttopic.__flags = 0\n\t\t\t\tif (!(parent = topic.__parent)) break\n\t\t\t\tparent.__removeSub(topic)\n\t\t\t\ttopic = parent\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * bind observer\n\t * @param observer new observer\n\t */\n\t__bind(observer?: Observer) {\n\t\tconst { __observer: org } = this\n\t\tif (org !== observer) {\n\t\t\torg && org.__unwatchTopic(this) // unbind old observer\n\t\t\tif (!observer || observer.__watchTopic(this) === false) observer = undefined\n\t\t\tthis.__observer = observer && observer.__watchTopic(this) !== false ? observer : observer\n\t\t}\n\t}\n\n\t/**\n\t * get a subtopic from the cache\n\t * @param prop property\n\t */\n\t__getSub(prop: string): Topic {\n\t\tconst { __subCache: subCache } = this\n\t\treturn subCache && subCache[prop]\n\t}\n\n\t/**\n\t * get or create a subtopic on the cache\n\t * @param subProp\tproperty of the subtopic\n\t * @return subtopic\n\t */\n\t__addSub(subProp: string): Topic {\n\t\tconst subCache: { [key: string]: Topic } =\n\t\t\t\tthis.__subCache || ((this.__subs = []), (this.__subCache = create(null))),\n\t\t\tsub: Topic = subCache[subProp] || (subCache[subProp] = new Topic(this.__owner, subProp, this))\n\n\t\tif (!(sub.__flags & TOPIC_ENABLED_FLAG)) {\n\t\t\t// init the subtopic\n\n\t\t\tconst { __subs: subs, __observer: observer } = this\n\n\t\t\t// 1. bind observer\n\t\t\tif (observer) {\n\t\t\t\tconst { __prop: prop } = this\n\n\t\t\t\t//#if _DEBUG\n\t\t\t\tisArrayChangeProp(observer, prop) && sub.__badPath(2, 'Array')\n\t\t\t\t//#endif\n\n\t\t\t\tvar subObserver: Observer\n\t\t\t\tif (subs[0]) {\n\t\t\t\t\tsubObserver = subs[0].__observer\n\t\t\t\t} else {\n\t\t\t\t\tconst subTarget = observer.target[prop]\n\t\t\t\t\tif (isObserverTarget(subTarget)) {\n\t\t\t\t\t\tsubObserver = loadSubObserver(observer, prop, subTarget)\n\t\t\t\t\t}\n\t\t\t\t\t//#if _DEBUG\n\t\t\t\t\telse if (!isNil(subTarget)) {\n\t\t\t\t\t\tsub.__badPath(2, toStrType(subTarget))\n\t\t\t\t\t}\n\t\t\t\t\t//#endif\n\t\t\t\t}\n\t\t\t\tsub.__bind(subObserver)\n\t\t\t}\n\n\t\t\t// 2. attach subtopic\n\t\t\tsub.__flags |= TOPIC_ENABLED_FLAG\n\t\t\tsubs.push(sub)\n\t\t}\n\n\t\tthis.__flags |= TOPIC_SUB_FLAG | TOPIC_ENABLED_FLAG\n\n\t\treturn sub\n\t}\n\n\t/**\n\t * remove the subtopic from the subs\n\t * @param topic topic\n\t */\n\t__removeSub(topic: Topic) {\n\t\tconst { __subs: subs } = this\n\t\tconst l = subs.length\n\t\tlet i = l\n\t\twhile (i--) {\n\t\t\tif (topic === subs[i]) {\n\t\t\t\tsubs.splice(i, 1)\n\t\t\t\tl === 1 && (this.__flags &= ~TOPIC_SUB_FLAG)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tassert('un-attached topic')\n\t}\n\n\t//#if _DEBUG\n\tprivate __badPath(i: number, type: string, msg?: string) {\n\t\tconst path = this.__getPath()\n\t\tconsole.warn(\n\t\t\t`observer[{}]: can not watch {} on {}{}{}.`,\n\t\t\tformatPath(path),\n\t\t\tformatPath(path.slice(-i)),\n\t\t\ttype,\n\t\t\tpath.length > i ? `[${formatPath(path.slice(0, -i))}]` : '',\n\t\t\tmsg || '',\n\t\t\tthis.__owner.target\n\t\t)\n\t}\n\n\tprivate __badSubsPath(subs: Topic[], len: number, type: string) {\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tsubs[i].__badPath(2, type)\n\t\t}\n\t}\n\n\tprivate __getPath() {\n\t\tlet path: string[] = this.__path\n\t\tif (!path) {\n\t\t\tconst { __parent: parent, __prop: prop } = this\n\t\t\tthis.__path = path = parent ? parent.__getPath().concat(prop) : [prop]\n\t\t}\n\t\treturn path\n\t}\n\t//#endif\n\n\t/**\n\t * mark the change in topic\n\t *\n\t * @param original original value\n\t */\n\t__update(original: any) {\n\t\tif (this.__original === V) {\n\t\t\tthis.__original = original\n\n\t\t\t// add to collect queue\n\t\t\tconst l = collectQueue.length\n\t\t\tcollectQueue[l] = this\n\t\t\t!l && nextTick(collect)\n\t\t}\n\t}\n\n\t/**\n\t * collect the dirty topics(current and sub topics) from collectQueue\n\t * may collected by parent-topic\n\t */\n\t__collect() {\n\t\tconst { __original: original } = this\n\t\tif (original !== V) {\n\t\t\tconst { __observer: observer } = this\n\n\t\t\tthis.__original = V\n\n\t\t\tthis.____collect(observer, observer.target, original)\n\t\t}\n\t}\n\n\t/**\n\t * collect dirty topics\n\t * - Case 1:\n\t * \t1. collect from collectQueue\n\t * \t\t1. clean changed flag\n\t * \t\t2. save dirty values\n\t * \t\t3. collect the subtopics\n\t * \t\t\tdefault use the new and original value\n\t * \t\t\tuse the subtopic's original value when subtopic is changed\n\t * \t\t\tclean subtopic's changed flag\n\t * \t2. re-collect by parent-topic\n\t * \t\t1. replace the new value and discard the original value(keep the existing original value)\n\t * \t\t2. re-collect subtopics\n\t *\n\t * @param observer \tobserver of this topic\n\t * @param target \tnew target of this topic\n\t * @param original \toriginal value of this topic\n\t */\n\tprivate ____collect(observer: Observer, target: any, original: any) {\n\t\tconst { __flags: flags, __prop: prop } = this\n\t\tlet dirty: [any, any],\n\t\t\tsubTarget: any = V // lazy load the sub-target\n\n\t\tif (flags & TOPIC_LISTEN_FLAG) {\n\t\t\tif (!(dirty = this.__dirty)) {\n\t\t\t\tthis.__dirty = dirty = [, original]\n\t\t\t\tdirtyQueue.push(this)\n\t\t\t} // if this topic has been changed and collected, retains its original value\n\n\t\t\tdirty[0] = observer && isArrayChangeProp(observer, prop) ? target : (subTarget = getValue(target, prop))\n\t\t}\n\n\t\tif (flags & TOPIC_SUB_FLAG) {\n\t\t\tsubTarget === V && (subTarget = getValue(target, prop))\n\n\t\t\tconst { __subs: subs } = this\n\t\t\tconst l = subs.length\n\n\t\t\tvar subObserver: Observer,\n\t\t\t\tsub: Topic,\n\t\t\t\tsubOriginal: any,\n\t\t\t\ti = 0\n\n\t\t\tif (observer) {\n\t\t\t\t//#if _DEBUG\n\t\t\t\tisArrayChangeProp(observer, prop) && this.__badSubsPath(subs, l, 'Array')\n\t\t\t\t//#endif\n\n\t\t\t\tif (isObserverTarget(subTarget)) {\n\t\t\t\t\tsubObserver = loadSubObserver(observer, this.__prop, subTarget)\n\t\t\t\t\tsubTarget = subObserver.target\n\t\t\t\t\tdirty && (dirty[0] = subObserver.proxy) // update dirty proxy\n\t\t\t\t}\n\t\t\t\t//#if _DEBUG\n\t\t\t\telse if (!isNil(subTarget)) {\n\t\t\t\t\tthis.__badSubsPath(subs, l, toStrType(subTarget))\n\t\t\t\t}\n\t\t\t\t//#endif\n\t\t\t}\n\n\t\t\tfor (; i < l; i++) {\n\t\t\t\tsub = subs[i]\n\n\t\t\t\tif (!subObserver || sub.__observer != subObserver) {\n\t\t\t\t\tsub.__bind(subObserver)\n\n\t\t\t\t\tif ((subOriginal = sub.__original) === V) {\n\t\t\t\t\t\t// 1. this subtopic has not been changed, using the original value of the current topic\n\t\t\t\t\t\t// *2. this subtopic has been changed and collected, and the collector retains its original value\n\t\t\t\t\t\t// *   this does not happen after the topics are sorted by ID before collection\n\t\t\t\t\t\tsubOriginal = sub.__dirty ? undefined : getOriginalValue(original, sub.__prop)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// this subtopic was changed but not collected, collected in advance\n\t\t\t\t\t\tsub.__original = V\n\t\t\t\t\t}\n\n\t\t\t\t\tsub.____collect(subObserver, subTarget, subOriginal)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction compareTopic(topic1: Topic, topic2: Topic) {\n\treturn topic1.__id - topic2.__id\n}\n\n/**\n * collect the dirty topics on the collectQueue\n */\nfunction collect() {\n\t//#if _DEBUG\n\tconst start = Date.now()\n\t//#endif\n\n\tlet l = collectQueue.length,\n\t\ti = 0\n\n\t// sort by topic id\n\tcollectQueue.sort(compareTopic)\n\n\tfor (; i < l; i++) {\n\t\tcollectQueue[i].__collect()\n\t}\n\n\t//#if _DEBUG\n\tconsole.log(\n\t\t`Collect ${dirtyQueue.length} dirty topics from the collection queue (${l}), use ${Date.now() - start}ms`\n\t)\n\t//#endif\n\n\tnotify()\n}\n\n/**\n * notify all of the dirty topics\n */\nfunction notify() {\n\t//#if _DEBUG\n\tconst start = Date.now()\n\tlet topics = 0,\n\t\tlistens = 0\n\t//#endif\n\n\tconst l = dirtyQueue.length\n\tlet topic: Topic,\n\t\towner: Observer,\n\t\tpath: string[],\n\t\tvalue: any,\n\t\toriginal: any,\n\t\tdirty: [any, any],\n\t\ti = 0\n\n\tfor (; i < l; i++) {\n\t\ttopic = dirtyQueue[i]\n\t\tdirty = topic.__dirty\n\t\tvalue = dirty[0]\n\t\toriginal = dirty[1]\n\n\t\ttopic.__dirty = null // clean the dirty\n\n\t\tif (value !== original || !isPrimitive(value)) {\n\t\t\t// real dirty\n\t\t\towner = topic.__owner\n\t\t\tpath = topic.__path\n\t\t\ttopic.__listeners.each((fn, scope) => {\n\t\t\t\tscope ? fn.call(scope, path, value, original, owner) : fn(path, value, original, owner)\n\n\t\t\t\t//#if _DEBUG\n\t\t\t\tlistens++\n\t\t\t\t//#endif\n\t\t\t})\n\n\t\t\t//#if _DEBUG\n\t\t\ttopics++\n\t\t\t//#endif\n\t\t}\n\t}\n\n\t//#if _DEBUG\n\tconsole.log(\n\t\t`${listens} listen-callbacks of ${topics}/${l} dirty topics have been notified, use ${Date.now() - start}ms`\n\t)\n\t//#endif\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       Observer                                       *\n *                                                                                      */\n//========================================================================================\n\n/**\n */\nclass Watchers extends List<Topic> {\n\t__watched: boolean\n\t/**\n\t *\n\t */\n\tnotify(original: any) {\n\t\tthis.eachUnsafe(topic => topic.__update(original))\n\t}\n}\n\nexport const OBSERVER_KEY = '__observer__'\nexport function getObserver(target: ObserverTarget) {\n\tconst oserver: Observer = target[OBSERVER_KEY]\n\tif (oserver && (oserver.target === target || oserver.proxy === target)) return oserver\n}\nlet disableUpdate = false\nexport class Observer {\n\t/**\n\t * original object\n\t */\n\treadonly target: ObserverTarget\n\n\t/**\n\t * proxy object\n\t */\n\tproxy: ObserverTarget\n\n\t/**\n\t * is array\n\t */\n\treadonly isArray: boolean\n\n\t/**\n\t * topics\n\t * \t- key: property of original object\n\t * \t- value: topic\n\t */\n\t__topics: { [key: string]: Topic }\n\n\t/**\n\t * watched topics\n\t * \t- key: property of original object\n\t * \t- value: topics\n\t */\n\treadonly __watchs: { [key: string]: Watchers }\n\n\t/**\n\t * create Observer\n\t * @param target original object\n\t */\n\tconstructor(target: ObserverTarget) {\n\t\tthis.__watchs = create(null)\n\n\t\tthis.target = target\n\t\tthis.proxy = target\n\n\t\tif ((this.isArray = isArray(target))) applyArrayHooks(target as any[])\n\n\t\tassert.is(isObj(target), `the observer target can only be an object or an array`)\n\n\t\t// bind observer key on original object\n\t\tdefPropValue(target, OBSERVER_KEY, this, false, false, false)\n\t}\n\n\t/**\n\t * observe property path\n\t * @param propPath \tproperty path of original object, parse string path by {@link parsePath}\n\t * @param cb\t\tcallback\n\t * @param scope\t\tscope of callback\n\t */\n\tobserve(propPath: string | string[], cb: ObserverCallback, scope?: any) {\n\t\tconst path: string[] = parsePath(propPath),\n\t\t\ttopics = this.__topics || (this.__topics = create(null)),\n\t\t\tprop0 = path[0]\n\n\t\tlet topic = topics[prop0] || (topics[prop0] = new Topic(this, prop0)),\n\t\t\ti = 1,\n\t\t\tl = path.length\n\n\t\ttopic.__bind(this)\n\n\t\tfor (; i < l; i++) {\n\t\t\ttopic = topic.__addSub(path[i])\n\t\t}\n\n\t\treturn topic.__listen(path, cb, scope)\n\t}\n\n\t/**\n\t * unobserve property path\n\t * @param propPath\tproperty path on object\n\t * @param cb\t\tcallback\n\t * @param scope\t\tscope of cb\n\t */\n\tunobserve(propPath: string | string[], cb: ObserverCallback, scope?: any) {\n\t\tconst topic = this.__getTopic(parsePath(propPath))\n\t\ttopic && topic.__unlisten(cb, scope)\n\t}\n\n\t/**\n\t * unobserve property path\n\t * @param propPath\tproperty path on object\n\t * @param id \t\tlisten-id\n\t */\n\tunobserveId(propPath: string | string[], id: string) {\n\t\tconst topic = this.__getTopic(parsePath(propPath))\n\t\ttopic && topic.__unlistenId(id)\n\t}\n\n\t/**\n\t * update property value and notify changes\n\t * @param prop\t\tproperty\n\t * @param original\toriginal value\n\t */\n\tupdate(prop: string, original: any) {\n\t\tif (!disableUpdate) {\n\t\t\tconst watchers = this.__watchs[prop]\n\t\t\twatchers && watchers.size() && watchers.notify(original)\n\t\t}\n\t}\n\n\tupdateAll() {\n\t\tif (!disableUpdate) {\n\t\t\tconst { __watchs: watchs } = this\n\t\t\tvar prop: string, watchers: Watchers\n\t\t\tfor (prop in watchs) {\n\t\t\t\twatchers = watchs[prop]\n\t\t\t\twatchers.size() && watchers.notify(MISS)\n\t\t\t}\n\t\t}\n\t}\n\n\t_watchers(prop: string) {\n\t\tif (!disableUpdate) {\n\t\t\tconst watchers = this.__watchs[prop]\n\t\t\tif (watchers && watchers.size()) return watchers\n\t\t}\n\t}\n\n\t/**\n\t * watch property\n\t * @abstract\n\t * @protected\n\t * @param prop\tproperty\n\t */\n\t_watch(prop: string): boolean | void {\n\t\treturn true //assert('abstruct')\n\t}\n\n\t/**\n\t * get or create observer\n\t * @abstract\n\t * @protected\n\t */\n\tobserverOf(target: any): Observer {\n\t\treturn new Observer(target) //assert('abstruct')\n\t}\n\n\t/**\n\t *\n\t * @param path\n\t */\n\tprivate __getTopic(path: string[]) {\n\t\tconst { __topics: topics } = this\n\t\tlet topic: Topic\n\t\tif (topics && (topic = topics[path[0]])) {\n\t\t\tfor (var i = 1, l = path.length; i < l; i++) {\n\t\t\t\tif (!(topic = topic.__getSub(path[i]))) break\n\t\t\t}\n\t\t}\n\t\treturn topic\n\t}\n\n\t/**\n\t * watch topic\n\t * @private\n\t * @param topic\n\t */\n\t__watchTopic(topic: Topic): boolean | void {\n\t\tconst { __watchs: watchs } = this\n\t\tconst { __prop: prop } = topic\n\t\tconst topics: Watchers = watchs[prop] || (watchs[prop] = new Watchers()),\n\t\t\tstate = topics.__watched\n\n\t\tif (state === undefined) return (topics.__watched = this._watch(prop) !== false)\n\t\tstate && topics.add(topic)\n\t}\n\n\t/**\n\t * remove watched topic\n\t * @private\n\t * @param topic\n\t */\n\t__unwatchTopic(topic: Topic) {\n\t\tthis.__watchs[topic.__prop].remove(topic)\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\ttoJSON() {}\n}\n\nfunction isArrayChangeProp(observer: Observer, prop: string) {\n\treturn observer.isArray && prop === ARRAY_CHANGE\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      Array Hooks                                     *\n *                                                                                      */\n//========================================================================================\n\ntype ArrayHook = [string, (...args: any[]) => any]\nconst arrayHooks = mapArray(\n\t'fill,pop,push,reverse,shift,sort,splice,unshift'.split(','),\n\t(method: string): ArrayHook => {\n\t\tconst fn = Array[PROTOTYPE][method]\n\t\treturn [\n\t\t\tmethod,\n\t\t\tfunction() {\n\t\t\t\tconst observer: Observer = this[OBSERVER_KEY]\n\t\t\t\tobserver.updateAll()\n\t\t\t\treturn applyScope(fn, observer.target, arguments)\n\t\t\t}\n\t\t]\n\t}\n)\n\n/**\n * apply observer hooks on Array\n * @param array\n */\nfunction applyArrayHooks(array: any[]) {\n\tlet hook: ArrayHook,\n\t\ti = arrayHooks.length\n\twhile (i--) {\n\t\thook = arrayHooks[i]\n\t\tdefPropValue(array, hook[0], hook[1], false, false, false)\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     test topic                                     *\n *                                                                                      */\n//========================================================================================\n\nconst objIdGen: { [key: string]: number } = {}\nfunction objId(obj: any, str: string) {\n\treturn obj.id || (obj.id = str + '-' + (objIdGen[str] ? ++objIdGen[str] : (objIdGen[str] = 1)))\n}\nfunction topicState(topic: Topic) {\n\tconst path = []\n\tlet p = topic\n\twhile (p) {\n\t\tpath.unshift(p.__prop)\n\t\tp = p.__parent\n\t}\n\tconst subs = topic.__subs && topic.__subs.length\n\tconst listeners = topic.__listeners && topic.__listeners.size()\n\n\tassert.is(!!(subs || listeners) === !!(topic.__flags & TOPIC_ENABLED_FLAG))\n\tassert.is(!!subs === !!(topic.__flags & TOPIC_SUB_FLAG))\n\tassert.is(!!listeners === !!(topic.__flags & TOPIC_LISTEN_FLAG))\n\tassert.is(!topic.__observer || topic.__flags & TOPIC_ENABLED_FLAG)\n\n\treturn {\n\t\tid: objId(topic, 'topic'),\n\t\tpath: formatPath(path),\n\t\tobj: JSON.stringify(topic.__owner.target),\n\t\tenabled: !!(subs || listeners),\n\t\tlisteners: listeners,\n\t\twatched: topic.__observer && {\n\t\t\tid: objId(topic.__observer, 'observer'),\n\t\t\tobj: JSON.stringify(topic.__observer.target),\n\t\t\twatchs: watchs(topic.__observer)\n\t\t},\n\t\tsubCache: topic.__subCache && map(topic.__subCache, topicState),\n\t\tsubs: subs && map(topic.__subs, sub => objId(sub, 'topic'))\n\t}\n}\nfunction observerState(observer: Observer) {\n\treturn {\n\t\tid: objId(observer, 'observer'),\n\t\tobj: JSON.stringify(observer.target),\n\t\twatchs: watchs(observer),\n\t\ttopics: map(observer.__topics, subj => topicState(subj))\n\t}\n}\nfunction watchs(observer: Observer) {\n\treturn map(observer.__watchs, w =>\n\t\tw\n\t\t\t.toArray()\n\t\t\t.map(s => objId(s, 'topic'))\n\t\t\t.join(', ')\n\t)\n}\n\nfunction logState(obs: Observer) {\n\tconst state = observerState(obs)\n\tconsole.log(JSON.stringify(state, null, '  '))\n}\nlet obs = new Observer({ a: { b: { c: 1 } } })\nlet id1 = obs.observe('a.b.c', () => {})\nlet id2 = obs.observe('a.b.d', () => {})\n//logState(obs)\nobs.unobserveId('a.b.c', id1)\nobs.unobserveId('a.b.c', id1)\n//logState(obs)\nobs.unobserveId('a.b.d', id2)\n\n//logState(obs)\nid1 = obs.observe('a.b.c', function() {\n\tconsole.log('a.b.c', arguments)\n})\nid2 = obs.observe('a.b.d', function() {\n\tconsole.log('a.b.d', arguments)\n})\n//logState(obs)\n\nconst ov = obs.target['a']\nobs.target['a'] = { b: { d: 2 } }\nobs.update('a', ov)\n\nsetTimeout(function() {\n\t//logState(obs)\n}, 1000)\n\n//logState(obs)\n","/**\n * property utilities\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:24:47 GMT+0800 (China Standard Time)\n * @modified Thu Jan 31 2019 10:15:09 GMT+0800 (China Standard Time)\n */\n\n//#if _TARGET === 'es3'\n\nimport { hasOwnProp } from './polyfill'\nexport { hasOwnProp, propDescriptor, propAccessor, defProp, defPropValue } from './polyfill'\n\n/*#else\n\nimport { hasOwnProp } from './hasOwnProp'\nexport { hasOwnProp } from './hasOwnProp'\nexport { propDescriptor, propAccessor, defProp, defPropValue } from './main'\n\n//#endif */\n\n/**\n * get owner property value\n * @param prop \t\t\tproperty name\n * @param defaultVal \tdefault value\n */\nexport function getOwnProp(obj: any, prop: string, defaultVal?: any): any {\n\treturn hasOwnProp(obj, prop) ? obj[prop] : defaultVal\n}\n"],"names":["CONSTRUCTOR","PROTOTYPE","PROTO","TYPE_BOOL","TYPE_FN","TYPE_NUM","TYPE_STRING","GLOBAL","window","global","self","EMPTY_FN","getConstructor","o","C","Object","eq","o1","o2","isNull","isUndef","undefined","isNil","isBool","mkIsPrimitive","isNum","isStr","isFn","isInt","isPrimitive","type","isBoolean","mkIs","Boolean","isNumber","Number","isString","String","isDate","Date","isReg","RegExp","isArray","Array","isTypedArray","ArrayBuffer","isView","isArrayLike","NodeList","HTMLCollection","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","len","length","isObj","Type","blankStrReg","isBlank","test","createFn","body","args","name","Function","join","applyScope","concat","applyBuilder","maxArgs","scope","offset","cases","i","slice","applyNoScope","applyScopeN","applyNoScopeN","apply","fn","applyN","_bind","varGenReg","funcProto","bind","arguments","argLen","bindPolyfill","this","bindArgs","argOffset","params","stickyReg","sticky","unicodeReg","unicode","REG_ESCAPE","reEscape","str","replace","__hasOwn","hasOwnProp","obj","prop","call","__getProto","getPrototypeOf","____setProto","setPrototypeOf","prototypeOf","protoProp","__proto__","protoOf","__setProto","proto","setProto","p","__hasOwnProp","__defProp","defineProperty","__defineGetter__","__defineSetter__","propDescriptor","val","get","set","value","s","e","propAccessor","desc","TypeError","defProp","defPropValue","configurable","writable","enumerable","__","doCreate","props","k","create","Control","__desc","toString","STOP","eachProps","callback","own","eachObj","eachArray","array","l","SKIP","doMapObj","each","copy","v","doMapArray","j","data","index","mapArray","parseCallback","idx","doIdxOfObj","r","doIdxOfArray","idxOfArray","doReduceObj","accumulator","rs","doReduceArray","defaultObjKeyHandler","defaultObjValueHandler","arr2obj","doArr2Obj","makeArray","pathCache","pathReg","parsePath","propPath","cacheable","path","match","cidx","exec","lastIndex","SyntaxError","charAt","Error","formatPathHandler","prototype","charCode","charCodeAt","char","code","fromCharCode","cutStr","start","end","substring","cutLStr","substr","TRIM_REG","FIRST_LOWER_LETTER_REG","FIRST_UPPER_LETTER_REG","upper","toUpperCase","lower","toLowerCase","upperFirst","STR_ESCAPE_MAP","STR_ESCAPE","escapeStr","pad","chr","leftAlign","__pad","shorten","suffix","thousandSeparate","mkSeparator","binarySeparate","octalSeparate","hexSeparate","group","valReg","reg","numStr","separatorHandler","m","d","PLURAL_REG","pluralHandler","ies","es","ys","SINGULAR_REG","singularHandler","FORMAT_XPREFIX","FORMAT_PLUS","FORMAT_ZERO","FORMAT_SPACE","FORMAT_SEPARATOR","FORMAT_LEFT","FLAG_MAPPING","parseFlags","f","flags","paramPropR","widthR","formatReg","formatters","extendFormatter","fmt","getFormatter","vformat","getParam","defaultGetParam","param","paramProp","width","widx","wprop","fill","precision","pidx","pprop","shortenSuffix","parseParam","parseWidth","w","isFinite","paramIdx","getFormatParam","GET_PARAM_VAR","GET_PROP_VAR","STATE_VAR","createFormatter","getParamCode","getWidthCode","def","strs","formatter","mStart","mEnd","lastIdx","arr","codes","pushStr","append","strFormatter","toStr","numFormatter","parseNum","getPrefix","separator","num","prefix","plen","decimalPrefix","BASE_RADIXS","b","u","x","BASE_PREFIXS","baseFormatter","base","n","__toStr","xprefix","floatFormatter","____toStr","toExponential","toFixed","toPrecision","parseFloat","doAssign","target","overrides","filter","startOffset","endOffset","override","defaultAssignFilter","assignIfFilter","toJSON","JSON","stringify","c","E","g","G","B","O","X","REG_PROPS","deepEq","actual","expected","getTime","eqProps","eqArray","cache","notEqObjKey","eqObj","formatArgHandlers","parseMessage","msg","msgIdx","fs","assert","catchErr","checkErr","expect","err","message","ERROR","throwMsg","mkMsg","objFormatter","extendAssert","condition","dmsg","Err","split","paramStr","cond","expr","notThrow","BOOLEAN","NUMBER","STRING","FUNCTION","to","expectMsg","not","packTypeExpect","all","typeExpect","eql","nul","nil","undef","bool","int","primitive","boolean","number","string","date","typedArray","arrayLike","nan","isNaN","finite","blank","less","greater","range","DEFAULT_BINDING","List","binding","__length","__scaning","size","has","node","add","__insert","__tail","addFirst","insertAfter","__getNode","insertBefore","addAll","objs","__insertAll","addFirstAll","insertAfterAll","insertBeforeAll","prev","__siblingObj","next","first","__head","last","cb","__doLazyRemove","eachUnsafe","toArray","remove","__remove","pop","clean","__lazyRemove","__clean","__initNode","is","siblingIdx","sibling","__doInsert","nodeHead","nodeTail","head","__prev","tail","__doRemove","lazyRemoves","__lazyRemoves","push","DEFAULT_FN_BINDING","DEFAULT_SCOPE_BINDING","FnList","fnBinding","scopeBinding","__nodeMap","__list","parseScope","list","nodeMap","id","removeId","fnId","scopeId","DEFAULT_SCOPE_ID","fnIdGenerator","scopeIdGenerator","ticks","pending","executeTick","flush","MutationObserver","counter","observer","textNode","document","createTextNode","observe","characterData","setTimeout","nextTick","LINE_REG","Source","buff","__lines","__linePos","position","lines","linePos","source","escape","line","toSourceStr","escapeSourceStr","sourceStr","t","eachCharCodes","ignoreCase","eachCharCode","getAnotherCode","mixin","behaviour","Class","MatchError","$ruleErr","capturable","context","rule","pos","startPos","defaultErr","defaultMatch","idGen","Rule","$rule","options","onMatch","onErr","mkErr","error","src","userErr","matched","enter","getStart","stack","startCodes","startCodeTest","startCodeIdx","nextCode","setStartCodes","setCodeIdx","mkExpr","setExpr","EXPECT","getExpr","MatchRule","comsume","advance","CharMatchRule","allows","chars","nextChar","RegMatchRule","regexp","pick","pattern","multiline","_this","stickyMatch","execMatch","spicker","pickNone","pickTestStr","picker","pickAll","mkPicker","StringMatchRule","MatchContext","orgOffset","parent","result","__buff","__offset","__orgOffset","__advanced","__code","__flushCode","__setAdvanced","advanced","notLess","commit","margeState","rollback","checkpoint","resultLen","reset","orgBuff","currPos","resultSize","MAX","ComplexRule","repeat","builder","rMin","rMax","notGreater","rmatch","parse","ctx","unshift","init","rules","names","rnames","EXPECTS","__init","getRules","consume","AndRule","testRule","cp","out","OrRule","starts","rStarts","upErr","discardMatch","mkMatch","defaultMatchCallback","isStrOrCodes","isMatchPattern","parseRuleOptions","strMatch","mkComplexRule","defaultRepeat","_rule","rulesBuilder","ARRAY_CHANGE","MISS","V","isObserverTarget","loadSubObserver","subObserver","getObserver","observerOf","proxy","getValue","getOriginalValue","original","topicIdGen","collectQueue","dirtyQueue","Topic","owner","__flags","__original","__owner","__prop","__parent","__id","__listen","listeners","__listeners","__path","TOPIC_LISTEN_FLAG","__unlisten","____unlisten","__unlistenId","topic","__bind","__removeSub","org","__observer","__unwatchTopic","__watchTopic","__getSub","subCache","__subCache","__addSub","subProp","__subs","sub","subs","subTarget","TOPIC_SUB_FLAG","splice","__update","collect","__collect","____collect","dirty","__dirty","isArrayChangeProp","subOriginal","compareTopic","topic1","topic2","sort","notify","Watchers","OBSERVER_KEY","oserver","Observer","__watchs","hook","arrayHooks","applyArrayHooks","topics","__topics","prop0","unobserve","__getTopic","unobserveId","update","watchers","updateAll","watchs","_watchers","_watch","state","__watched","method","obs","a","id1","id2","console","log","ov","Cls","defaultVal","_eachArray","_eachObj","doEach","eacharray","eachobj","doMap","doIdxOf","doReduce","handler","doObjKeys","doObjValues"],"mappings":"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"}