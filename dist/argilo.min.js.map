{"version":3,"file":"argilo.min.js","sources":["../src/utility/consts.ts","../src/utility/is.ts","../src/utility/fn.ts","../src/utility/reg.ts","../src/utility/proto.ts","../src/utility/prop.ts","../src/utility/create.ts","../src/utility/collection/control.ts","../src/utility/collection/each.ts","../src/utility/collection/map.ts","../src/utility/collection/idxOf.ts","../src/utility/collection/reduce.ts","../src/utility/collection/obj2arr.ts","../src/utility/collection/arr2obj.ts","../src/utility/propPath.ts","../src/utility/string.ts","../src/utility/format.ts","../src/utility/assign.ts","../src/utility/List/List.ts","../src/utility/List/FnList.ts","../src/utility/nextTick.ts","../src/utility/collection/index.ts"],"sourcesContent":["/**\n *\n * @author Tao Zeng (tao.zeng.zt@qq.com)\n * @module utility\n * @created 2018-11-09 15:23:35\n * @modified 2018-11-09 15:23:35 by Tao Zeng (tao.zeng.zt@qq.com)\n */\n\nexport const CONSTRUCTOR = 'constructor'\n\nexport const PROTOTYPE = 'prototype'\n\nexport const PROTO = '__proto__'\n\nexport const TYPE_BOOL = 'boolean'\n\nexport const TYPE_FN = 'function'\n\nexport const TYPE_NUM = 'number'\n\nexport const TYPE_STRING = 'string'\n\nexport const TYPE_UNDEF = 'undefined'\n\nexport const GLOBAL: any =\n\ttypeof window !== TYPE_UNDEF\n\t\t? window\n\t\t: typeof global !== TYPE_UNDEF\n\t\t? global\n\t\t: typeof self !== TYPE_UNDEF\n\t\t? self\n\t\t: {}\n\nexport interface ObjArray {\n\tlength: number;\n}\nexport  type IArray = any[] |string | IArguments | ObjArray\n","/**\n * type checker\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Mon Dec 03 2018 17:48:07 GMT+0800 (China Standard Time)\n */\n\nimport { CONSTRUCTOR, GLOBAL, TYPE_BOOL, TYPE_FN, TYPE_NUM, TYPE_STRING, TYPE_UNDEF } from './consts'\n\n/**\n * is equals\n * > o1 === o2 || NaN === NaN\n */\nexport function eq(o1: any, o2: any): boolean {\n\treturn o1 === o2 || (o1 !== o1 && o2 !== o2)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    primitive type                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * is null\n */\nexport function isNull(o: any): boolean {\n\treturn o === null\n}\n\n/**\n * is undefined\n */\nexport function isUndef(o: any): boolean {\n\treturn o === undefined\n}\n\n/**\n * is null or undefined\n */\nexport function isNil(o: any): boolean {\n\treturn o === null || o === undefined\n}\n\n/**\n * is boolean\n */\nexport const isBool: (o: any) => boolean = mkIsPrimitive(TYPE_BOOL)\n\n/**\n * is a number\n */\nexport const isNum: (o: any) => boolean = mkIsPrimitive(TYPE_NUM)\n\n/**\n * is a string\n */\nexport const isStr: (o: any) => boolean = mkIsPrimitive(TYPE_STRING)\n\n/**\n * is a function\n */\nexport const isFn: (o: any) => boolean = mkIsPrimitive(TYPE_FN)\n\n/**\n * is integer number\n */\nexport function isInt(o: any): boolean {\n\treturn o === 0 || (o ? typeof o === TYPE_NUM && o % 1 === 0 : false)\n}\n\n/**\n * is primitive type\n * - null\n * - undefined\n * - boolean\n * - number\n * - string\n * - function\n */\nexport function isPrimitive(o: any): boolean {\n\tif (o === undefined || o === null) {\n\t\treturn true\n\t}\n\tswitch (typeof o) {\n\t\tcase TYPE_BOOL:\n\t\tcase TYPE_NUM:\n\t\tcase TYPE_STRING:\n\t\tcase TYPE_FN:\n\t\t\treturn true\n\t}\n\treturn false\n}\n\nfunction mkIsPrimitive(type: string): (o: any) => boolean {\n\treturn function is(o: any): boolean {\n\t\treturn typeof o === type\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    reference type                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * is instanceof\n */\nexport function instOf(obj: any, Cls: Function): boolean {\n\treturn obj !== undefined && obj !== null && obj instanceof Cls\n}\n\n/**\n * is child instance of Type\n */\nexport function is(o: any, Type: Function | Function[]): boolean {\n\tif (o !== undefined && o !== null) {\n\t\tconst C = o[CONSTRUCTOR] || Object\n\t\tif (Type[CONSTRUCTOR] === Array) {\n\t\t\tvar i = Type.length\n\t\t\twhile (i--) {\n\t\t\t\tif (C === (Type as Function[])[i]) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn C === Type\n\t\t}\n\t}\n\treturn false\n}\n\n/**\n * is boolean or Boolean\n */\nexport const isBoolean: (o: any) => boolean = mkIs(Boolean)\n\n/**\n * is number or Number\n */\nexport const isNumber: (o: any) => boolean = mkIs(Number)\n\n/**\n * is string or String\n */\nexport const isString: (o: any) => boolean = mkIs(String)\n\n/**\n * is Date\n */\nexport const isDate: (o: any) => boolean = mkIs(Date)\n\n/**\n * is RegExp\n */\nexport const isReg: (o: any) => boolean = mkIs(RegExp)\n\n/**\n * is Array\n */\nexport const isArray: (o: any) => boolean = Array.isArray || mkIs(Array)\n\n/**\n * is Typed Array\n */\nexport const isTypedArray: (o: any) => boolean = isFn(ArrayBuffer) ? ArrayBuffer.isView : () => false\n\n/**\n * is Array or pseudo-array\n * - Array\n * - String\n * - IArguments\n * - NodeList\n * - HTMLCollection\n * - Typed Array\n * - {length: int, [length-1]: any}\n */\nexport function isArrayLike(o: any): boolean {\n\tif (o) {\n\t\tswitch (o[CONSTRUCTOR]) {\n\t\t\tcase Array:\n\t\t\tcase String:\n\t\t\tcase GLOBAL.NodeList:\n\t\t\tcase GLOBAL.HTMLCollection:\n\t\t\tcase GLOBAL.Int8Array:\n\t\t\tcase GLOBAL.Uint8Array:\n\t\t\tcase GLOBAL.Int16Array:\n\t\t\tcase GLOBAL.Uint16Array:\n\t\t\tcase GLOBAL.Int32Array:\n\t\t\tcase GLOBAL.Uint32Array:\n\t\t\tcase GLOBAL.Float32Array:\n\t\t\tcase GLOBAL.Float64Array:\n\t\t\t\treturn true\n\t\t}\n\t\tconst len = o.length\n\t\treturn typeof len === TYPE_NUM && (len === 0 || (len > 0 && len % 1 === 0 && len - 1 in o))\n\t}\n\treturn o === ''\n}\n\n/**\n * is simple Object\n * TODO object may has constructor property\n */\nexport function isObj(o: any): boolean {\n\tif (o === undefined || o === null) {\n\t\treturn false\n\t}\n\tconst C = o[CONSTRUCTOR]\n\treturn C === undefined || C === Object\n}\n\nfunction mkIs(Type: Function): (o: any) => boolean {\n\treturn function is(o: any): boolean {\n\t\treturn o !== undefined && o !== null && o[CONSTRUCTOR] === Type\n\t}\n}\n\nconst blankStrReg = /^\\s*$/\n/**\n * is empty\n * - string: trim(string).length === 0\n * - array: array.length === 0\n * - pseudo-array: pseudo-array.length === 0\n */\nexport function isBlank(o: any): boolean {\n\tif (o) {\n\t\tif (o[CONSTRUCTOR] === String) {\n\t\t\treturn blankStrReg.test(o)\n\t\t}\n\t\treturn o.length === 0\n\t}\n\treturn true\n}\n","/**\n * Function utilities\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Fri Nov 23 2018 11:18:33 GMT+0800 (China Standard Time)\n */\n\nimport { GLOBAL, PROTOTYPE } from './consts'\nimport { isNil } from './is'\n\n// ========================================================================================\n/*                                                                                      *\n *                                    create function                                   *\n *                                                                                      */\n// ========================================================================================\n\n/**\n * create function by code string\n * @param body\tfunction body\n * @param args\tfunction argument names\n * @param name\tfunction name\n */\nexport function createFn<T extends Function>(body: string, args?: string[], name?: string): T {\n\treturn name\n\t\t? Function(`return function ${name}(${args ? args.join(', ') : ''}){${body}}`)()\n\t\t: applyScope(Function, Function, args && args.length ? args.concat(body) : [body])\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                    function apply                                    *\n *                                                                                      */\n// ========================================================================================\n\n/**\n * generate apply function\n */\nfunction applyBuilder<T extends Function>(maxArgs: number, scope: any, offset: any): T {\n\tscope = scope ? 'scope' : ''\n\toffset = offset ? 'offset' : ''\n\tconst args = new Array(maxArgs + 1)\n\tconst cases = new Array(maxArgs + 1)\n\tfor (let i = 0; i <= maxArgs; i++) {\n\t\targs[i] = `${i || scope ? ', ' : ''}args[${offset ? `offset${i ? ' + ' + i : ''}` : i}]`\n\t\tcases[i] = `case ${i}: return fn${scope && '.call'}(${scope}${args.slice(0, i).join('')});`\n\t}\n\treturn Function(`return function(fn, ${scope && scope + ', '}args${offset && ', offset, len'}){\nswitch(${offset ? 'len' : 'args.length'}){\n${cases.join('\\n')}\n}\n${offset &&\n\t\t`var arr = new Array(len);\nfor(var i=0; i<len; i++) arr[i] = arr[offset + i];`}\nreturn fn.apply(${scope || 'null'}, ${offset ? 'arr' : 'args'});\n}`)()\n}\n\n/**\n * apply function with scope\n * @param fn\ttarget function\n * @param scope\tscope of function\n * @param args\targuments of function\n */\nexport const applyScope: (fn: Function, scope: any, args: any[] | IArguments) => any = applyBuilder(8, 1, 0)\n\n/**\n * apply function without scope\n * @param fn\t\ttarget function\n * @param args\targuments of function\n */\nexport const applyNoScope: (fn: Function, args: any[] | IArguments) => any = applyBuilder(8, 0, 0)\n\n/**\n * apply function with scope\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport const applyScopeN: (\n\tfn: Function,\n\tscope: any,\n\targs: any[] | IArguments,\n\toffset: number,\n\tlen: number\n) => any = applyBuilder(8, 1, 1)\n\n/**\n * apply function without scope\n * @param fn\t\ttarget function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport const applyNoScopeN: (fn: Function, args: any[] | IArguments, offset: number, len: number) => any = applyBuilder(\n\t8,\n\t0,\n\t1\n)\n\n/**\n * apply function\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n */\nexport function apply(fn: Function, scope: any, args: any[] | IArguments): any {\n\tif (scope === undefined || scope === null || scope === GLOBAL) {\n\t\treturn applyNoScope(fn, args || [])\n\t}\n\treturn applyScope(fn, scope, args || [])\n}\n\n/**\n * apply function\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport function applyN(fn: Function, scope: any, args: any[] | IArguments, offset: number, len: number): any {\n\tif (scope === undefined || scope === null || scope === GLOBAL) {\n\t\treturn applyNoScopeN(fn, args, offset, len)\n\t}\n\treturn applyScopeN(fn, scope, args, offset, len)\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                     function name                                    *\n *                                                                                      */\n// ========================================================================================\n\nconst varGenReg = /\\$\\d+$/\n\n/**\n * get function name\n */\nexport function fnName(fn: Function): string {\n\tconst name: string = (fn as any).name\n\treturn name ? name.replace(varGenReg, '') : 'anonymous'\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                         bind                                         *\n *                                                                                      */\n// ========================================================================================\n\nlet _bind\nconst funcProto = Function[PROTOTYPE]\nif (funcProto.bind) {\n\t_bind = function bind<T extends Function>(fn: T, scope: any): T {\n\t\tconst args = arguments,\n\t\t\targLen = args.length\n\t\tif (isNil(scope)) {\n\t\t\treturn argLen > 2 ? bindPolyfill(fn, scope, args, 2) : fn\n\t\t}\n\t\treturn applyScopeN(fn.bind, fn, args, 1, argLen - 1)\n\t}\n} else {\n\tfuncProto.bind = function bind(scope) {\n\t\treturn bindPolyfill(this, scope, arguments, 1)\n\t}\n\t_bind = function bind<T extends Function>(fn: T, scope: any): T {\n\t\treturn bindPolyfill(fn, scope, arguments, 2)\n\t}\n}\n\n/**\n * bind scope or arguments on function\n * - return source function when without arguments and scope is undefined or null\n * - only bind arguments when scope is undefined or null, well can call the new function proxy with some scope\n *\n * @example\n * \t\tfunction example() {\n * \t\t\tconsole.log(this, arguments);\n * \t\t}\n * \t\tvar proxy = bind(example, null) \t// proxy === example\n * \t\tproxy() \t\t\t\t\t\t\t// log: window | undefined, []\n * \t\tproxy.call(1) \t\t\t\t\t\t// log: 1, []\n *\n * \t\tproxy = bind(example, null, 1) \t\t// proxy !== example\n * \t\tproxy() \t\t\t\t\t\t\t// log: window | undefined, [1]\n * \t\tproxy(2) \t\t\t\t\t\t\t// log: window | undefined, [1, 2]\n * \t\tproxy.call(1, 2) \t\t\t\t\t// log: 1, [1, 2]\n *\n * \t\tproxy = bind(example, {}, 1, 2)\t\t// proxy !== example\n * \t\tproxy() \t\t\t\t\t\t\t// log: {}, [1]\n * \t\tproxy(2) \t\t\t\t\t\t\t// log: {}, [1, 2, 2]\n * \t\tproxy.call(1, 2) \t\t\t\t\t// log: {}, [1, 2, 2]\n *\n * @param fn\tsource function\n * @param scope\tbind scope\n * @param args\tbind arguments\n * @return function proxy\n */\nexport const bind: <T extends Function>(fn: T, scope: any, ...args: any[]) => T = _bind\n\n/**\n * bind\n * > not bind scope when scope is null or undefined\n * @param fn\t\tsource function\n * @param scope\t\tbind scope\n * @param args\t\tbind arguments\n * @param argOffset\toffset of args\n * @return function proxy\n */\nfunction bindPolyfill<T extends Function>(fn: T, scope: any, bindArgs: any[] | IArguments, argOffset: number): T {\n\tconst argLen = bindArgs.length - argOffset\n\tif (scope === undefined) {\n\t\tscope = null\n\t}\n\tif (argLen > 0) {\n\t\t// bind with arguments\n\t\treturn function bindProxy() {\n\t\t\tconst args = arguments\n\t\t\tlet i = args.length\n\t\t\tif (i) {\n\t\t\t\tconst params = new Array(argLen + i)\n\t\t\t\twhile (i--) {\n\t\t\t\t\tparams[argLen + i] = args[i]\n\t\t\t\t}\n\t\t\t\ti = argLen\n\t\t\t\twhile (i--) {\n\t\t\t\t\tparams[i] = bindArgs[i + argOffset]\n\t\t\t\t}\n\t\t\t\treturn apply(fn, scope === null ? this : scope, params) // call with scope or this\n\t\t\t}\n\t\t\treturn applyN(fn, scope === null ? this : scope, bindArgs, argOffset, argLen) // call with scope or this\n\t\t} as any\n\t}\n\tif (scope === null) {\n\t\treturn fn\n\t}\n\tif (scope === GLOBAL) {\n\t\t// bind on GLOBAL\n\t\treturn function bindProxy() {\n\t\t\treturn applyNoScope(fn, arguments)\n\t\t} as any\n\t}\n\treturn function bindProxy() {\n\t\treturn applyScope(fn, scope, arguments)\n\t} as any\n}\n","/**\n * regexp utilities\n * @module utility/reg\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Sep 06 2018 18:27:51 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 20:00:44 GMT+0800 (China Standard Time)\n */\n\nimport { isBool } from './is'\n\n/**\n * is support sticky on RegExp\n */\nexport const regStickySupport = isBool(/(?:)/.sticky)\n\n/**\n * is support unicode on RegExp\n */\nexport const regUnicodeSupport = isBool(/(?:)/.unicode)\n\nconst REG_ESCAPE = /[-\\/\\\\^$*+?.()|[\\]{}]/g\n\n/**\n * escape string for RegExp\n */\nexport function reEscape(str: string): string {\n\treturn str.replace(REG_ESCAPE, '\\\\$&')\n}\n","/**\n * prototype utilities\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:23:56 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 20:00:18 GMT+0800 (China Standard Time)\n */\nimport { CONSTRUCTOR, PROTO, PROTOTYPE } from './consts'\n\nconst __hasOwn = Object[PROTOTYPE].hasOwnProperty\nconst __getProto = Object.getPrototypeOf,\n\t____setProto = Object.setPrototypeOf\n\n/**\n * is support Object.getPrototypeOf and Object.setPrototypeOf\n */\nexport const prototypeOfSupport = !!____setProto\n\nexport const protoPropSupport = { __proto__: [] } instanceof Array\n\n/**\n * Object.getPrototypeOf shim\n */\nexport const protoOf: (o: any) => any = ____setProto\n\t? __getProto\n\t: __getProto\n\t? function getPrototypeOf(obj) {\n\t\t\treturn obj[PROTO] || __getProto(obj)\n\t  }\n\t: function getPrototypeOf(obj) {\n\t\t\treturn (__hasOwn.call(obj, PROTO) ? obj[PROTO] : obj[CONSTRUCTOR][PROTOTYPE]) || null\n\t  }\n\nexport const __setProto: <T>(obj: any, proto: any) => any =\n\t____setProto ||\n\tfunction setPrototypeOf(obj, proto) {\n\t\tobj[PROTO] = proto\n\t\treturn obj\n\t}\n\n/**\n * Object.setPrototypeOf shim\n */\nexport const setProto: <T>(obj: any, proto: any) => any =\n\t____setProto ||\n\t(protoPropSupport\n\t\t? __setProto\n\t\t: function setPrototypeOf(obj, proto) {\n\t\t\t\tfor (let p in proto) {\n\t\t\t\t\tif (__hasOwn.call(proto, p)) {\n\t\t\t\t\t\tobj[p] = proto[p]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn __setProto(obj, proto)\n\t\t  })\n","/**\n * prop utilities\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:22:57 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 20:00:13 GMT+0800 (China Standard Time)\n */\nimport { PROTO, PROTOTYPE } from './consts'\nimport { protoPropSupport } from './proto'\n\nconst __hasOwn = Object[PROTOTYPE].hasOwnProperty\n\n/**\n * has own property\n */\nexport const hasOwnProp: (obj: any, prop: string) => boolean = protoPropSupport\n\t? function hasOwnProp(obj: any, prop: string): boolean {\n\t\t\treturn __hasOwn.call(obj, prop)\n\t  }\n\t: function hasOwnProp(obj: any, prop: string): boolean {\n\t\t\treturn prop !== PROTO && __hasOwn.call(obj, prop)\n\t  }\n\n/**\n * get owner property value\n * @param prop \t\t\tproperty name\n * @param defaultVal \tdefault value\n */\nexport function getOwnProp(obj: any, prop: string, defaultVal?: any): any {\n\treturn hasOwnProp(obj, prop) ? obj[prop] : defaultVal\n}\n\nlet __defProp = Object.defineProperty\n/**\n * is support Object.defineProperty\n */\nexport const defPropSupport: boolean =\n\t__defProp &&\n\t(function() {\n\t\ttry {\n\t\t\tvar val,\n\t\t\t\tobj: any = {}\n\t\t\t__defProp(obj, 's', {\n\t\t\t\tget() {\n\t\t\t\t\treturn val\n\t\t\t\t},\n\t\t\t\tset(value) {\n\t\t\t\t\tval = value\n\t\t\t\t}\n\t\t\t})\n\t\t\tobj.s = 1\n\t\t\treturn obj.s === val\n\t\t} catch (e) {}\n\t})()\n\nif (!defPropSupport) {\n\t__defProp = function defineProperty(\n\t\tobj: any,\n\t\tprop: string | number | symbol,\n\t\tdesc: PropertyDescriptor & ThisType<any>\n\t): any {\n\t\tif (desc.get || desc.set) {\n\t\t\tthrow new Error('not support getter/setter on defineProperty')\n\t\t}\n\t\tobj[prop] = desc.value\n\t\treturn obj\n\t}\n}\n\n/**\n * define property\n */\nexport const defProp = __defProp\n\n/**\n * define property by value\n */\nexport const defPropValue: <V>(\n\tobj: any,\n\tprop: string,\n\tvalue: V,\n\tconfigurable?: boolean,\n\twritable?: boolean,\n\tenumerable?: boolean\n) => V = defPropSupport\n\t? function defPropValue(obj, prop, value, configurable, writable, enumerable) {\n\t\t\t__defProp(obj, prop, {\n\t\t\t\tvalue,\n\t\t\t\tconfigurable: configurable || false,\n\t\t\t\twritable: writable || false,\n\t\t\t\tenumerable: enumerable || false\n\t\t\t})\n\t\t\treturn value\n\t  }\n\t: function defPropValue(obj, prop, value) {\n\t\t\tobj[prop] = value\n\t\t\treturn value\n\t  }\n","/**\n * Object.create shim\n * @module utility/create\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:24:47 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 15:37:23 GMT+0800 (China Standard Time)\n */\n\nimport { CONSTRUCTOR, PROTOTYPE } from './consts'\nimport { defProp, hasOwnProp } from './prop'\nimport { __setProto } from './proto'\n\nfunction __() {}\n\n/**\n * create shim\n */\nfunction doCreate(o: object | null, props?: PropertyDescriptorMap & ThisType<any>): object {\n\t__[PROTOTYPE] = o\n\tconst obj = new __()\n\t__[PROTOTYPE] = null\n\tif (props) {\n\t\tvar k, v\n\t\tfor (k in props) {\n\t\t\tif (hasOwnProp(props, k)) {\n\t\t\t\tdefProp(obj, k, props[k])\n\t\t\t}\n\t\t}\n\t}\n\treturn obj\n}\n\n/**\n * create object\n */\nexport default Object.create ||\n\t(Object.getPrototypeOf\n\t\t? doCreate\n\t\t: function create(o: object | null, props?: PropertyDescriptorMap & ThisType<any>): object {\n\t\t\t\tconst obj = doCreate(o, props)\n\t\t\t\t__setProto(obj, o)\n\t\t\t\treturn obj\n\t\t  })\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:10:41 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 14:17:32 GMT+0800 (China Standard Time)\n */\nexport class Control {\n\tprivate desc: string\n\tconstructor(desc: string) {\n\t\tthis.desc = desc\n\t}\n\ttoString() {\n\t\treturn this.desc\n\t}\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:10:41 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:39:11 GMT+0800 (China Standard Time)\n */\nimport { Control } from './control'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { hasOwnProp } from '../prop'\nimport { isArrayLike, isBool } from '../is'\n\n/**\n * STOP Control\n * > stop each/map/indexOf...\n */\nexport const STOP = new Control('STOP')\n//========================================================================================\n/*                                                                                      *\n *                                each object properties                                *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on object\n * - will stop each on return STOP\n */\nexport type EachPropCallback = (prop: string, obj: object) => Control | void\n\n/**\n * each properties\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties, default: true\n * @return stoped property name or false\n */\nexport function eachProps(obj: object, callback: EachPropCallback, own: boolean): false | string\nexport function eachProps(obj: object, callback: EachPropCallback, scope?: any, own?: boolean): false | string\nexport function eachProps(obj: object, callback: EachPropCallback, scope?: any, own?: boolean): false | string {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tlet k: string\n\tif (own === false) {\n\t\tfor (k in obj) if (callback(k, obj) === STOP) return k\n\t} else {\n\t\tfor (k in obj) if (hasOwnProp(obj, k) && callback(k, obj) === STOP) return k\n\t}\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      each object                                     *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on object\n * - will stop each on callback return STOP\n */\nexport type EachObjCallback = (value: any, prop: string, obj: object) => Control | void\n\n/**\n * each object\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties, default: true\n * @return stoped property name or false\n */\nexport function eachObj(obj: object, callback: EachObjCallback, own: boolean): false | string\nexport function eachObj(obj: object, callback: EachObjCallback, scope?: any, own?: boolean): false | string\nexport function eachObj(obj: object, callback: EachObjCallback, scope?: any, own?: boolean): false | string {\n\tconst args = arguments\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tlet k: string\n\tif (own === false) {\n\t\tfor (k in obj) if (callback(obj[k], k, obj) === STOP) return k\n\t} else {\n\t\tfor (k in obj) if (hasOwnProp(obj, k) && callback(obj[k], k, obj) === STOP) return k\n\t}\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      each array                                      *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on array\n * - will stop each on callback return STOP\n */\nexport type EachArrayCallback = (data: any, index: number, array: IArray) => Control | void\n\n/**\n * each array\n * - will stop each on callback return STOP\n * @param array\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @return stoped index or false\n */\nexport function eachArray(array: IArray, callback: EachArrayCallback, scope?: any): false | number {\n\tcallback = bind(callback, scope)\n\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\tif (callback(array[i], i, array) === STOP) return i\n\t}\n\treturn false\n}\n\n/**\n * reverse each array\n * - will stop each on callback return STOP\n * @param array\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @return stoped index or false\n */\nexport function reachArray(array: IArray, callback: EachArrayCallback, scope?: any): false | number {\n\tcallback = bind(callback, scope)\n\tlet i = array.length\n\twhile (i--) if (callback(array[i], i, array) === STOP) return i\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         each                                         *\n *                                                                                      */\n//========================================================================================\n\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: IArray,\n\tcallback: EachArrayCallback,\n\tscope?: any\n): false | number\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object,\n\tcallback: EachObjCallback,\n\town?: boolean\n): false | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object,\n\tcallback: EachObjCallback,\n\tscope?: any,\n\town?: boolean\n): false | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\town?: boolean\n): false | number | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\tscope?: any,\n\town?: boolean\n): false | number | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: any,\n\tcallback: any,\n\tscope?: any,\n\town?: boolean\n): false | number | string {\n\tif (isArrayLike(obj)) return _eachArray(obj, callback, scope)\n\treturn _eachObj(obj, callback, scope, own)\n}\n\n/**\n * each\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties on object, default: true\n * @return stoped index or false\n */\n\nexport function each(obj: IArray, callback: EachArrayCallback, scope?: any): false | number\nexport function each(obj: object, callback: EachObjCallback, own?: boolean): false | string\nexport function each(obj: object, callback: EachObjCallback, scope?: any, own?: boolean): false | string\nexport function each(\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\town?: boolean\n): false | number | string\nexport function each(\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\tscope?: any,\n\town?: boolean\n): false | number | string\nexport function each(obj: any, callback: any, scope?: any, own?: boolean): false | number | string {\n\treturn doEach(eachArray, eachObj, obj, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:54:35 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport create from '../create'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool } from '../is'\n\n/**\n * SKIP Control\n * > skip map\n */\nexport const SKIP = new Control('SKIP')\n\n//========================================================================================\n/*                                                                                      *\n *                                    map object                                   *\n *                                                                                      */\n//========================================================================================\n\n/**\n * callback on object\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param value\tproperty value\n * @param prop\tproperty name\n * @param obj\tmap target\n */\nexport type MapObjCallback<T> = (callback: any, prop: string, obj: object) => T | Control\n\nexport function doMapObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\town?: boolean\n): { [key: string]: T }\nexport function doMapObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T }\nexport function doMapObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tconst copy: { [key: string]: T } = create(null)\n\teach(\n\t\tobj,\n\t\t(value, prop, obj) => {\n\t\t\tconst v = callback(value, prop, obj)\n\t\t\tif (v === STOP) return STOP\n\t\t\tif (v !== SKIP) copy[prop] = v as T\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn copy\n}\n\n/**\n * object: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param obj\t\tmap target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\tmap own properties, default: true\n */\nexport function mapObj<T>(obj: object, callback: MapObjCallback<T>, own?: boolean): { [key: string]: T }\nexport function mapObj<T>(obj: object, callback: MapObjCallback<T>, scope?: any, own?: boolean): { [key: string]: T }\nexport function mapObj<T>(obj: object, callback: MapObjCallback<T>, scope?: any, own?: boolean): { [key: string]: T } {\n\treturn doMapObj(eachObj, obj, callback, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     indexof Array                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * callback on array\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param data\titem data\n * @param index\titem index\n * @param array\tmap target\n */\nexport type MapArrayCallback<T> = (data: any, index: number, array: IArray) => T | Control\n\nexport function doMapArray<T>(each: typeof eachArray, array: IArray, callback: MapArrayCallback<T>, scope?: any): T[] {\n\tcallback = bind(callback, scope)\n\tconst copy: T[] = []\n\tlet j = 0\n\teach(array, (data, index, array) => {\n\t\tconst v = callback(data, index, array)\n\t\tif (v === STOP) return STOP\n\t\tif (v !== SKIP) copy[j++] = v as T\n\t})\n\treturn copy\n}\n\n/**\n * array: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param array\t\tmap target\n * @param value\t\tcallback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function mapArray<T>(array: IArray, callback: MapArrayCallback<T>, scope?: any): T[] {\n\treturn doMapArray(eachArray, array, callback, scope)\n}\n\n/**\n * revice array: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param array\t\tmap target\n * @param value\t\tmap value of callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function rmapArray<T>(array: IArray, callback: MapArrayCallback<T>, scope?: any): T[] {\n\treturn doMapArray(reachArray, array, callback, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       map                                       *\n *                                                                                      */\n//========================================================================================\n\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray,\n\tcallback: MapArrayCallback<T>,\n\tscope?: any\n): any[]\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\town?: boolean\n): { [key: string]: T }\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T }\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: any,\n\tcallback: any,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | any[] {\n\tif (isArrayLike(obj)) return doMapArray(eacharray, obj, callback, scope)\n\treturn doMapObj(eachobj, obj, callback, scope, own)\n}\n\n/**\n * map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param obj\t\tmap target\n * @param value\t\tmap value of callback\n * @param scope\t\tscope of callback\n * @param own\t\tmap own properties on object, default: true\n * @return array index or property name or -1\n */\nexport function map<T>(obj: IArray, callback: MapArrayCallback<T>, scope?: any): any[]\nexport function map<T>(obj: object, callback: MapObjCallback<T>, own?: boolean): { [key: string]: T }\nexport function map<T>(obj: object, callback: MapObjCallback<T>, scope?: any, own?: boolean): { [key: string]: T }\nexport function map<T>(\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function map<T>(\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function map<T>(obj: object | IArray, callback: any, scope?: any, own?: boolean): { [key: string]: T } | T[] {\n\treturn doMap(eachArray, eachObj, obj, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:38:16 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool, isFn, eq } from '../is'\n\nfunction parseCallback(value: any, scope: any) {\n\tif (isFn(value)) return bind(value, scope)\n\treturn function defaultHandler(data, idx, obj) {\n\t\treturn eq(data, value)\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    index of object                                   *\n *                                                                                      */\n//========================================================================================\n\n/**\n * indexOf callback on object\n * - will stop find on callback return STOP\n * @param value\tproperty value\n * @param prop\tproperty name\n * @param obj\t\tindexOf target\n * @return\n * - boolean: is finded\n * - void: find next\n * - STOP: stop find\n */\nexport type IdxOfObjCallback = (value: any, prop: string, obj: object) => boolean | Control | void\n\nexport function doIdxOfObj(each: typeof eachObj, obj: object, value: any, own?: boolean): -1 | string\nexport function doIdxOfObj(each: typeof eachObj, obj: object, value: IdxOfObjCallback, own?: boolean): -1 | string\nexport function doIdxOfObj(\n\teach: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback,\n\tscope?: any,\n\town?: boolean\n): -1 | string\n\nexport function doIdxOfObj(\n\teach: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback | any,\n\tscope?: any,\n\town?: boolean\n): -1 | string {\n\tif (isBool(scope)) {\n\t\town = scope\n\t\tscope = null\n\t}\n\tconst callback: IdxOfObjCallback = parseCallback(value, scope)\n\tlet idx: -1 | string = -1\n\teach(\n\t\tobj,\n\t\t(data, prop, obj) => {\n\t\t\tconst r = callback(data, prop, obj)\n\t\t\tif (r === true) {\n\t\t\t\tidx = prop\n\t\t\t\treturn STOP\n\t\t\t} else if (r === STOP) return r\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn idx\n}\n\n/**\n * object: indexOf\n * - will stop find on callback return STOP\n * @param obj\t\tfind target\n * @param callback\tfind value or callback\n * @param scope\t\tscope of callback\n * @param own\t\tfind own properties, default: true\n * @return property name or -1\n */\nexport function idxOfObj(obj: object, value: any, own?: boolean): -1 | string\nexport function idxOfObj(obj: object, value: IdxOfObjCallback, own?: boolean): -1 | string\nexport function idxOfObj(obj: object, value: IdxOfObjCallback, scope?: any, own?: boolean): -1 | string\nexport function idxOfObj(obj: object, value: IdxOfObjCallback | any, scope?: any, own?: boolean): -1 | string {\n\treturn doIdxOfObj(eachObj, obj, value, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     indexof Array                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * indexOf callback on array\n * - will stop find on callback return STOP\n * @param data\titem data\n * @param index\titem index\n * @param array\tindexOf target\n * @return\n * - boolean: is finded\n * - void: find next\n * - STOP: stop find\n */\nexport type IdxOfArrayCallback = (data: any, index: number, array: IArray) => boolean | Control | void\n\nexport function doIdxOfArray(each: typeof eachArray, array: IArray, value: any): number\nexport function doIdxOfArray(each: typeof eachArray, array: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function doIdxOfArray(\n\teach: typeof eachArray,\n\tarray: IArray,\n\tvalue: IdxOfArrayCallback | any,\n\tscope?: any\n): number {\n\tconst callback: IdxOfArrayCallback = parseCallback(value, scope)\n\tlet idx = -1\n\teach(array, (data, index, array) => {\n\t\tconst r = callback(data, index, array)\n\t\tif (r === true) {\n\t\t\tidx = index\n\t\t\treturn STOP\n\t\t} else if (r === STOP) return r\n\t})\n\treturn idx\n}\n\n/**\n * array: indexOf\n * - will stop find on callback return STOP\n * @param array\t\tfind target\n * @param value\t\tfind value or callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function idxOfArray(array: IArray, value: any): number\nexport function idxOfArray(array: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function idxOfArray(array: IArray, value: IdxOfArrayCallback | any, scope?: any): number {\n\treturn doIdxOfArray(eachArray, array, value, scope)\n}\n\n/**\n * revice array: indexOf\n * - will stop find on callback return STOP\n * @param array\t\tfind target\n * @param value\t\tfind value of callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function ridxOfArray(array: IArray, value: any): number\nexport function ridxOfArray(array: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function ridxOfArray(array: IArray, value: IdxOfArrayCallback | any, scope?: any): number {\n\treturn doIdxOfArray(reachArray, array, value, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       index of                                       *\n *                                                                                      */\n//========================================================================================\n// find by value\nexport function doIdxOf(eacharray: typeof eachArray, eachobj: typeof eachObj, obj: IArray, value: any): number\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tvalue: any,\n\town?: boolean\n): string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tvalue: any,\n\town?: boolean\n): number | string\n// find by callback\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray,\n\tvalue: IdxOfArrayCallback,\n\tscope?: any\n): number\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback,\n\town?: boolean\n): -1 | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback,\n\tscope?: any,\n\town?: boolean\n): -1 | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\town?: boolean\n): number | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\tscope?: any,\n\town?: boolean\n): number | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: any,\n\tvalue: any,\n\tscope?: any,\n\town?: boolean\n): number | string {\n\tif (isArrayLike(obj)) return doIdxOfArray(eacharray, obj, value, scope)\n\treturn doIdxOfObj(eachobj, obj, value, scope, own)\n}\n\n/**\n * indexOf\n * - will stop find on callback return STOP\n * @param obj\t\tfind target\n * @param value\t\tfind value of callback\n * @param scope\t\tscope of callback\n * @param own\t\tfind own properties on object, default: true\n * @return array index or property name or -1\n */\nexport function idxOf(obj: IArray, value: any): number | string\nexport function idxOf(obj: object, value: any, own?: boolean): number | string\nexport function idxOf(obj: object | IArray, value: any, own?: boolean): number | string\nexport function idxOf(obj: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function idxOf(obj: object, value: IdxOfObjCallback, own?: boolean): -1 | string\nexport function idxOf(obj: object, value: IdxOfObjCallback, scope?: any, own?: boolean): -1 | string\nexport function idxOf(\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\town?: boolean\n): number | string\nexport function idxOf(\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\tscope?: any,\n\town?: boolean\n): number | string\nexport function idxOf(obj: object | IArray, value: any, scope?: any, own?: boolean): number | string {\n\treturn doIdxOf(eachArray, eachObj, obj, value, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 14:02:39 GMT+0800 (China Standard Time)\n */\nimport { Control } from './control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool } from '../is'\n\n//========================================================================================\n/*                                                                                      *\n *                                     reduce object                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * reduce callback on object\n * - will stop reduce on return STOP\n */\nexport type ReduceObjCallback<T> = (accumulator: T, value: any, prop: string, obj: object) => T | Control\n\nexport function doReduceObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\town?: boolean\n): T\nexport function doReduceObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduceObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\teach(\n\t\tobj,\n\t\t(value, prop, obj) => {\n\t\t\tconst rs = callback(accumulator, value, prop, obj)\n\t\t\tif (rs === STOP) return STOP\n\t\t\taccumulator = rs as T\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn accumulator\n}\n\n/**\n * reduce object\n * - will stop reduce on callback return STOP\n * @param obj\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n * @param own\t\t\treduce own properties, default: true\n */\nexport function reduceObj<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, own?: boolean)\nexport function reduceObj<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, scope?: any, own?: boolean)\nexport function reduceObj<T>(\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\treturn doReduceObj(eachObj, obj, accumulator, callback, scope, own)\n}\n//========================================================================================\n/*                                                                                      *\n *                                     reduce array                                     *\n *                                                                                      */\n//========================================================================================\n\n/**\n * reduce callback on array\n * - will stop reduce on return STOP\n */\nexport type ReduceArrayCallback<T> = (accumulator: T, data: any, index: number, array: IArray) => T | Control\n\nexport function doReduceArray<T>(\n\teach: typeof eachArray,\n\tarray: IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T>,\n\tscope?: any\n): T {\n\tcallback = bind(callback, scope)\n\teach(array, (data, index, array) => {\n\t\tconst rs = callback(accumulator, data, index, array)\n\t\tif (rs === STOP) return STOP\n\t\taccumulator = rs as T\n\t})\n\treturn accumulator\n}\n\n/**\n * reduce array\n * - will stop reduce on callback return STOP\n * @param array\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n */\nexport function reduceArray<T>(array: IArray, accumulator: T, callback: ReduceArrayCallback<T>, scope?: any): T {\n\treturn doReduceArray(eachArray, array, accumulator, callback, scope)\n}\n\n/**\n * revice reduce array\n * - will stop reduce on callback return STOP\n * @param array\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n */\nexport function rreduceArray<T>(array: IArray, accumulator: T, callback: ReduceArrayCallback<T>, scope?: any): T {\n\treturn doReduceArray(reachArray, array, accumulator, callback, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        reduce                                        *\n *                                                                                      */\n//========================================================================================\n\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T>,\n\tscope?: any\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T> | ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\tif (isArrayLike(obj))\n\t\treturn doReduceArray(eacharray, obj as IArray, accumulator, callback as ReduceArrayCallback<T>, scope)\n\treturn doReduceObj(eachobj, obj as object, accumulator, callback as ReduceObjCallback<T>, scope, own)\n}\n\n/**\n * reduce\n * - will stop reduce on callback return STOP\n * @param obj\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n * @param own\t\t\treduce own properties of reduce object, default: true\n */\nexport function reduce<T>(obj: IArray, accumulator: T, callback: ReduceArrayCallback<T>, scope?: any): T\nexport function reduce<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, own?: boolean): T\nexport function reduce<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, scope?: any, own?: boolean): T\nexport function reduce<T>(\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\town?: boolean\n): T\nexport function reduce<T>(\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function reduce<T>(\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T> | ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\treturn doReduce(eachArray, eachObj, obj, accumulator, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Jul 26 2018 10:47:47 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:59:31 GMT+0800 (China Standard Time)\n */\nimport { Control } from './control'\nimport { STOP, eachObj, eachProps } from './each'\nimport { SKIP } from './map'\nimport { isBool, isFn } from '../is'\nimport { bind } from '../fn'\n\n//========================================================================================\n/*                                                                                      *\n *                                         keys                                         *\n *                                                                                      */\n//========================================================================================\n\nexport type ObjKeyHandler<T> = (prop: string, obj: object) => T | Control\n\nfunction defaultObjKeyHandler(prop: string, obj: object): any {\n\treturn prop\n}\nexport function doObjKeys<T>(each: typeof eachProps, obj: object, own?: boolean): T[]\nexport function doObjKeys<T>(each: typeof eachProps, obj: object, callback: ObjKeyHandler<T>, own?: boolean): T[]\nexport function doObjKeys<T>(\n\teach: typeof eachProps,\n\tobj: object,\n\tcallback: ObjKeyHandler<T>,\n\tscope?: any,\n\town?: boolean\n): T[]\nexport function doObjKeys<T>(\n\teach: typeof eachProps,\n\tobj: object,\n\tcallback_own?: ObjKeyHandler<T> | boolean,\n\tscope_own?: any,\n\town?: boolean\n): T[]\nexport function doObjKeys<T>(each: typeof eachProps, obj: object): T[] {\n\tconst rs: T[] = [],\n\t\targs = arguments\n\tlet handler: ObjKeyHandler<T> = defaultObjKeyHandler,\n\t\ti = 2,\n\t\tj = 0\n\tif (isFn(args[i])) {\n\t\thandler = args[i++]\n\t\tif (!isBool(args[i])) handler = bind(handler, args[i++])\n\t}\n\teach(\n\t\tobj,\n\t\t(prop, obj) => {\n\t\t\tconst val = handler(prop, obj)\n\t\t\tif (val === STOP) return STOP\n\t\t\tif (val !== SKIP) rs[j++] = val as T\n\t\t},\n\t\tnull,\n\t\targs[i]\n\t)\n\treturn rs\n}\n\n/**\n * @param obj\t\ttarget\n * @param handler\tkey handler\n * @param scope\t\tscope or handler\n * @param own\t\tis get own properties, default: true\n */\nexport function keys<T>(obj: object, own?: boolean): T[]\nexport function keys<T>(obj: object, callback: ObjKeyHandler<T>, own?: boolean): T[]\nexport function keys<T>(obj: object, callback: ObjKeyHandler<T>, scope?: any, own?: boolean): T[]\nexport function keys<T>(obj: object, callback?: ObjKeyHandler<T> | boolean, scope?: any, own?: boolean): T[] {\n\treturn doObjKeys(eachProps, obj, callback, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        values                                        *\n *                                                                                      */\n//========================================================================================\n\nexport type ObjValueHandler<T> = (value: any, prop: string, obj: object) => T | Control\n\nfunction defaultObjValueHandler(value: any, prop: string, obj: object): any {\n\treturn value\n}\nexport function doObjValues<T>(each: typeof eachObj, obj: object, own?: boolean): T[]\nexport function doObjValues<T>(each: typeof eachObj, obj: object, callback: ObjValueHandler<T>, own?: boolean): T[]\nexport function doObjValues<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: ObjValueHandler<T>,\n\tscope?: any,\n\town?: boolean\n): T[]\nexport function doObjValues<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback_own?: ObjValueHandler<T> | boolean,\n\tscope_own?: any,\n\town?: boolean\n): T[]\nexport function doObjValues<T>(each: typeof eachObj, obj: object): T[] {\n\tconst rs: T[] = [],\n\t\targs = arguments\n\tlet handler: ObjValueHandler<T> = defaultObjValueHandler,\n\t\ti = 1,\n\t\tj = 0\n\tif (isFn(args[i])) {\n\t\thandler = args[i++]\n\t\tif (!isBool(args[i])) handler = bind(handler, args[i++])\n\t}\n\teach(\n\t\tobj,\n\t\tfunction(data, prop, obj) {\n\t\t\tconst val = handler(data, prop, obj)\n\t\t\tif (val === STOP) return STOP\n\t\t\tif (val !== SKIP) rs[j++] = val as T\n\t\t},\n\t\tnull,\n\t\targs[i]\n\t)\n\treturn rs\n}\n\n/**\n * @param obj\t\ttarget\n * @param handler\tvalue handler\n * @param scope\t\tscope or handler\n * @param own\t\tis get own properties, default: true\n */\nexport function values<T>(obj: object, own?: boolean): T[]\nexport function values<T>(obj: object, callback: ObjValueHandler<T>, own?: boolean): T[]\nexport function values<T>(obj: object, callback: ObjValueHandler<T>, scope?: any, own?: boolean): T[]\nexport function values<T>(obj: object, callback?: ObjValueHandler<T> | boolean, scope?: any, own?: boolean): T[] {\n\treturn doObjValues(eachObj, obj, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Fri Nov 16 2018 16:29:04 GMT+0800 (China Standard Time)\n * @modified Fri Nov 30 2018 17:42:28 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './control'\nimport { eachArray } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isFn, isStr, isArray } from '../is'\nimport create from '../create'\n\n/**\n * @return STOP or SKIP or [key: string, value: any]\n */\nexport type Arr2ObjCallback = (data: any, index: number, array: IArray) => Control | [string, any]\n\nexport function doArr2Obj(each: typeof eachArray, array: IArray, callback: Arr2ObjCallback, scope?: any): object {\n\tconst obj = create(null)\n\tcallback = bind(callback, scope)\n\teach(array, (data, index, array) => {\n\t\tconst r: Control | [string, any] = callback(data, index, array)\n\t\tif (isArray(r)) {\n\t\t\tobj[r[0]] = r[1]\n\t\t} else {\n\t\t\treturn r as Control\n\t\t}\n\t})\n\treturn obj\n}\n\n/**\n * convert array to object\n */\nexport function arr2obj(array: IArray, callback: Arr2ObjCallback, scope?: any): object {\n\treturn doArr2Obj(eachArray, array, callback, scope)\n}\n\n/**\n * convert array or string to object\n * @param array\n * @param val\tvalue or callback\n * @param split\tsplit char on string\n */\nexport function makeMap(array: IArray, val: Arr2ObjCallback, split?: string): object\nexport function makeMap(array: IArray, val?: any, split?: string): object\nexport function makeMap(array: IArray, val?: any, split?: string): object {\n\tif (isStr(array)) array = (array as string).split(isStr(split) ? split : ',')\n\treturn arr2obj(array, isFn(val) ? val : data => [data, val])\n}\n","import create from './create'\nimport { isArray } from './is'\nimport { mapArray } from './collection'\n\nconst pathCache: { [key: string]: string[] } = create(null)\n\n// prop | [index | \"string prop\" | 'string prop']\nconst pathReg = /(?:^|\\.)([a-zA-Z$_][\\w$]*)|\\[\\s*(?:(\\d+)|\"((?:[^\\\\\"]|\\\\.)*)\"|'((?:[^\\\\']|\\\\.)*)')\\s*\\]/g\n\nexport function parsePath(path: string | string[], cacheable?: boolean): string[]\nexport function parsePath(path, cacheable) {\n\tif (isArray(path)) return path\n\n\tlet array = pathCache[path]\n\tif (!array) {\n\t\tarray = []\n\t\tvar match,\n\t\t\tidx = 0,\n\t\t\tcidx,\n\t\t\ti = 0\n\t\twhile ((match = pathReg.exec(path))) {\n\t\t\tcidx = pathReg.lastIndex\n\t\t\tif (cidx !== idx + match[0].length) {\n\t\t\t\tthrow new SyntaxError(`Invalid Path: \"${path}\", unkown character[${path.charAt(idx)}] at offset:${idx}`)\n\t\t\t}\n\t\t\tarray[i++] = match[1] || match[2] || match[3] || match[4]\n\t\t\tidx = cidx\n\t\t}\n\t\tif (cacheable === false) return array\n\t\tpathCache[path] = array\n\t}\n\treturn array.slice()\n}\n\nexport function formatPath(path: string | string[]): string {\n\treturn isArray(path) ? mapArray(path, formatPathHandler).join('') : (path as string)\n}\n\nfunction formatPathHandler(prop: string): string {\n\treturn `[\"${String(prop).replace(\"'\", '\\\\\"')}\"]`\n}\n\nexport function get(obj, path) {\n\tpath = parsePath(path)\n\tconst l = path.length - 1\n\tif (l === -1) return obj\n\tlet i = 0\n\tfor (; i < l; i++) {\n\t\tobj = obj[path[i]]\n\t\tif (obj === null || obj === undefined) return undefined\n\t}\n\treturn obj ? obj[path[i]] : undefined\n}\n\nexport function set(obj, path, value) {\n\tpath = parsePath(path)\n\tconst l = path.length - 1\n\tif (l === -1) return\n\tlet attr,\n\t\tv,\n\t\ti = 0\n\tfor (; i < l; i++) {\n\t\tattr = path[i]\n\t\tv = obj[attr]\n\t\tif (!v) obj[attr] = v = {}\n\t\tobj = v\n\t}\n\tattr = path[i]\n\tobj[attr] = value\n}\n","/**\n * String utilities\n * @module utility/string\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Thu Dec 06 2018 18:45:25 GMT+0800 (China Standard Time)\n */\nimport { createFn } from './fn'\nimport { isNil, isFn, isNum } from './is'\nimport { get } from './propPath'\nimport create from './create'\n\n//========================================================================================\n/*                                                                                      *\n *                                       char code                                      *\n *                                                                                      */\n//========================================================================================\n\n/**\n * get char code\n * > string.charCodeAt\n */\nexport function charCode(str: string, index?: number): number {\n\treturn str.charCodeAt(index || 0)\n}\n\n/**\n * get char by char code\n * > String.fromCharCode\n */\nexport function char(code: number): string {\n\treturn String.fromCharCode(code)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         trim                                         *\n *                                                                                      */\n//========================================================================================\n\nconst TRIM_REG = /(^\\s+)|(\\s+$)/g\n\n/**\n * trim\n */\nexport function trim(str: string): string {\n\treturn str.replace(TRIM_REG, '')\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         case                                         *\n *                                                                                      */\n//========================================================================================\n\nconst FIRST_LOWER_LETTER_REG = /^[a-z]/\n\n/**\n * upper first char\n */\nexport function upperFirst(str: string): string {\n\treturn str.replace(FIRST_LOWER_LETTER_REG, upperHandler)\n}\n\nfunction upperHandler(m) {\n\treturn m.toUpperCase()\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                  parse string value                                  *\n *                                                                                      */\n//========================================================================================\n\n/**\n * convert any value to string\n * - undefined | null: ''\n * - NaN:\n * - Infinity:\n * - other: String(value)\n * TODO support NaN, Infinity\n */\nexport function strval(obj: any): string {\n\treturn isNil(obj) ? '' : String(obj)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        escape                                        *\n *                                                                                      */\n//========================================================================================\n\nconst STR_ESCAPE_MAP = {\n\t\t'\\n': '\\\\n',\n\t\t'\\t': '\\\\t',\n\t\t'\\f': '\\\\f',\n\t\t'\"': '\\\\\"',\n\t\t\"'\": \"\\\\'\"\n\t},\n\tSTR_ESCAPE = /[\\n\\t\\f\"']/g\n\nexport function escapeString(str: string): string {\n\treturn str.replace(STR_ESCAPE, str => STR_ESCAPE_MAP[str])\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                          pad                                         *\n *                                                                                      */\n//========================================================================================\n\nexport function pad(str: any, len: number, chr?: string, leftAlign?: boolean | number): string {\n\tstr = String(str)\n\tconst l = str.length\n\tif (l >= len) return str\n\n\tconst padding = new Array(len - l + 1).join(chr || ' ')\n\treturn leftAlign ? str + padding : padding + str\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                   plural & singular                                  *\n *                                                                                      */\n//========================================================================================\n\nfunction replacor(regs: ([RegExp, string])[]): (str: string) => string {\n\treturn function(str: string): string {\n\t\tfor (let i = 0, reg; i < 4; i++) {\n\t\t\treg = regs[i]\n\t\t\tif (reg[0].test(str)) return str.replace(reg[0], reg[1])\n\t\t}\n\t\treturn str\n\t}\n}\n\nexport const plural: (str: string) => string = replacor([\n\t[/([a-zA-Z]+[^aeiou])y$/, '$1ies'],\n\t[/([a-zA-Z]+[aeiou]y)$/, '$1s'],\n\t[/([a-zA-Z]+[sxzh])$/, '$1es'],\n\t[/([a-zA-Z]+[^sxzhy])$/, '$1s']\n])\n\nexport const singular: (str: string) => string = replacor([\n\t[/([a-zA-Z]+[^aeiou])ies$/, '$1y'],\n\t[/([a-zA-Z]+[aeiou])s$/, '$1'],\n\t[/([a-zA-Z]+[sxzh])es$/, '$1'],\n\t[/([a-zA-Z]+[^sxzhy])s$/, '$1']\n])\n\n//========================================================================================\n/*                                                                                      *\n *                                   thousand separate                                  *\n *                                                                                      */\n//========================================================================================\n\nexport const thousandSeparationReg = /(\\d)(?=(\\d{3})+(?!\\d))/g\nexport function thousandSeparate(number: number): string {\n\tconst split = String(number).split('.')\n\tsplit[0] = split[0].replace(thousandSeparationReg, '$1,')\n\treturn split.join('.')\n}\n","/**\n * @module utility/format\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 03 2018 19:46:41 GMT+0800 (China Standard Time)\n * @modified Thu Dec 06 2018 20:10:18 GMT+0800 (China Standard Time)\n */\n\nimport { createFn } from './fn'\nimport { isFn } from './is'\nimport { get, parsePath } from './propPath'\nimport create from './create'\nimport { pad, thousandSeparationReg, charCode } from './string'\n\n//========================================================================================\n/*                                                                                      *\n *                                      format Rule                                     *\n *                                                                                      */\n//========================================================================================\n\n//   0      1      2     3     4       5       6           7         8      9           10             11             12      13\n// [match, expr, index, prop, flags, width, width-idx, width-prop, fill, precision, precision-idx, precision-prop, cut-fill, type]\nconst paramIdxR = `(\\\\d+|\\\\$|@)`,\n\tparamPropR = `(?:\\\\{((?:[a-zA-Z$_][\\\\w$_]*|\\\\[(?:\\\\d+|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)*\"|'(?:[^\\\\\\\\']|\\\\\\\\.)*')\\\\])(?:\\\\.[a-zA-Z$_][\\\\w$_]*|\\\\[(?:\\\\d+|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)*\"|'(?:[^\\\\\\\\']|\\\\\\\\.)*')\\\\])*)\\\\})`,\n\twidthR = `(?:([1-9]\\\\d*)|&${paramIdxR}${paramPropR})`,\n\tfillR = `(?:=(.))`,\n\tcutSuffixR = `(?:=\"((?:[^\\\\\\\\\"]|\\\\\\\\.)*)\")`,\n\tformatReg = new RegExp(\n\t\t`\\\\\\\\.|(\\\\{${paramIdxR}?${paramPropR}?(?::([#,+\\\\- 0]*)(?:${widthR}${fillR}?)?(?:\\\\.${widthR}${cutSuffixR}?)?)?(?::?([a-zA-Z_][a-zA-Z0-9_$]*))?\\\\})`,\n\t\t'g'\n\t)\n\n//========================================================================================\n/*                                                                                      *\n *                                     format flags                                     *\n *                                                                                      */\n//========================================================================================\n\ntype FormatFlags = number\n\nexport const FORMAT_XPREFIX: FormatFlags = 0x1\nexport const FORMAT_PLUS: FormatFlags = 0x1\nexport const FORMAT_ZERO: FormatFlags = 0x2\nexport const FORMAT_SPACE: FormatFlags = 0x4\nexport const FORMAT_THOUSAND: FormatFlags = 0x8\nexport const FORMAT_LEFT: FormatFlags = 0x16\n\n// flags parser \n\nconst FLAG_MAPPING = {\n\t'#': FORMAT_XPREFIX,\n\t'+': FORMAT_PLUS,\n\t'0': FORMAT_ZERO,\n\t' ': FORMAT_SPACE,\n\t',': FORMAT_THOUSAND,\n\t'-': FORMAT_LEFT\n}\nfunction parseFlags(f: string): FormatFlags {\n\tlet flags: FormatFlags = 0\n\tif (f) {\n\t\tvar i = f.length\n\t\twhile (i--) flags |= FLAG_MAPPING[f.charAt(i)]\n\t}\n\treturn flags\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      Formatters                                      *\n *                                                                                      */\n//========================================================================================\n\ntype FormatCallback = (\n\tval: any,\n\tflags: FormatFlags,\n\twidth: number,\n\tprecision: number | undefined,\n\tcutSuffix: string\n) => string\n\ntype Formatter = {\n\tget: (obj: any, path: string[]) => any\n\tfmt: FormatCallback\n}\n\nconst formatters: {\n\t[k: string]: Formatter\n} = create(null)\n\nexport function extendFormatter(obj: { [key: string]: Formatter | FormatCallback }) {\n\tvar fmt, name\n\tfor (name in obj) {\n\t\tfmt = obj[name]\n\t\tif (isFn(fmt)) {\n\t\t\tformatters[name] = { fmt, get }\n\t\t} else if (isFn(fmt.fmt)) {\n\t\t\tformatters[name] = fmt\n\t\t}\n\t}\n}\n\nfunction getFormatter(name: string): Formatter {\n\tconst f = formatters[name || 's']\n\tif (f) return f\n\tthrow new Error(`Invalid Formatter: ${name}`)\n}\n\nfunction __doFormat(\n\tformatter: Formatter,\n\tval: any,\n\tflags: FormatFlags,\n\twidth: number,\n\tfill: string,\n\tprecision: number | undefined,\n\tcutSuffix: string\n): string {\n\tlet str = formatter.fmt(val, flags, width, precision, cutSuffix)\n\tif (width > str.length) str = pad(str, width, fill, flags & FORMAT_LEFT)\n\treturn str\n}\n\n//========================================================================================\n/*                                                                                      *\n *                           format by every parameter object                           *\n *                                                                                      */\n//========================================================================================\n\n/**\n * Syntax:\n * \t\t\t'{' (<parameter>)? ('!' <property>)? (':' (<flags>)? (<width>)? ('!' <property>)? ('=' <fill-char>)? ('.' <precision>  ('!' <property>)? )? )? (':'? <data-type>)? '}'\n * - parameter\n * \t\t- parameter index\n * \t\t\t{}\t\t\t\t\t\tformat by next unused argument\n * \t\t\t{<number>}\t\t\t\tformat by arguments[number]\n * \t\t\t{@}\t\t\t\t\t\tformat by current used argument\n * \t\t\t{$}\t\t\t\t\t\tformat by next unused argument\n * \t\t- property\n * \t\t\t{.<path>}\t\t\t\tget value on parameter by property path\n * \t\t\t\t\t\t\t\t\tSyntax: '.' (<propName> | '[' (<number> | <string>) ']') ('.' <propName> | '[' (<number> | <string>) ']')*\n * \t\t\t\t\t\t\t\t\teg. .abc.abc | .[\"abc\"]['abc'] | .abc[0] | .[0].abc\n * - flags\n * \t\tspace   prefix non-negative number with a space\n * \t\t+       prefix non-negative number with a plus sign\n * \t\t-       left-justify within the field\n * \t\t,\t\tthousand separation number\n * \t\t#       ensure the leading \"0\" for any octal\n * \t\t\t\tprefix non-zero hexadecimal with \"0x\" or \"0X\"\n * \t\t\t\tprefix non-zero binary with \"0b\" or \"0B\"\n * @example\n * \t\tformat('<{: d}>',  12);\t\t// return \"< 12>\"\n *\t\tformat('<{: d}>',   0);\t\t// return \"< 0>\"\n *\t\tformat('<{: d}>', -12);\t\t// return \"<-12>\"\n *\t\tformat('<{:+d}>',  12);\t\t// return \"<+12>\"\n *\t\tformat('<{:+d}>',   0);\t\t// return \"<+0>\"\n *\t\tformat('<{:+d}>', -12);\t\t// return \"<-12>\"\n *\t\tformat('<{:6s}>',  12);\t\t// return \"<    12>\"\n *\t\tformat('<{:-6s}>', 12);\t\t// return \"<12    >\"\n *\t\tformat('<{:#o}>',  12);\t\t// return \"<014>\"\n *\t\tformat('<{:#x}>',  12);\t\t// return \"<0xc>\"\n *\t\tformat('<{:#X}>',  12);\t\t// return \"<0XC>\"\n *\t\tformat('<{:#b}>',  12);\t\t// return \"<0b1100>\"\n *\t\tformat('<{:#B}>',  12);\t\t// return \"<0B1100>\"\n * - width\n * \t\t\t(<width>)? ('=' <fill-char>)? ('.' <precision>)?\n * \t\t- min width\n * \t\t- precision width\n * - data-type\n * - Rules\n * \t\t- property-path\n * \t\t\t\t(\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t[a-zA-Z$_][\\w$_]*|\n * \t\t\t\t\t\t\\[\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\\d+|\n * \t\t\t\t\t\t\t\"(?:[^\\\\\"]|\\\\.)*\"|\n * \t\t\t\t\t\t\t'(?:[^\\\\']|\\\\.)*'\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t\\]\n * \t\t\t\t\t)\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t\\.[a-zA-Z$_][\\w$_]*|\n * \t\t\t\t\t\t\\[\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\\d+|\n * \t\t\t\t\t\t\t\"(?:[^\\\\\"]|\\\\.)*\"|\n * \t\t\t\t\t\t\t'(?:[^\\\\']|\\\\.)*'\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t\\]\n * \t\t\t\t\t)*\n * \t\t\t\t)\n * \t\t- expression\n * \t\t\t/[^\\\\{]+|\t\t\t\t\t\t\t\t\t\t\t// escape\n * \t\t\t\\\\.|\t\t\t\t\t\t\t\t\t\t\t\t// escape\n * \t\t\t(\t\t\t\t\t\t\t\t\t\t\t\t\t// 1: expression\n * \t\t\t\t\\{\n * \t\t\t\t(\\d+|\\$|@)?\t\t\t\t\t\t\t\t\t\t// 2: parameter index\n * \t\t\t\t(?:!<property-path> )?\t\t\t\t\t\t\t// 3: property path of parameter\n * \t\t\t\t(?:\n * \t\t\t\t\t:\n * \t\t\t\t\t([#,+\\- ]*)\t\t\t\t\t\t\t\t\t// 4: flags\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t(\\d+)|\t\t\t\t\t\t\t\t// 5: width\n * \t\t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\t&\n * \t\t\t\t\t\t\t\t(\\d+|\\$|@)\t\t\t\t\t\t// 6: parameter index of width\n * \t\t\t\t\t\t\t\t(?:!<property-path>)?\t\t\t// 7: property path of width parameter\n * \t\t\t\t\t\t\t)\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t(?:=(.))?\t\t\t\t\t\t\t\t// 8: pad fill\n * \t\t\t\t\t)?\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t\\.\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t(\\d+)|\t\t\t\t\t\t\t\t// 9: width\n * \t\t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\t&\n * \t\t\t\t\t\t\t\t(\\d+|\\$|@)\t\t\t\t\t\t// 10: parameter index of width\n * \t\t\t\t\t\t\t\t(?:!<property-path>)?\t\t\t// 11: property path of width parameter\n * \t\t\t\t\t\t\t)\n * \t\t\t\t\t\t)\n * \t\t\t\t\t)?\n * \t\t\t\t)?\n * \t\t\t\t(?:\n * \t\t\t\t\t:?\n * \t\t\t\t\t([a-zA-Z_][a-zA-Z0-9_$]*))?\t\t\t\t\t// 12: data type\n * \t\t\t\t\\}\n * \t\t\t)/\n */\nexport function vformat<T>(fmt: string, args: T, offset?: number, getParam?: (args: T, idx: number) => any) {\n\toffset = offset || 0\n\tconst state: [number, number] = [offset, offset]\n\tgetParam = getParam || defaultGetParam\n\treturn fmt.replace(formatReg, function(\n\t\ts,\n\t\tm,\n\t\tparam,\n\t\tparamProp,\n\t\tflags,\n\t\twidth,\n\t\twidx,\n\t\twprop,\n\t\tfill,\n\t\tprecision,\n\t\tpidx,\n\t\tpprop,\n\t\tcutSuffix,\n\t\ttype\n\t) {\n\t\tif (!m) return s.charAt(1)\n\n\t\tconst formatter = getFormatter(type)\n\n\t\treturn __doFormat(\n\t\t\tformatter,\n\t\t\tparseParam(param || '$', paramProp, state, args, getParam),\n\t\t\tparseFlags(flags),\n\t\t\tparseWidth(width, widx, wprop, state, args, getParam) || 0,\n\t\t\tfill || ' ',\n\t\t\tparseWidth(precision, pidx, pprop, state, args, getParam),\n\t\t\tcutSuffix || ''\n\t\t)\n\t})\n}\n\nfunction parseWidth<T>(\n\twidth: string,\n\tidx: string | undefined,\n\tprop: string | undefined,\n\tstate: [number, number],\n\targs: T,\n\tgetParam: (args: T, idx: number) => any\n): number | undefined {\n\tif (width) return (width as any) >> 0\n\tif (idx) {\n\t\tconst w = parseParam(idx, prop, state, args, getParam) >> 0\n\t\tif (isFinite(w)) return w\n\t}\n}\n\nfunction parseParam<T>(\n\tparamIdx: string,\n\tprop: string | undefined,\n\tstate: [number, number],\n\targs: T,\n\tgetParam: (args: T, idx: number) => any\n): any {\n\tlet param = getParam(\n\t\targs,\n\t\tparamIdx === '$'\n\t\t\t? state[0]++\n\t\t\t: paramIdx === '@'\n\t\t\t? state[0] === state[1]\n\t\t\t\t? state[0]\n\t\t\t\t: state[0] - 1\n\t\t\t: (paramIdx as any) >> 0\n\t)\n\tif (prop) param = get(param, prop)\n\treturn param\n}\n\nfunction defaultGetParam(args: any, idx: number) {\n\treturn args[idx]\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        format                                        *\n *                                                                                      */\n//========================================================================================\n\nfunction getFormatParam(args: IArguments, idx: number) {\n\treturn args[idx + 1]\n}\n\n/**\n * @see vformat\n */\nexport function format(fmt: string, ...args: any): string\nexport function format(fmt: string): string {\n\treturn vformat(fmt, arguments, 0, getFormatParam)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       formatter                                      *\n *                                                                                      */\n//========================================================================================\n\nconst PROP1_VAR = 'p1',\n\tPROP2_VAR = 'p2',\n\tPROP3_VAR = 'p3',\n\tGET_PARAM_VAR = 'getp',\n\tGET_PROP_VAR = 'get',\n\tSTATE_VAR = 'state'\nfunction createFormatter(m: string[], getParam?: (args: IArguments, idx: number) => any) {\n\tconst formatter = getFormatter(m[13])\n\n\tconst p1 = m[3] && parsePath(m[3]),\n\t\tp2 = m[7] && parsePath(m[7]),\n\t\tp3 = m[11] && parsePath(m[11])\n\n\treturn createFn(\n\t\t`return function(args, ${STATE_VAR}){\n\treturn dofmt(fmt,\n\t\t${getParamCode(m[2] || '$', p1 && PROP1_VAR)},\n\t\tg,\n\t\t${getWidthCode(m[5], m[6], p2 && PROP2_VAR, '0')},\n\t\tf,\n\t\t${getWidthCode(m[9], m[10], p3 && PROP3_VAR, 'void 0')},\n\t\tcf);\n}`,\n\t\t['dofmt', 'fmt', 'g', 'f', 'cf', GET_PROP_VAR, GET_PARAM_VAR, PROP1_VAR, PROP2_VAR, PROP3_VAR]\n\t)(__doFormat, formatter, parseFlags(m[4]), m[8] || ' ', m[12] || '', get, getParam, p1, p2, p3)\n}\n\nfunction getWidthCode(width: string, idx: string, prop: string, def: string): string {\n\treturn width ? width : idx ? getParamCode(idx, prop) : def\n}\n\nfunction getParamCode(idx: string, prop: string): string {\n\tlet code = `${GET_PARAM_VAR}(args, ${\n\t\tidx === '$'\n\t\t\t? `${STATE_VAR}[0]++`\n\t\t\t: idx === '@'\n\t\t\t? `${STATE_VAR}[0] === ${STATE_VAR}[1] ? ${STATE_VAR}[0] : ${STATE_VAR}[0] - 1`\n\t\t\t: idx\n\t})`\n\tif (prop) return `${GET_PROP_VAR}(${code}, ${prop})`\n\treturn code\n}\n\nexport function formatter(\n\tfmt: string,\n\toffset?: number,\n\tgetParam?: (args: IArguments, idx: number) => any\n): (...args: any[]) => string {\n\tlet m,\n\t\tlastIdx = 0,\n\t\tmStart,\n\t\tmEnd,\n\t\tarr = [],\n\t\tcodes = [],\n\t\ti = 0\n\toffset = offset || 0\n\twhile ((m = formatReg.exec(fmt))) {\n\t\tmEnd = formatReg.lastIndex\n\t\tmStart = mEnd - m[0].length\n\t\tlastIdx < mStart && pushStr(fmt.substring(lastIdx, mStart), 0)\n\t\tif (m[1]) {\n\t\t\tcodes[i] = `arr[${i}](arguments, ${STATE_VAR})`\n\t\t\tarr[i++] = createFormatter(m, getParam || defaultGetParam)\n\t\t} else {\n\t\t\tpushStr(m[0].charAt(1), i)\n\t\t}\n\t\tlastIdx = mEnd\n\t}\n\tlastIdx < fmt.length && pushStr(fmt.substring(lastIdx), i)\n\treturn createFn(`return function(){var ${STATE_VAR} = [${offset}, ${offset}]; return ${codes.join(' + ')}}`, [\n\t\t'arr'\n\t])(arr)\n\n\tfunction pushStr(str, append) {\n\t\tif (append && arr[i - 1].length) {\n\t\t\tarr[i - 1] += str\n\t\t} else {\n\t\t\tcodes[i] = `arr[${i}]`\n\t\t\tarr[i++] = str\n\t\t}\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                  default formatters                                  *\n *                                                                                      */\n//========================================================================================\n\nconst TOEXPONENTIAL = 'toExponential',\n\tTOPRECISION = 'toPrecision',\n\tTOFIXED = 'toFixed'\n\nfunction floatFormatter(\n\ttype: string\n): (val: any, flags: FormatFlags, width: number, precision: number | undefined, cutSuffix: string) => string {\n\tconst toStr =\n\t\t\ttype === 'e' || type === 'E'\n\t\t\t\t? (num, precision) => num[TOEXPONENTIAL](precision)\n\t\t\t\t: type === 'f'\n\t\t\t\t? (num, precision) => precision >= 0 && num[TOFIXED](precision)\n\t\t\t\t: (num, precision) => precision && num[TOPRECISION](precision),\n\t\tupper = charCode(type) < 97\n\n\treturn function(val, flags, width, precision) {\n\t\tlet num = parseFloat(val)\n\t\tif (!isFinite(num)) return String(num)\n\n\t\tlet str = toStr(num, precision) || String(num)\n\n\t\tif (flags & FORMAT_THOUSAND) {\n\t\t\tvar split = str.split('.')\n\t\t\tsplit[0] = split[0].replace(thousandSeparationReg, '$1,')\n\t\t\tstr = split.join('.')\n\t\t}\n\t\tstr = prefixNum(num, str, flags, width)\n\t\treturn upper ? str.toUpperCase() : str\n\t}\n}\n\nconst BaseRadixs = {\n\tb: 2,\n\tB: 2,\n\to: 8,\n\tu: 10,\n\tx: 16,\n\tX: 16\n}\nconst BasePrefixs = ['0b', '0', '0x']\nfunction baseFormatter(\n\ttype: string\n): (val: any, flags: FormatFlags, width: number, precision: number | undefined, cutSuffix: string) => string {\n\tconst base = BaseRadixs[type],\n\t\txprefix = base != 10 ? BasePrefixs[base >> 3] : '',\n\t\tupper = charCode(type) < 97\n\treturn function(val, flags, width) {\n\t\tconst num = val >>> 0\n\t\tif (!isFinite(num)) return String(num)\n\t\tconst str = formatNum(num.toString(base), flags & FORMAT_XPREFIX ? xprefix : '', flags, width)\n\t\treturn upper ? str.toUpperCase() : str\n\t}\n}\n\nfunction cutStr(str: string, len: number, suffix: string) {\n\treturn len < str.length ? str.substr(0, len - suffix.length) + suffix : str\n}\nextendFormatter({\n\ts(val, flags, width, precision, cutSuffix) {\n\t\treturn cutStr(String(val), precision, cutSuffix)\n\t},\n\tj(val, flags, width, precision, cutSuffix) {\n\t\treturn cutStr(JSON.stringify(val), precision, cutSuffix)\n\t},\n\tc(val: any) {\n\t\tconst num = val >> 0\n\t\treturn num > 0 ? String.fromCharCode(num) : ''\n\t},\n\td(val: any, flags, width) {\n\t\tlet num = val >> 0\n\t\tif (!isFinite(num)) return String(num)\n\n\t\tlet str = String(num)\n\n\t\tif (flags & FORMAT_THOUSAND) str = str.replace(thousandSeparationReg, '$1,')\n\n\t\treturn prefixNum(num, str, flags, width)\n\t},\n\te: floatFormatter('e'),\n\tE: floatFormatter('E'),\n\tf: floatFormatter('f'),\n\tg: floatFormatter('g'),\n\tG: floatFormatter('G'),\n\tb: baseFormatter('b'),\n\tB: baseFormatter('B'),\n\to: baseFormatter('o'),\n\tu: baseFormatter('u'),\n\tx: baseFormatter('x'),\n\tX: baseFormatter('X')\n})\n\nfunction prefixNum(num: number, str: string, flags: FormatFlags, width: number) {\n\treturn formatNum(str, num < 0 ? '' : flags & FORMAT_PLUS ? '+' : flags & FORMAT_SPACE ? ' ' : '', flags, width)\n}\n\nfunction formatNum(str: string, prefix: string, flags: FormatFlags, width: number) {\n\tif (flags & FORMAT_ZERO && width > str.length - prefix.length) {\n\t\tstr = pad(str, width - prefix.length, '0')\n\t}\n\treturn prefix + str\n}\n","/**\n * Object.assign shim\n * @module utility/assign\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:22:13 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 14:03:59 GMT+0800 (China Standard Time)\n */\nimport { hasOwnProp } from './prop'\n\n/**\n * @param prop\n * @param target\n * @param override\n * @return is assign\n */\nexport type AssignFilter = (prop: string, target: any, override: any) => boolean\n\n/**\n *\n * @param target\n * @param overrides\n * @param filter\n * @param startOffset \tstart offset in overrides, default: 0\n * @param endOffset \tend offset in overrides, default: overrides.length-1\n */\nexport function doAssign(\n\ttarget: any,\n\toverrides: object[] | IArguments,\n\tfilter: AssignFilter,\n\tstartOffset?: number,\n\tendOffset?: number\n): any {\n\tif (!target) {\n\t\ttarget = {}\n\t}\n\tconst l = endOffset || overrides.length - 1\n\tlet i = startOffset || 0,\n\t\toverride,\n\t\tprop\n\tfor (; i < l; i++) {\n\t\tif ((override = overrides[i])) {\n\t\t\tfor (prop in override) {\n\t\t\t\tif (filter(prop, target, override)) {\n\t\t\t\t\ttarget[prop] = override[prop]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn target\n}\n\n/**\n * assign properties\n * > Object.assign shim\n */\nexport function assign(target: any, ...args: any[]): any\nexport function assign(target: any): any {\n\treturn doAssign(target, arguments, defaultAssignFilter, 1)\n}\n\n/**\n * assign un-exist properties\n */\nexport function assignIf(target: any, ...args: any[]): any\nexport function assignIf(target: any): any {\n\treturn doAssign(target, arguments, assignIfFilter, 1)\n}\n\n/**\n * default assign filter\n * - property is owner in override\n * @see {AssignFilter}\n */\nexport function defaultAssignFilter(prop: string, target: any, override: any): boolean {\n\treturn hasOwnProp(override, prop)\n}\n\n/**\n * assign if filter\n * - property is owner in override\n * - property not in target object\n * @see {AssignFilter}\n */\nexport function assignIfFilter(prop: string, target: any, override: any): boolean {\n\treturn hasOwnProp(override, prop) && !(prop in target)\n}\n","/**\n * Double Linked List\n * @module utility/List\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 19:56:25 GMT+0800 (China Standard Time)\n */\n\nimport { bind } from '../fn'\nimport { defPropValue } from '../prop'\n\nexport const DEFAULT_BINDING = '__list__'\n\nexport type ListElement = object | any[] | Function\ninterface ListNode extends Array<any> {\n\t0: ListElement\n\t1?: ListNode\n\t2?: ListNode\n\t3?: List\n}\n//type ListNode = [ListElement | void, IListNode | void, IListNode | void, List]\n\nexport class List {\n\tstatic binding: string = DEFAULT_BINDING\n\n\tlength: number = 0\n\thead?: ListNode\n\ttail?: ListNode\n\tbinding: string\n\tscaning: boolean = false\n\tlazyRemoves?: ListNode[]\n\tconstructor(binding?: string) {\n\t\tthis.binding = binding || DEFAULT_BINDING\n\t}\n\thas(obj: ListElement): boolean {\n\t\tconst node: ListNode | void = obj[this.binding]\n\t\treturn node ? node[0] === obj && node[3] === this : false\n\t}\n\tadd(obj: ListElement): number {\n\t\treturn __insert(this, obj, this.tail)\n\t}\n\taddFirst(obj: ListElement): number {\n\t\treturn __insert(this, obj)\n\t}\n\tinsertAfter(obj: ListElement, target?: ListElement): number {\n\t\treturn __insert(this, obj, target && __getNode(this, target))\n\t}\n\tinsertBefore(obj: ListElement, target?: ListElement): number {\n\t\treturn __insert(this, obj, target && __getNode(this, target)[1])\n\t}\n\taddAll(objs: ListElement[]): number {\n\t\treturn __insertAll(this, objs, this.tail)\n\t}\n\taddFirstAll(objs: ListElement[]): number {\n\t\treturn __insertAll(this, objs)\n\t}\n\tinsertAfterAll(objs: ListElement[], target?: ListElement): number {\n\t\treturn __insertAll(this, objs, target && __getNode(this, target))\n\t}\n\tinsertBeforeAll(objs: ListElement[], target?: ListElement): number {\n\t\treturn __insertAll(this, objs, target && __getNode(this, target)[1])\n\t}\n\tprev(obj: ListElement): ListElement {\n\t\treturn __siblingObj(this, obj, 1)\n\t}\n\tnext(obj: ListElement): ListElement {\n\t\treturn __siblingObj(this, obj, 2)\n\t}\n\tfirst(): ListElement {\n\t\tconst node: ListNode = this.head\n\t\treturn node && node[0]\n\t}\n\tlast(): ListElement {\n\t\tconst node: ListNode = this.tail\n\t\treturn node && node[0]\n\t}\n\tremove(obj: ListElement): number {\n\t\tconst node = __getNode(this, obj)\n\t\tif (this.scaning) {\n\t\t\tconst { lazyRemoves } = this\n\t\t\tobj[this.binding] = undefined // unbind list node\n\t\t\tnode[3] = undefined\n\t\t\tif (lazyRemoves) {\n\t\t\t\tlazyRemoves.push(node)\n\t\t\t} else {\n\t\t\t\tthis.lazyRemoves = [node]\n\t\t\t}\n\t\t} else {\n\t\t\t__remove(this, node)\n\t\t}\n\t\treturn --this.length\n\t}\n\teach(cb: (obj: ListElement) => boolean | void, scope?: any) {\n\t\tif (!this.scaning) throw new Error('Recursive calls are not allowed.')\n\t\tif (this.length) {\n\t\t\tthis.scaning = true\n\t\t\tcb = bind(cb, scope)\n\t\t\tvar node = this.head\n\t\t\twhile (node) {\n\t\t\t\tif (node[3] === this && cb(node[0]) === false) break\n\t\t\t\tnode = node[2]\n\t\t\t}\n\t\t\t__doLazyRemove(this)\n\t\t\tthis.scaning = false\n\t\t}\n\t}\n\ttoArray(): ListElement[] {\n\t\tconst array: ListElement[] = new Array(this.length)\n\t\tlet node = this.head,\n\t\t\ti = 0\n\t\twhile (node) {\n\t\t\tif (node[3] === this) array[i++] = node[0]\n\t\t\tnode = node[2]\n\t\t}\n\t\treturn array\n\t}\n\tclean() {\n\t\tif (this.length) {\n\t\t\tif (this.scaning) {\n\t\t\t\tconst { binding } = this\n\t\t\t\tconst lazyRemoves = this.lazyRemoves || (this.lazyRemoves = [])\n\t\t\t\tvar node = this.head\n\t\t\t\twhile (node) {\n\t\t\t\t\tif (node[3] === this) {\n\t\t\t\t\t\tnode[0][binding] = undefined\n\t\t\t\t\t\tlazyRemoves.push(node)\n\t\t\t\t\t}\n\t\t\t\t\tnode = node[2]\n\t\t\t\t}\n\t\t\t\tthis.length = 0\n\t\t\t} else {\n\t\t\t\t__clean(this)\n\t\t\t}\n\t\t}\n\t}\n\tclone(cb: (obj: ListElement) => ListElement, scope?: any) {\n\t\tconst newlist = new List(this.binding)\n\t\tif (this.length) {\n\t\t\tcb = bind(cb, scope)\n\t\t\tvar node = this.head,\n\t\t\t\tnewtail,\n\t\t\t\tnewhead,\n\t\t\t\tnewprev = undefined,\n\t\t\t\ti = 0\n\t\t\twhile (node) {\n\t\t\t\tif (node[3] === this && (newtail = cb(node[0]))) {\n\t\t\t\t\tnewtail = __initNode(newlist, newtail)\n\n\t\t\t\t\tif (!newtail[3]) throw new Error('Double add List, Clone Callback should return a new Object')\n\n\t\t\t\t\tnewtail[3] = newlist\n\t\t\t\t\tif (newprev) {\n\t\t\t\t\t\tnewtail[1] = newprev\n\t\t\t\t\t\tnewprev[2] = newtail\n\t\t\t\t\t\tnewprev = newtail\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewprev = newhead = newtail\n\t\t\t\t\t}\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t\tnode = node[2]\n\t\t\t}\n\t\t\ti && __doInsert(newlist, newhead, newtail, i)\n\t\t}\n\t\treturn newlist\n\t}\n}\n\nfunction __doInsert(list: List, nodeHead: ListNode, nodeTail: ListNode, len: number, prev?: ListNode): number {\n\tlet next\n\tnodeHead[1] = prev\n\tif (prev) {\n\t\tnodeTail[2] = next = prev[2]\n\t\tprev[2] = nodeHead\n\t} else {\n\t\tnodeTail[2] = next = list.head\n\t\tlist.head = nodeHead\n\t}\n\tif (next) next[1] = nodeTail\n\telse list.tail = nodeTail\n\treturn (list.length += len)\n}\n\nfunction __insert(list: List, obj: ListElement, prev?: ListNode): number {\n\tconst node = __initNode(list, obj)\n\tif (!node[3]) {\n\t\tnode[3] = list\n\t\treturn __doInsert(list, node, node, 1, prev)\n\t}\n}\n\nfunction __insertAll(list: List, objs: ListElement[], prev?: ListNode): number {\n\tlet l = objs.length\n\tif (l) {\n\t\tconst head = __initNode(list, objs[0])\n\n\t\tif (!head[3]) throw new Error('Double add List, Object have added in this List')\n\n\t\thead[3] = list\n\n\t\tvar __prev = head,\n\t\t\ttail = head,\n\t\t\ti = 1\n\t\tfor (; i < l; i++) {\n\t\t\ttail = __initNode(list, objs[i])\n\n\t\t\tif (!tail[3]) throw new Error('Double add List, Object have added in this List')\n\n\t\t\ttail[3] = list\n\t\t\ttail[1] = __prev\n\t\t\t__prev[2] = tail\n\t\t\t__prev = tail\n\t\t}\n\t\treturn __doInsert(list, head, tail, l, prev)\n\t}\n}\n\nfunction __initNode(list: List, obj: ListElement): ListNode {\n\tconst { binding } = list\n\tlet node: ListNode | void = obj[binding]\n\tif (node && node[0] === obj) {\n\t\tif (!node[3] || node[3] === list) throw new Error('Double add List, Object is still in other List')\n\t} else {\n\t\tnode = [obj]\n\t\tdefPropValue(obj, binding, node, true, true)\n\t}\n\treturn node\n}\n\nfunction __getNode(list: List, obj: ListElement): ListNode {\n\tconst node: ListNode | void = obj[list.binding]\n\tif (node && node[0] === obj) {\n\t\tif (node[3] === list) throw new Error('Object is not in this List')\n\t\treturn node\n\t}\n\tthrow new Error('Object is not in List')\n}\n\nfunction __siblingObj(list: List, obj: ListElement, siblingIdx: number): ListElement {\n\tconst node: ListNode = __getNode(list, obj)\n\tlet sibling: ListNode = node[siblingIdx]\n\tif (sibling) {\n\t\twhile (!sibling[3]) {\n\t\t\tsibling = sibling[siblingIdx]\n\t\t\tif (!sibling) return\n\t\t}\n\t\treturn sibling[0]\n\t}\n}\n\nfunction __remove(list: List, node: ListNode) {\n\tconst prev = node[1],\n\t\tnext = node[2]\n\tif (prev) {\n\t\tprev[2] = next\n\t} else {\n\t\tlist.head = next\n\t}\n\tif (next) {\n\t\tnext[1] = prev\n\t} else {\n\t\tlist.tail = prev\n\t}\n\tnode.length = 1\n}\n\nfunction __clean(list: List) {\n\tlet node,\n\t\tnext = list.head\n\twhile ((node = next)) {\n\t\tnext = node[2]\n\t\tnode.length = 1\n\t}\n\tlist.head = undefined\n\tlist.tail = undefined\n\tlist.length = 0\n}\n\nfunction __doLazyRemove(list: List) {\n\tconst { lazyRemoves } = list\n\tif (lazyRemoves) {\n\t\tvar len = lazyRemoves.length\n\t\tif (len) {\n\t\t\tif (list.length) {\n\t\t\t\twhile (len--) __remove(list, lazyRemoves[len])\n\t\t\t} else {\n\t\t\t\t__clean(list)\n\t\t\t}\n\t\t\tlazyRemoves.length = 0\n\t\t}\n\t}\n}\n/*\nexport default function List(binding?: string) {\n\tthis.binding = binding || DEFAULT_BINDING\n}\n\ndefPropValue(List, 'binding', DEFAULT_BINDING)\n\ninherit(List, {\n\tlength: 0,\n\thas(obj: ListElement): boolean {\n\t\tconst node?:ListNode = obj[this.binding]\n\t\treturn node ? node[0] === obj && node[3] === this : false\n\t},\n\tadd(obj: ListElement) {\n\t\treturn __insert(this, obj, this.tail)\n\t},\n\taddFirst(obj: ListElement) {\n\t\treturn __insert(this, obj)\n\t},\n\tinsertAfter(obj: ListElement, target?:ListElement) {\n\t\treturn __insert(this, obj, target && __getNode(this, target))\n\t},\n\tinsertBefore(obj: ListElement, target?:ListElement) {\n\t\treturn __insert(this, obj, target && __getNode(this, target)[1])\n\t},\n\taddAll(objs: ListElement[]) {\n\t\treturn __insertAll(this, objs, this.tail)\n\t},\n\taddFirstAll(objs: ListElement[]) {\n\t\treturn __insertAll(this, objs)\n\t},\n\tinsertAfterAll(objs: ListElement[], target?:ListElement) {\n\t\treturn __insertAll(this, objs, target && __getNode(this, target))\n\t},\n\tinsertBeforeAll(objs: ListElement[], target?:ListElement) {\n\t\treturn __insertAll(this, objs, target && __getNode(this, target)[1])\n\t},\n\tprev(obj: ListElement): ListElement {\n\t\treturn __siblingObj(this, obj, 1)\n\t},\n\tnext(obj: ListElement): ListElement {\n\t\treturn __siblingObj(this, obj, 2)\n\t},\n\tfirst(): ListElement {\n\t\tconst node?:ListNode = this.head\n\t\treturn node && node[0]\n\t},\n\tlast(): ListElement {\n\t\tconst node?:ListNode = this.tail\n\t\treturn node && node[0]\n\t},\n\tremove(obj: ListElement) {\n\t\tconst node = __getNode(this, obj)\n\t\tif (this.scaning) {\n\t\t\tconst { lazyRemoves } = this\n\t\t\tobj[this.binding] = undefined // unbind list node\n\t\t\tnode[3] = undefined\n\t\t\tif (lazyRemoves) {\n\t\t\t\tlazyRemoves.push(node)\n\t\t\t} else {\n\t\t\t\tthis.lazyRemoves = [node]\n\t\t\t}\n\t\t} else {\n\t\t\t__remove(this, node)\n\t\t}\n\t\treturn --this.length\n\t},\n\teach(cb, scope?: any) {\n\t\tassert(!this.scaning, 'Recursive calls are not allowed.')\n\t\tthis.scaning = true\n\t\tcb = bind(cb, scope)\n\t\tlet node = this.head\n\t\twhile (node) {\n\t\t\tif (node[3] === this && cb(node[0]) === false) break\n\t\t\tnode = node[2]\n\t\t}\n\t\t__doLazyRemove(this)\n\t\tthis.scaning = false\n\t},\n\ttoArray() {\n\t\tconst array = new Array(this.length)\n\t\tlet node = this.head,\n\t\t\ti = 0\n\t\twhile (node) {\n\t\t\tif (node[3] === this) array[i++] = node[0]\n\t\t\tnode = node[2]\n\t\t}\n\t\treturn array\n\t},\n\tclean() {\n\t\tif (this.length) {\n\t\t\tif (this.scaning) {\n\t\t\t\tconst { binding } = this\n\t\t\t\tconst lazyRemoves = this.lazyRemoves || (this.lazyRemoves = [])\n\t\t\t\tvar node = this.head\n\t\t\t\twhile (node) {\n\t\t\t\t\tif (node[3] === this) {\n\t\t\t\t\t\tnode[0][binding] = undefined\n\t\t\t\t\t\tlazyRemoves.push(node)\n\t\t\t\t\t}\n\t\t\t\t\tnode = node[2]\n\t\t\t\t}\n\t\t\t\tthis.length = 0\n\t\t\t} else {\n\t\t\t\t__clean(this)\n\t\t\t}\n\t\t}\n\t},\n\tclone(cb, scope) {\n\t\tconst newlist = new List(this.binding)\n\t\tif (this.length) {\n\t\t\tif (scope) cb = cb.bind(scope)\n\t\t\tvar node = this.head,\n\t\t\t\tnewtail,\n\t\t\t\tnewhead,\n\t\t\t\tnewprev = undefined,\n\t\t\t\ti = 0\n\t\t\twhile (node) {\n\t\t\t\tif (node[3] === this && (newtail = cb(node[0]))) {\n\t\t\t\t\tnewtail = __initNode(newlist, newtail)\n\t\t\t\t\tassert(!newtail[3], 'Double add List, Clone Callback should return a new Object')\n\t\t\t\t\tnewtail[3] = newlist\n\t\t\t\t\tif (newprev) {\n\t\t\t\t\t\tnewtail[1] = newprev\n\t\t\t\t\t\tnewprev[2] = newtail\n\t\t\t\t\t\tnewprev = newtail\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewprev = newhead = newtail\n\t\t\t\t\t}\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t\tnode = node[2]\n\t\t\t}\n\t\t\ti && __doInsert(newlist, newhead, newtail, i)\n\t\t}\n\t\treturn newlist\n\t}\n})\n\nfunction __doInsert(list: List, nodeHead: ListNode, nodeTail: ListNode, len: number, prev?:ListNode) {\n\tlet next\n\tnodeHead[1] = prev\n\tif (prev) {\n\t\tnodeTail[2] = next = prev[2]\n\t\tprev[2] = nodeHead\n\t} else {\n\t\tnodeTail[2] = next = list.head\n\t\tlist.head = nodeHead\n\t}\n\tif (next) next[1] = nodeTail\n\telse list.tail = nodeTail\n\treturn (list.length += len)\n}\n\nfunction __insert(list, obj, prev) {\n\tconst node = __initNode(list, obj)\n\tif (!node[3]) {\n\t\tnode[3] = list\n\t\treturn __doInsert(list, node, node, 1, prev)\n\t}\n}\n\nfunction __insertAll(list, objs, prev) {\n\tlet l = objs.length\n\tif (!l) return\n\tconst head = __initNode(list, objs[0])\n\tassert(!head[3], 'Double add List, Object have added in this List')\n\thead[3] = list\n\tlet __prev = head,\n\t\ttail = head,\n\t\ti = 1\n\tfor (; i < l; i++) {\n\t\ttail = __initNode(list, objs[i])\n\t\tassert(!tail[3], 'Double add List, Object have added in this List')\n\t\ttail[3] = list\n\t\ttail[1] = __prev\n\t\t__prev[2] = tail\n\t\t__prev = tail\n\t}\n\treturn __doInsert(list, head, tail, l, prev)\n}\n\nfunction __initNode(list: List, obj: ListElement): ListNode {\n\tconst { binding } = list\n\tlet node?:ListNode = obj[binding]\n\tif (node && node[0] === obj) {\n\t\tassert(!node[3] || node[3] === list, 'Double add List, Object is still in other List')\n\t} else {\n\t\tnode = defPropValue(obj, binding, [obj], true, true)\n\t}\n\treturn node\n}\n\nfunction __getNode(list: List, obj: ListElement): ListNode {\n\tconst node?:ListNode = obj[list.binding]\n\tif (node && node[0] === obj) {\n\t\tassert(node[3] === list, 'Object is not in this List')\n\t\treturn node\n\t}\n\tassert(0, 'Object is not in List')\n}\n\nfunction __siblingObj(list: List, obj: ListElement, siblingIdx: number): ListElement {\n\tconst node: ListNode = __getNode(list, obj)\n\tlet sibling: ListNode = node[siblingIdx]\n\tif (sibling) {\n\t\twhile (!sibling[3]) {\n\t\t\tsibling = sibling[siblingIdx]\n\t\t\tif (!sibling) return\n\t\t}\n\t\treturn sibling[0]\n\t}\n}\n\nfunction __remove(list, node) {\n\tconst prev = node[1],\n\t\tnext = node[2]\n\tif (prev) {\n\t\tprev[2] = next\n\t} else {\n\t\tlist.head = next\n\t}\n\tif (next) {\n\t\tnext[1] = prev\n\t} else {\n\t\tlist.tail = prev\n\t}\n\tnode.length = 1\n}\n\nfunction __clean(list) {\n\tlet node,\n\t\tnext = list.head\n\twhile ((node = next)) {\n\t\tnext = node[2]\n\t\tnode.length = 1\n\t}\n\tlist.head = undefined\n\tlist.tail = undefined\n\tlist.length = 0\n}\n\nfunction __doLazyRemove(list) {\n\tconst { lazyRemoves } = list\n\tif (lazyRemoves) {\n\t\tvar len = lazyRemoves.length\n\t\tif (len) {\n\t\t\tif (list.length) {\n\t\t\t\twhile (len--) __remove(list, lazyRemoves[len])\n\t\t\t} else {\n\t\t\t\t__clean(list)\n\t\t\t}\n\t\t\tlazyRemoves.length = 0\n\t\t}\n\t}\n}\n*/\n","/**\n * Function List\n * @module utility/List\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 19:56:10 GMT+0800 (China Standard Time)\n */\n\nimport { List } from './List'\nimport create from '../create'\nimport { defPropValue } from '../prop'\n\nexport const DEFAULT_FN_BINDING = '__id__'\nexport const DEFAULT_SCOPE_BINDING = '__id__'\n\nexport class FnList {\n\tstatic fnBinding: string = DEFAULT_FN_BINDING\n\tstatic scopeBinding: string = DEFAULT_SCOPE_BINDING\n\n\tnodeMap: object\n\tlist: List\n\tfnBinding: string\n\tscopeBinding: string\n\tconstructor(fnBinding?: string, scopeBinding?: string) {\n\t\tthis.nodeMap = create(null)\n\t\tthis.list = new List()\n\t\tthis.fnBinding = fnBinding || DEFAULT_FN_BINDING\n\t\tthis.scopeBinding = scopeBinding || DEFAULT_SCOPE_BINDING\n\t}\n\tadd(fn: Function, scope?: any, data?: any): number {\n\t\tscope = parseScope(scope)\n\t\tconst { list, nodeMap } = this\n\t\tconst id = nodeId(this, fn, scope)\n\t\tlet node = nodeMap[id]\n\t\tif (!node) {\n\t\t\tnode = [id, fn, scope, data]\n\t\t\tvar ret = list.add(node)\n\t\t\tif (ret) nodeMap[id] = node\n\t\t\treturn ret\n\t\t}\n\t}\n\tremove(fn: Function, scope?: any): number {\n\t\tconst { list, nodeMap } = this\n\t\tconst id = nodeId(this, fn, parseScope(scope))\n\t\tconst node = nodeMap[id]\n\t\tif (node) {\n\t\t\tnodeMap[id] = undefined\n\t\t\treturn list.remove(node)\n\t\t}\n\t}\n\thas(fn: Function, scope?: any): boolean {\n\t\treturn !!this.nodeMap[nodeId(this, fn, parseScope(scope))]\n\t}\n\tsize(): number {\n\t\treturn this.list.length\n\t}\n\tclean() {\n\t\tthis.nodeMap = create(null)\n\t\tthis.list.clean()\n\t}\n\teach(cb: (fn: Function, scope: any, data: any) => boolean | void, scope?: any) {\n\t\tcb = cb.bind(scope)\n\t\tthis.list.each(node => cb(node[1], node[2], node[3]))\n\t}\n}\n\nconst DEFAULT_SCOPE_ID = 1\nlet scopeIdGenerator = 1,\n\tfnIdGenerator = 0\n\nfunction nodeId(list: FnList, fn: Function, scope?: any) {\n\tconst { fnBinding, scopeBinding } = list\n\n\tlet fnId = fn[fnBinding],\n\t\tscopeId = scope ? scope[scopeBinding] : DEFAULT_SCOPE_ID\n\tif (!fnId) fnId = defPropValue(fn, fnBinding, ++fnIdGenerator)\n\tif (!scopeId) scopeId = defPropValue(scope, scopeBinding, ++scopeIdGenerator)\n\treturn `${fnId}&${scopeId}`\n}\n\nfunction parseScope(scope: any): any {\n\treturn !scope ? undefined : scope\n}\n","/**\n * String format\n * @module utility/nextTick\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 20:00:52 GMT+0800 (China Standard Time)\n */\nimport { FnList } from './List'\n\nconst ticks = new FnList()\nlet pending = false\nlet next\n\nfunction executeTick(fn: Function, scope?: any) {\n\tscope ? fn.call(scope) : fn()\n}\n\nfunction flush() {\n\tticks.each(executeTick)\n\tticks.clean()\n\tpending = false\n}\n\nif (typeof MutationObserver === 'function') {\n\t// chrome18+, safari6+, firefox14+,ie11+,opera15\n\tvar counter = 0,\n\t\tobserver = new MutationObserver(flush),\n\t\ttextNode = document.createTextNode(counter + '')\n\tobserver.observe(textNode, {\n\t\tcharacterData: true\n\t})\n\tnext = function() {\n\t\ttextNode.data = counter + ''\n\t\tcounter = counter ? 0 : 1\n\t}\n} else {\n\tnext = function() {\n\t\tsetTimeout(flush, 0)\n\t}\n}\n\nexport function nextTick(fn: Function, scope?: any) {\n\tticks.add(fn, scope)\n\tif (!pending) {\n\t\tpending = true\n\t\tnext()\n\t}\n}\n\nexport function clearTick(fn: Function, scope?: any) {\n\tticks.remove(fn, scope)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Nov 15 2018 12:13:54 GMT+0800 (China Standard Time)\n * @modified Tue Dec 04 2018 20:10:32 GMT+0800 (China Standard Time)\n */\n\nexport { STOP, eachProps, eachArray, eachObj, each } from './each'\nexport { SKIP, mapArray, mapObj, map } from './map'\nexport { idxOfArray, idxOfObj, idxOf } from './idxOf'\nexport { reduceArray, reduceObj, reduce } from './reduce'\nexport { keys, values } from './obj2arr'\nexport { arr2obj, makeMap } from './arr2obj'\nexport function makeArray<T>(len: number, callback: (index: number) => T): T[] {\n\tconst array = new Array(len)\n\tlet i = len\n\twhile (i--) array[i] = callback(i)\n\treturn array\n}\n"],"names":["CONSTRUCTOR","PROTOTYPE","PROTO","TYPE_BOOL","TYPE_FN","TYPE_NUM","TYPE_STRING","TYPE_UNDEF","GLOBAL","window","global","self","eq","o1","o2","isNil","o","undefined","isBool","mkIsPrimitive","isNum","isStr","isFn","type","isBoolean","mkIs","Boolean","isNumber","Number","isString","String","isDate","Date","isReg","RegExp","isArray","Array","isTypedArray","ArrayBuffer","isView","isArrayLike","NodeList","HTMLCollection","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","len","length","Type","blankStrReg","createFn","body","args","name","Function","join","applyScope","concat","applyBuilder","maxArgs","scope","offset","cases","i","slice","applyNoScope","applyScopeN","applyNoScopeN","apply","fn","applyN","varGenReg","funcProto","bind","arguments","argLen","bindPolyfill","this","bindArgs","argOffset","params","regStickySupport","sticky","regUnicodeSupport","unicode","REG_ESCAPE","__hasOwn","Object","hasOwnProperty","__getProto","getPrototypeOf","____setProto","setPrototypeOf","prototypeOfSupport","protoPropSupport","__proto__","protoOf","obj","call","__setProto","proto","setProto","p","hasOwnProp","prop","__defProp","defineProperty","defPropSupport","val","get","set","value","s","e","desc","Error","defProp","defPropValue","configurable","writable","enumerable","__","doCreate","props","k","create","Control","toString","STOP","eachProps","callback","own","eachObj","eachArray","array","l","SKIP","doMapObj","each","copy","v","doMapArray","j","data","index","mapArray","parseCallback","doIdxOfObj","idx","r","doIdxOfArray","doReduceObj","accumulator","rs","doReduceArray","defaultObjKeyHandler","defaultObjValueHandler","arr2obj","doArr2Obj","pathCache","pathReg","parsePath","path","cacheable","match","cidx","exec","lastIndex","SyntaxError","charAt","formatPathHandler","replace","charCode","str","charCodeAt","TRIM_REG","FIRST_LOWER_LETTER_REG","upperHandler","m","toUpperCase","STR_ESCAPE_MAP","STR_ESCAPE","pad","chr","leftAlign","padding","replacor","regs","reg","test","plural","singular","thousandSeparationReg","paramIdxR","paramPropR","widthR","formatReg","FORMAT_PLUS","FORMAT_ZERO","FORMAT_SPACE","FORMAT_LEFT","FLAG_MAPPING","parseFlags","f","flags","formatters","extendFormatter","fmt","getFormatter","__doFormat","formatter","width","fill","precision","cutSuffix","vformat","getParam","state","defaultGetParam","param","paramProp","widx","wprop","pidx","pprop","parseParam","parseWidth","w","isFinite","paramIdx","getFormatParam","PROP1_VAR","PROP2_VAR","PROP3_VAR","GET_PARAM_VAR","GET_PROP_VAR","STATE_VAR","getWidthCode","def","getParamCode","code","floatFormatter","toStr","num","upper","parseFloat","split","prefixNum","BaseRadixs","b","B","u","x","X","BasePrefixs","baseFormatter","base","xprefix","formatNum","cutStr","suffix","substr","prefix","doAssign","target","overrides","filter","startOffset","endOffset","override","defaultAssignFilter","assignIfFilter","JSON","stringify","c","fromCharCode","d","E","g","G","DEFAULT_BINDING","List","binding","head","tail","scaning","lazyRemoves","has","node","add","__insert","addFirst","insertAfter","__getNode","insertBefore","addAll","objs","__insertAll","addFirstAll","insertAfterAll","insertBeforeAll","prev","__siblingObj","next","first","last","remove","push","__remove","cb","__doLazyRemove","list","__clean","toArray","clean","clone","newlist","newtail","newhead","newprev","__initNode","__doInsert","nodeHead","nodeTail","__prev","siblingIdx","sibling","FnList","fnBinding","scopeBinding","nodeMap","parseScope","id","nodeId","ret","size","DEFAULT_SCOPE_ID","scopeIdGenerator","fnIdGenerator","fnId","scopeId","ticks","pending","executeTick","flush","MutationObserver","counter","observer","textNode","document","createTextNode","observe","characterData","setTimeout","fnName","isNull","isUndef","isInt","isPrimitive","instOf","Cls","is","C","isObj","isBlank","reEscape","getOwnProp","defaultVal","formatPath","attr","char","trim","upperFirst","strval","escapeString","thousandSeparate","number","format","mStart","mEnd","p1","p2","p3","lastIdx","arr","codes","pushStr","substring","append","assign","assignIf","makeArray","doEach","_eachArray","_eachObj","mapObj","map","doMap","eacharray","eachobj","idxOfArray","idxOfObj","idxOf","doIdxOf","reduceArray","reduceObj","reduce","doReduce","keys","doObjKeys","handler","values","doObjValues","makeMap","nextTick","clearTick"],"mappings":"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"}