!(function(r, t) {
	'object' == typeof exports && 'undefined' != typeof module
		? t(exports)
		: 'function' == typeof define && define.amd
		? define('argilo', ['exports'], t)
		: t(((r = r || self).argilo = {}))
})(this, function(r) {
	var t = 'constructor',
		n = 'prototype',
		e = '__proto__',
		i = 'hasOwnProperty',
		u = 'boolean',
		o = 'function',
		a = 'number',
		s = 'string',
		c = 'undefined',
		f = typeof window !== c ? window : typeof global !== c ? global : typeof self !== c ? self : {}
	function EMPTY_FN() {}
	function getConstructor(r) {
		var n = r[t]
		return typeof n === o ? n : Object
	}
	function eq(r, t) {
		return r === t || (r != r && t != t)
	}
	function isNull(r) {
		return null === r
	}
	function isUndef(r) {
		return r === undefined
	}
	function isNil(r) {
		return null === r || r === undefined
	}
	var h = mkIsPrimitive(u),
		l = mkIsPrimitive(a),
		d = mkIsPrimitive(s),
		p = mkIsPrimitive(o)
	function isInt(r) {
		return 0 === r || (!!r && (typeof r === a && r % 1 == 0))
	}
	function isPrimitive(r) {
		if (r === undefined || null === r) return !0
		switch (typeof r) {
			case u:
			case a:
			case s:
			case o:
				return !0
		}
		return !1
	}
	function mkIsPrimitive(r) {
		return function is(t) {
			return typeof t === r
		}
	}
	function instOf(r, t) {
		return r !== undefined && null !== r && r instanceof t
	}
	function is(r, n) {
		if (r !== undefined && null !== r) {
			var e = r[t] || Object
			if (n[t] !== Array) return e === n
			for (var i = n.length; i--; ) if (e === n[i]) return !0
		}
		return !1
	}
	var m = mkIs(Boolean),
		v = mkIs(Number),
		g = mkIs(String),
		y = mkIs(Date),
		b = mkIs(RegExp),
		x = Array.isArray || mkIs(Array),
		O = p(ArrayBuffer)
			? ArrayBuffer.isView
			: function() {
					return !1
			  }
	function isArrayLike(r) {
		if (r) {
			switch (r[t]) {
				case Array:
				case String:
				case f.NodeList:
				case f.HTMLCollection:
				case f.Int8Array:
				case f.Uint8Array:
				case f.Int16Array:
				case f.Uint16Array:
				case f.Int32Array:
				case f.Uint32Array:
				case f.Float32Array:
				case f.Float64Array:
					return !0
			}
			var n = r.length
			return typeof n === a && (0 === n || (n > 0 && n % 1 == 0 && n - 1 in r))
		}
		return '' === r
	}
	function isObj(r) {
		return r !== undefined && null !== r && getConstructor(r) === Object
	}
	function mkIs(r) {
		return function is(n) {
			return n !== undefined && null !== n && n[t] === r
		}
	}
	var k = /^\s*$/
	function isBlank(r) {
		return !r || (r[t] === String ? k.test(r) : 0 === r.length)
	}
	function createFn(r, t, n) {
		return n
			? Function('return function ' + n + '(' + (t ? t.join(', ') : '') + '){' + r + '}')()
			: A(Function, Function, t && t.length ? t.concat(r) : [r])
	}
	function applyBuilder(r, t, n) {
		;(t = t ? 'scope' : ''), (n = n ? 'offset' : '')
		for (var e = new Array(r + 1), i = new Array(r + 1), u = 0; u <= r; u++)
			(e[u] = (u || t ? ', ' : '') + 'args[' + (n ? 'offset' + (u ? ' + ' + u : '') : u) + ']'),
				(i[u] = 'case ' + u + ': return fn' + (t && '.call') + '(' + t + e.slice(0, u).join('') + ');')
		return Function(
			'return function(fn, ' +
				(t && t + ', ') +
				'args' +
				(n && ', offset, len') +
				'){\nswitch(' +
				(n ? 'len' : 'args.length') +
				'){\n' +
				i.join('\n') +
				'\n}\n' +
				(n && 'var arr = new Array(len);\nfor(var i=0; i<len; i++) arr[i] = arr[offset + i];') +
				'\nreturn fn.apply(' +
				(t || 'null') +
				', ' +
				(n ? 'arr' : 'args') +
				');\n}'
		)()
	}
	var A = applyBuilder(8, 1, 0),
		M = applyBuilder(8, 0, 0),
		_ = applyBuilder(8, 1, 1),
		F = applyBuilder(8, 0, 1)
	function apply(r, t, n) {
		return t === undefined || null === t || t === f ? M(r, n || []) : A(r, t, n || [])
	}
	function applyN(r, t, n, e, i) {
		return t === undefined || null === t || t === f ? F(r, n, e, i) : _(r, t, n, e, i)
	}
	var S,
		j = /\$\d+$/
	function fnName(r) {
		var t = r.name
		return t ? t.replace(j, '') : 'anonymous'
	}
	var C = Function[n]
	C.bind
		? (S = function bind(r, t) {
				var n = arguments,
					e = n.length
				return isNil(t) ? (e > 2 ? bindPolyfill(r, t, n, 2) : r) : _(r.bind, r, n, 1, e - 1)
		  })
		: ((C.bind = function bind(r) {
				return bindPolyfill(this, r, arguments, 1)
		  }),
		  (S = function bind(r, t) {
				return bindPolyfill(r, t, arguments, 2)
		  }))
	var P = S
	function bindPolyfill(r, t, n, e) {
		var i = n.length - e
		return (
			t === undefined && (t = null),
			i > 0
				? function bindProxy() {
						var u = arguments,
							o = u.length
						if (o) {
							for (var a = new Array(i + o); o--; ) a[i + o] = u[o]
							for (o = i; o--; ) a[o] = n[o + e]
							return apply(r, null === t ? this : t, a)
						}
						return applyN(r, null === t ? this : t, n, e, i)
				  }
				: null === t
				? r
				: t === f
				? function bindProxy() {
						return M(r, arguments)
				  }
				: function bindProxy() {
						return A(r, t, arguments)
				  }
		)
	}
	var w = h(/(?:)/.sticky),
		E = h(/(?:)/.unicode),
		R = /[-\/\\^$*+?.()|[\]{}]/g
	function reEscape(r) {
		return r.replace(R, '\\$&')
	}
	var I = Object[n][i]
	function hasOwnProp(r, t) {
		return I.call(r, t)
	}
	var $ = Object.getPrototypeOf,
		L = Object.setPrototypeOf,
		N = !!L,
		T = { __proto__: [] } instanceof Array,
		q = L
			? $
			: $
			? function getPrototypeOf(r) {
					return r[e] || $(r)
			  }
			: function getPrototypeOf(r) {
					return (hasOwnProp(r, e) ? r[e] : r[t][n]) || null
			  },
		B =
			L ||
			function setPrototypeOf(r, t) {
				return (r[e] = t), r
			},
		z =
			L ||
			(T
				? B
				: function setPrototypeOf(r, t) {
						for (var n in t) hasOwnProp(t, n) && (r[n] = t[n])
						return B(r, t)
				  }),
		H = T
			? hasOwnProp
			: function hasOwnProp$$1(r, t) {
					return t !== e && hasOwnProp(r, t)
			  },
		K = Object.defineProperty,
		Z = Object[n],
		V = Z.__defineGetter__,
		W = Z.__defineSetter__,
		G =
			K &&
			!!(function() {
				try {
					var r,
						t = {}
					return (
						K(t, 's', {
							get: function get() {
								return r
							},
							set: function set(t) {
								r = t
							}
						}),
						(t.s = 1),
						t.s === r
					)
				} catch (n) {}
			})(),
		X = G || !!W
	G ||
		(K = W
			? function defineProperty(r, t, n) {
					var e = n.get,
						i = n.set
					return (
						(!('value' in n) && t in r) || (r[t] = n.value), e && V.call(r, t, e), i && W.call(r, t, i), r
					)
			  }
			: function defineProperty(r, t, n) {
					if (n.get || n.set)
						throw new TypeError('Invalid property descriptor. Accessor descriptors are not supported.')
					return (!('value' in n) && t in r) || (r[t] = n.value), r
			  })
	var D = K,
		U = G
			? function defPropValue(r, t, n, e, i, u) {
					return K(r, t, { value: n, enumerable: !1 !== u, configurable: !1 !== e, writable: !1 !== i }), n
			  }
			: function defPropValue(r, t, n) {
					return (r[t] = n), n
			  }
	function getOwnProp(r, t, n) {
		return H(r, t) ? r[t] : n
	}
	function __() {}
	function doCreate(r, t) {
		__[n] = r
		var e = new __()
		if (((__[n] = null), t)) for (var i in t) H(t, i) && D(e, i, t[i])
		return e
	}
	var Y =
			Object.create ||
			(Object.create = Object.getPrototypeOf
				? doCreate
				: function create(r, t) {
						var n = doCreate(r, t)
						return B(n, r), n
				  }),
		J = (function() {
			function Control(r) {
				this.t = r
			}
			return (
				(Control.prototype.toString = function toString() {
					return this.t
				}),
				Control
			)
		})(),
		Q = new J('STOP')
	function eachProps(r, t, n, e) {
		var i
		if ((h(n) ? (e = n) : (t = P(t, n)), !1 === e)) {
			for (i in r) if (t(i, r) === Q) return i
		} else for (i in r) if (H(r, i) && t(i, r) === Q) return i
		return !1
	}
	function eachObj(r, t, n, e) {
		var i
		if ((h(n) ? (e = n) : (t = P(t, n)), !1 === e)) {
			for (i in r) if (t(r[i], i, r) === Q) return i
		} else for (i in r) if (H(r, i) && t(r[i], i, r) === Q) return i
		return !1
	}
	function eachArray(r, t, n) {
		t = P(t, n)
		for (var e = 0, i = r.length; e < i; e++) if (t(r[e], e, r) === Q) return e
		return !1
	}
	function doEach(r, t, n, e, i, u) {
		return isArrayLike(n) ? r(n, e, i) : t(n, e, i, u)
	}
	function each(r, t, n, e) {
		return doEach(eachArray, eachObj, r, t, n, e)
	}
	var rr = new J('SKIP')
	function doMapObj(r, t, n, e, i) {
		h(e) ? (i = e) : (n = P(n, e))
		var u = Y(null)
		return (
			r(
				t,
				function(r, t, e) {
					var i = n(r, t, e)
					if (i === Q) return Q
					i !== rr && (u[t] = i)
				},
				null,
				i
			),
			u
		)
	}
	function mapObj(r, t, n, e) {
		return doMapObj(eachObj, r, t, n, e)
	}
	function doMapArray(r, t, n, e) {
		n = P(n, e)
		var i = [],
			u = 0
		return (
			r(t, function(r, t, e) {
				var o = n(r, t, e)
				if (o === Q) return Q
				o !== rr && (i[u++] = o)
			}),
			i
		)
	}
	function mapArray(r, t, n) {
		return doMapArray(eachArray, r, t, n)
	}
	function doMap(r, t, n, e, i, u) {
		return isArrayLike(n) ? doMapArray(r, n, e, i) : doMapObj(t, n, e, i, u)
	}
	function map(r, t, n, e) {
		return doMap(eachArray, eachObj, r, t, n, e)
	}
	function parseCallback(r, t) {
		return p(r)
			? P(r, t)
			: function defaultHandler(t, n, e) {
					return eq(t, r)
			  }
	}
	function doIdxOfObj(r, t, n, e, i) {
		h(e) && ((i = e), (e = null))
		var u = parseCallback(n, e),
			o = -1
		return (
			r(
				t,
				function(r, t, n) {
					var e = u(r, t, n)
					return !0 === e ? ((o = t), Q) : e === Q ? e : void 0
				},
				null,
				i
			),
			o
		)
	}
	function idxOfObj(r, t, n, e) {
		return doIdxOfObj(eachObj, r, t, n, e)
	}
	function doIdxOfArray(r, t, n, e) {
		var i = parseCallback(n, e),
			u = -1
		return (
			r(t, function(r, t, n) {
				var e = i(r, t, n)
				return !0 === e ? ((u = t), Q) : e === Q ? e : void 0
			}),
			u
		)
	}
	function idxOfArray(r, t, n) {
		return doIdxOfArray(eachArray, r, t, n)
	}
	function doIdxOf(r, t, n, e, i, u) {
		return isArrayLike(n) ? doIdxOfArray(r, n, e, i) : doIdxOfObj(t, n, e, i, u)
	}
	function idxOf(r, t, n, e) {
		return doIdxOf(eachArray, eachObj, r, t, n, e)
	}
	function doReduceObj(r, t, n, e, i, u) {
		return (
			h(i) ? (u = i) : (e = P(e, i)),
			r(
				t,
				function(r, t, i) {
					var u = e(n, r, t, i)
					if (u === Q) return Q
					n = u
				},
				null,
				u
			),
			n
		)
	}
	function reduceObj(r, t, n, e, i) {
		return doReduceObj(eachObj, r, t, n, e, i)
	}
	function doReduceArray(r, t, n, e, i) {
		return (
			(e = P(e, i)),
			r(t, function(r, t, i) {
				var u = e(n, r, t, i)
				if (u === Q) return Q
				n = u
			}),
			n
		)
	}
	function reduceArray(r, t, n, e) {
		return doReduceArray(eachArray, r, t, n, e)
	}
	function doReduce(r, t, n, e, i, u, o) {
		return isArrayLike(n) ? doReduceArray(r, n, e, i, u) : doReduceObj(t, n, e, i, u, o)
	}
	function reduce(r, t, n, e, i) {
		return doReduce(eachArray, eachObj, r, t, n, e, i)
	}
	function defaultObjKeyHandler(r, t) {
		return r
	}
	function doObjKeys(r, t) {
		var n = [],
			e = arguments,
			i = defaultObjKeyHandler,
			u = 2,
			o = 0
		return (
			p(e[u]) && ((i = e[u++]), h(e[u]) || (i = P(i, e[u++]))),
			r(
				t,
				function(r, t) {
					var e = i(r, t)
					if (e === Q) return Q
					e !== rr && (n[o++] = e)
				},
				null,
				e[u]
			),
			n
		)
	}
	function keys(r, t, n, e) {
		return doObjKeys(eachProps, r, t, n, e)
	}
	function defaultObjValueHandler(r, t, n) {
		return r
	}
	function doObjValues(r, t) {
		var n = [],
			e = arguments,
			i = defaultObjValueHandler,
			u = 1,
			o = 0
		return (
			p(e[u]) && ((i = e[u++]), h(e[u]) || (i = P(i, e[u++]))),
			r(
				t,
				function(r, t, e) {
					var u = i(r, t, e)
					if (u === Q) return Q
					u !== rr && (n[o++] = u)
				},
				null,
				e[u]
			),
			n
		)
	}
	function values(r, t, n, e) {
		return doObjValues(eachObj, r, t, n, e)
	}
	function doArr2Obj(r, t, n, e) {
		var i = Y(null)
		return (
			(n = P(n, e)),
			r(t, function(r, t, e) {
				var u = n(r, t, e)
				if (!x(u)) return u
				i[u[0]] = u[1]
			}),
			i
		)
	}
	function arr2obj(r, t, n) {
		return doArr2Obj(eachArray, r, t, n)
	}
	function makeMap(r, t, n) {
		return (
			d(r) && (r = r.split(d(n) ? n : ',')),
			arr2obj(
				r,
				p(t)
					? t
					: function(r) {
							return [r, t]
					  }
			)
		)
	}
	function makeArray(r, t) {
		for (var n = new Array(r), e = r; e--; ) n[e] = t(e)
		return n
	}
	var tr = Y(null),
		nr = /(?:^|\.)([a-zA-Z$_][\w$]*)|\[\s*(?:(\d+)|"((?:[^\\"]|\\.)*)"|'((?:[^\\']|\\.)*)')\s*\]/g
	function parsePath(r, t) {
		var n
		if (x(r)) n = r
		else {
			if ((n = tr[r])) return console.log('catched path', r, n), n
			n = []
			for (var e, i, u = 0, o = 0; (e = nr.exec(r)); ) {
				if ((i = nr.lastIndex) !== u + e[0].length)
					throw new SyntaxError(
						'Invalid Path: "' + r + '", unkown character[' + r.charAt(u) + '] at offset:' + u
					)
				;(n[o++] = e[1] || e[2] || e[3] || e[4]), (u = i)
			}
			!1 !== t && o && (tr[r] = n)
		}
		if (!n.length) throw new Error('Empty Path: ' + r)
		return console.log('uncatched path', r, n), n
	}
	function formatPath(r) {
		return x(r) ? r.path || (r.path = mapArray(r, formatPathHandler).join('')) : r
	}
	function formatPathHandler(r) {
		return '["' + String(r).replace("'", '\\"') + '"]'
	}
	function get(r, t) {
		for (var n = (t = parsePath(t)).length - 1, e = 0; e < n; e++)
			if (null === (r = r[t[e]]) || r === undefined) return
		if (r && ~n) return r[t[e]]
	}
	function set(r, t, n) {
		for (var e = (t = parsePath(t)).length - 1, i = 0; i < e; i++) r = r[t[i]] || (r[t[i]] = {})
		~e && (r[t[i]] = n)
	}
	function charCode(r, t) {
		return r.charCodeAt(t || 0)
	}
	function char(r) {
		return String.fromCharCode(r)
	}
	function cutStr(r, t, n) {
		return r.substring(t, n)
	}
	function cutLStr(r, t, n) {
		return r.substr(t, n)
	}
	var er = /(^\s+)|(\s+$)/g
	function trim(r) {
		return r.replace(er, '')
	}
	var ir = /^[a-z]/,
		ur = /^[A-Z]/
	function upper(r) {
		return r.toUpperCase()
	}
	function lower(r) {
		return r.toLowerCase()
	}
	function upperFirst(r) {
		return r.replace(ir, upper)
	}
	function lowerFirst(r) {
		return r.replace(ur, lower)
	}
	var ar = { '\n': '\\n', '\t': '\\t', '\f': '\\f', '"': '\\"', "'": "\\'" },
		sr = /[\n\t\f"']/g
	function escapeStr(r) {
		return r.replace(sr, function(r) {
			return ar[r]
		})
	}
	function pad(r, t, n, e) {
		return t > r.length ? __pad(r, t, n, e) : r
	}
	function shorten(r, t, n) {
		return t < r.length ? ((n = n || ''), r.substr(0, t - n.length) + n) : r
	}
	function __pad(r, t, n, e) {
		var i = new Array(t - r.length + 1).join(n || ' ')
		return e ? r + i : i + r
	}
	var cr = mkSeparator(3),
		fr = mkSeparator(8, '01'),
		hr = mkSeparator(4, '0-7'),
		lr = mkSeparator(4, '\\da-fA-F')
	function mkSeparator(r, t) {
		t = t || '\\d'
		var n = new RegExp(
			'^(?:[+-]|\\s+|0[xXbBoO])|([' + t + '])(?=([' + t + ']{' + r + '})+(?![' + t + ']))|[^' + t + '].*',
			'g'
		)
		return function(r) {
			return r.replace(n, separatorHandler)
		}
	}
	function separatorHandler(r, t) {
		return t ? t + ',' : r
	}
	var dr = /([a-zA-Z]+)([^aeiou])y$|([sxzh])$|([aeiou]y)$|([^sxzhy])$/
	function plural(r) {
		return r.replace(dr, pluralHandler)
	}
	function pluralHandler(r, t, n, e, i, u) {
		return t + (n ? n + 'ies' : e ? e + 'es' : (i || u) + 's')
	}
	var pr = /([a-zA-Z]+)([^aeiou])ies$|([sxzh])es$|([aeiou]y)s$|([^sxzhy])s$/
	function singular(r) {
		return r.replace(pr, singularHandler)
	}
	function singularHandler(r, t, n, e, i, u) {
		return t + (n ? n + 'y' : e || i || u)
	}
	var mr = 1,
		vr = 2,
		gr = 4,
		yr = 8,
		br = 16,
		xr = 32,
		Or = { '#': mr, '+': vr, 0: gr, ' ': yr, ',': br, '-': xr }
	function parseFlags(r) {
		var t = 0
		if (r) for (var n = r.length; n--; ) t |= Or[r.charAt(n)]
		return t
	}
	var kr = '(\\d+|\\$|@)',
		Ar =
			'(?:\\{((?:[a-zA-Z$_][\\w$_]*|\\[(?:\\d+|"(?:[^\\\\"]|\\\\.)*"|\'(?:[^\\\\\']|\\\\.)*\')\\])(?:\\.[a-zA-Z$_][\\w$_]*|\\[(?:\\d+|"(?:[^\\\\"]|\\\\.)*"|\'(?:[^\\\\\']|\\\\.)*\')\\])*)\\})',
		Mr = '(?:([1-9]\\d*)|&' + kr + Ar + ')',
		_r = new RegExp(
			'\\\\.|(\\{' +
				kr +
				'?' +
				Ar +
				'?(?::([#,+\\- 0]*)(?:' +
				Mr +
				'(?:=(.))' +
				'?)?(?:\\.' +
				Mr +
				'(?:="((?:[^\\\\"]|\\\\.)*)")' +
				'?)?)?([a-zA-Z_][a-zA-Z0-9_$]*)?\\})',
			'g'
		),
		Fr = Y(null)
	function extendFormatter(r) {
		var t, n
		for (n in r) (t = r[n]), p(t) && (Fr[n] = t)
	}
	function getFormatter(r) {
		var t = Fr[r || 's']
		if (t) return t
		throw new Error('Invalid Formatter: ' + r)
	}
	function vformat(r, t, n, e) {
		var i = (n = n || 0)
		return (
			(e = e || defaultGetParam),
			r.replace(_r, function(r, t, n, e, i, u, o, a, s, c, f, h, l, d) {
				return t
					? getFormatter(d)(
							parseParam(n || '$', e),
							parseFlags(i),
							parseWidth(u, o, a) || 0,
							s,
							parseWidth(c, f, h),
							l
					  )
					: r.charAt(1)
			})
		)
		function parseWidth(r, t, n) {
			if (r) return r >> 0
			if (t) {
				var e = parseParam(t, n) >> 0
				if (isFinite(e)) return e
			}
		}
		function parseParam(r, u) {
			var o = e(t, '$' === r ? n++ : '@' === r ? (n === i ? n : n - 1) : r >> 0)
			return u ? get(o, u) : o
		}
	}
	function defaultGetParam(r, t) {
		return r[t]
	}
	function format(r) {
		return vformat(r, arguments, 0, getFormatParam)
	}
	function getFormatParam(r, t) {
		return r[t + 1]
	}
	var Sr = 'getp',
		jr = 'get',
		Cr = 'state'
	function createFormatter(r, t) {
		return createFn(
			'return function(args, ' +
				Cr +
				'){\nreturn fmt(' +
				getParamCode(r[2] || '$', r[3]) +
				',\n"' +
				parseFlags(r[4]) +
				'",\n' +
				getWidthCode(r[5], r[6], r[7], '0') +
				',\n"' +
				(r[8] ? escapeStr(r[8]) : ' ') +
				'",\n' +
				getWidthCode(r[9], r[10], r[11], 'void 0') +
				',\n"' +
				(r[12] ? escapeStr(r[12]) : '') +
				'");\n}',
			['fmt', jr, Sr]
		)(getFormatter(r[13]), get, t)
	}
	function getWidthCode(r, t, n, e) {
		return r || (t ? getParamCode(t, n) : e)
	}
	function getParamCode(r, t) {
		var n =
			Sr +
			'(args, ' +
			('$' === r
				? Cr + '[0]++'
				: '@' === r
				? Cr + '[0] === ' + Cr + '[1] ? ' + Cr + '[0] : ' + Cr + '[0] - 1'
				: r) +
			')'
		if (t) {
			for (var e = parsePath(t), i = e.length, u = new Array(i); i--; ) u[i] = '"' + escapeStr(e[i]) + '"'
			return jr + '(' + n + ', [' + u.join(', ') + '])'
		}
		return n
	}
	function formatter(r, t, n) {
		var e,
			i,
			u,
			o = 0,
			a = [],
			s = [],
			c = 0
		for (t = t || 0; (e = _r.exec(r)); )
			o < (i = (u = _r.lastIndex) - e[0].length) && pushStr(cutStr(r, o, i), 0),
				e[1]
					? ((s[c] = 'arr[' + c + '](arguments, ' + Cr + ')'),
					  (a[c++] = createFormatter(e, n || defaultGetParam)))
					: pushStr(e[0].charAt(1), c),
				(o = u)
		return (
			o < r.length && pushStr(cutStr(r, o), c),
			createFn('return function(){var ' + Cr + ' = [' + t + ', ' + t + ']; return ' + s.join(' + ') + '}', [
				'arr'
			])(a)
		)
		function pushStr(r, t) {
			t && a[c - 1].match ? (a[c - 1] += r) : ((s[c] = 'arr[' + c + ']'), (a[c++] = r))
		}
	}
	function strFormatter(r) {
		return function(t, n, e, i, u, o) {
			var a = r(t, n)
			return e > a.length ? __pad(a, e, i, n & xr) : shorten(a, u, o)
		}
	}
	function numFormatter(r, t, n, e) {
		return function(i, u, o, a, s) {
			var c = r(i)
			if (!isFinite(c)) return String(c)
			var f = t(c, u),
				h = f.length,
				l = n(c < 0 ? -c : c, u, s)
			return u & gr
				? ((l = f + pad(l, o - h, '0')), u & br ? e(l) : l)
				: (u & br && (l = e(l)), pad(f + l, o, a, u & xr))
		}
	}
	function decimalPrefix(r, t) {
		return r < 0 ? '-' : t & vr ? '+' : t & yr ? ' ' : ''
	}
	var Pr = { b: [2, fr], o: [8, hr], u: [10, cr], x: [16, lr] },
		wr = ['0b', '0o', '0x']
	function baseFormatter(r) {
		var t = Pr[r.toLowerCase()],
			n = t[0],
			e = function __toStr(r) {
				return r.toString(n)
			},
			i =
				'X' === r
					? function(r) {
							return upper(e(r))
					  }
					: e,
			u = 10 === n ? '' : wr[n >> 3]
		return (
			charCode(r) < 96 && (u = upper(u)),
			numFormatter(
				function(r) {
					return r >>> 0
				},
				function(r, t) {
					return t & mr ? u : ''
				},
				i,
				t[1]
			)
		)
	}
	function floatFormatter(r) {
		var t = 'E' === upper(r) ? toExponential : 'f' === r ? toFixed : toPrecision,
			n = function __toStr(r, n, e) {
				return t(r, e) || String(r)
			},
			e =
				charCode(r) > 96
					? n
					: function(r, t, e) {
							return upper(n(r, t, e))
					  }
		return numFormatter(parseFloat, decimalPrefix, e, cr)
	}
	function toExponential(r, t) {
		return r.toExponential(t)
	}
	function toPrecision(r, t) {
		return t && r.toPrecision(t)
	}
	function toFixed(r, t) {
		return t >= 0 && r.toFixed(t)
	}
	function toStr(r) {
		return String(r)
	}
	function doAssign(r, t, n, e, i) {
		r || (r = {})
		for (var u, o, a = i || t.length - 1, s = e || 0; s < a; s++)
			if ((u = t[s])) for (o in u) n(o, r, u) && (r[o] = u[o])
		return r
	}
	function assign(r) {
		return doAssign(r, arguments, defaultAssignFilter, 1)
	}
	function assignIf(r) {
		return doAssign(r, arguments, assignIfFilter, 1)
	}
	function defaultAssignFilter(r, t, n) {
		return H(n, r)
	}
	function assignIfFilter(r, t, n) {
		return H(n, r) && !(r in t)
	}
	extendFormatter({
		s: strFormatter(toStr),
		j: strFormatter(function(r) {
			return r === undefined || p(r) || (r.toJSON && r.toJSON() === undefined) ? toStr(r) : JSON.stringify(r)
		}),
		c: function c(r) {
			var t = r >> 0
			return t > 0 ? String.fromCharCode(t) : ''
		},
		d: numFormatter(
			function(r) {
				return r >> 0
			},
			decimalPrefix,
			toStr,
			cr
		),
		e: floatFormatter('e'),
		E: floatFormatter('E'),
		f: floatFormatter('f'),
		g: floatFormatter('g'),
		G: floatFormatter('G'),
		b: baseFormatter('b'),
		B: baseFormatter('B'),
		o: baseFormatter('o'),
		O: baseFormatter('O'),
		u: baseFormatter('u'),
		x: baseFormatter('x'),
		X: baseFormatter('X')
	})
	var Er = ['source', 'global', 'ignoreCase', 'multiline']
	function deepEq(r, t) {
		return (
			!!eq(r, t) ||
			(!(!r || !t || getConstructor(r) !== getConstructor(t)) &&
				(isPrimitive(r)
					? String(r) === String(t)
					: y(r)
					? r.getTime() === t.getTime()
					: b(r)
					? eqProps(r, t, Er)
					: x(r)
					? eqArray(r, t, deepEq)
					: O(r)
					? eqArray(r, t, eq)
					: eqObj(r, t)))
		)
	}
	function eqProps(r, t, n) {
		for (var e = n.length; e--; ) if (r[n[e]] !== t[n[e]]) return !1
		return !0
	}
	function eqArray(r, t, n) {
		var e = r.length
		if (e !== t.length) return !1
		for (; e--; ) if (!n(r[e], t[e])) return !1
		return !0
	}
	function eqObj(r, t) {
		var n,
			e = Y(null)
		for (n in r) {
			if (notEqObjKey(r, t, n)) return !1
			e[n] = !0
		}
		for (n in t) if (!e[n] && notEqObjKey(r, t, n)) return !1
		return !0
	}
	function notEqObjKey(r, t, n) {
		return H(r, n) ? !H(t, n) || !deepEq(r[n], t[n]) : H(t, n)
	}
	var Rr = [],
		Ir = []
	function parseMessage(r, t, n) {
		var e = Rr[n]
		return (
			e ||
				((Ir[n] = function(r, t) {
					return r[0][t >= n ? t + 1 : t]
				}),
				(Rr[n] = e = Y(null))),
			(e[r] || (e[r] = formatter(r, n, Ir[n])))(t)
		)
	}
	var $r = function assert(r) {
		throw new Error(parseMessage(r || 'Error', arguments, 0))
	}
	function catchErr(r) {
		try {
			r()
		} catch (t) {
			return t
		}
	}
	function checkErr(r, t) {
		return (d(r) ? r : r.message) === t.message
	}
	var Lr = new Error(),
		Nr = mkMsg(objFormatter(1), 'throw')
	function extendAssert(r, t, n, e, i) {
		var u = d(n)
				? n.split(/,/g)
				: l(n)
				? makeArray(n, function(r) {
						return 'arg' + (r + 1)
				  })
				: n,
			o = u.join(', '),
			a = x(t) ? t[0] : t,
			s = (x(t) ? t[1] : '') + (d(a) ? '(' + a + ')' : 'cond(' + o + ')')
		return ($r[r] = createFn(
			'return function assert' +
				upperFirst(r) +
				'(' +
				o +
				', msg){\n\tif (' +
				s +
				')\n\t\tthrow new Err(parseMsg(msg || dmsg, arguments, ' +
				u.length +
				'));\n\treturn assert;\n}',
			['Err', 'parseMsg', 'dmsg', 'cond', 'assert']
		)(i || Error, parseMessage, e, a, $r))
	}
	function extendAsserts(r) {
		eachObj(r, function(r, t) {
			var n = r[0],
				e = r[1],
				i = r[2],
				u = r[3] || TypeError
			i[0] && extendAssert(t, [n, '!'], e, i[0], u), i[1] && extendAssert('not' + upperFirst(t), n, e, i[1], u)
		})
	}
	;($r['throw'] = function(r, t, n) {
		var e = catchErr(r)
		if (!e || (t && !checkErr(t, e)))
			throw ((arguments[0] = e), !t && (arguments[2] = Lr), new Error(parseMessage(n || Nr[0], arguments, 2)))
		return $r
	}),
		($r.notThrow = function(r, t, n) {
			var e = catchErr(r)
			if (e && (!t || !checkErr(t, e)))
				throw ((arguments[0] = e), !t && (arguments[2] = Lr), new Error(parseMessage(n || Nr[0], arguments, 2)))
			return $r
		})
	var Tr = c,
		qr = u,
		Br = a,
		zr = s,
		Hr = o,
		Kr = 'null',
		Zr = 'integer',
		Vr = 'Array',
		Wr = 'TypedArray'
	function mkMsg(r, t) {
		return [expectMsg(r, !1, t), expectMsg(r, !0, t)]
	}
	function expectMsg(r, t, n) {
		return 'Expected ' + objFormatter(0) + ' ' + (t ? 'not ' : '') + (n || 'to') + ' ' + r
	}
	function objFormatter(r) {
		return '{' + r + ':.80="..."j}'
	}
	function packTypeExpect(r, t) {
		return t ? typeExpect(r, upperFirst(r)) : upperFirst(r)
	}
	function typeExpect() {
		return Array.prototype.join.call(arguments, ' | ')
	}
	extendAssert('is', '!o', 'o', expectMsg('Exist')),
		extendAssert('not', 'o', 'o', expectMsg('Not Exist')),
		extendAsserts({
			eq: [eq, 2, mkMsg(objFormatter(1))],
			eql: [deepEq, 2, mkMsg(objFormatter(1))],
			nul: [isNull, 1, mkMsg(Kr)],
			nil: [isNil, 1, mkMsg(typeExpect(Kr, Tr))],
			undef: [isUndef, 1, mkMsg(Tr)],
			bool: [h, 1, mkMsg(qr)],
			num: [l, 1, mkMsg(Br)],
			int: [isInt, 1, mkMsg(Zr)],
			str: [d, 1, mkMsg(zr)],
			fn: [p, 1, mkMsg(Hr)],
			primitive: [isPrimitive, 1, mkMsg('Primitive type(' + typeExpect(Kr, Tr, qr, Br, Zr, zr, Hr) + ')')],
			boolean: [m, 1, mkMsg(packTypeExpect(qr))],
			number: [v, 1, mkMsg(packTypeExpect(Br))],
			string: [g, 1, mkMsg(packTypeExpect(zr))],
			date: [y, 1, mkMsg('Date')],
			reg: [b, 1, mkMsg('RegExp')],
			array: [x, 1, mkMsg(Vr)],
			typedArray: [O, 1, mkMsg('TypedArray')],
			arrayLike: [
				isArrayLike,
				1,
				mkMsg(typeExpect(Vr, packTypeExpect(zr), 'Arguments', Wr, 'NodeList', 'HTMLCollection'))
			],
			obj: [isObj, 1, mkMsg('Object')],
			nan: [isNaN, 1, mkMsg('NaN')],
			finite: [isFinite, 1, mkMsg('Finite')],
			blank: [isBlank, 1, mkMsg('Blank')],
			less: ['o<t', 'o,t', mkMsg(objFormatter(1), 'less than')],
			greater: ['o>t', 'o,t', mkMsg(objFormatter(1), 'greater than')],
			match: ['reg.test(str)', 'str,reg', mkMsg(objFormatter(1), 'match')],
			range: ['o>=s&&o<e', 'o,s,e', mkMsg('[{1} - {2})')]
		})
	var Gr = '__list__',
		Xr = (function() {
			function List(r) {
				;(this.i = 0), (this.h = !1), (this.binding = r || Gr)
			}
			var r = List.prototype
			return (
				(r.size = function size() {
					return this.i
				}),
				(r.has = function has(r) {
					var t = r[this.binding]
					return !!t && (t[0] === r && t[3] === this)
				}),
				(r.add = function add(r) {
					return this.l(r, this.p)
				}),
				(r.addFirst = function addFirst(r) {
					return this.l(r)
				}),
				(r.insertAfter = function insertAfter(r, t) {
					return this.l(r, t && this.m(t))
				}),
				(r.insertBefore = function insertBefore(r, t) {
					return this.l(r, t && this.m(t)[1])
				}),
				(r.addAll = function addAll(r) {
					return this.v(r, this.p)
				}),
				(r.addFirstAll = function addFirstAll(r) {
					return this.v(r)
				}),
				(r.insertAfterAll = function insertAfterAll(r, t) {
					return this.v(r, t && this.m(t))
				}),
				(r.insertBeforeAll = function insertBeforeAll(r, t) {
					return this.v(r, t && this.m(t)[1])
				}),
				(r.prev = function prev(r) {
					return this.k(r, 1)
				}),
				(r.next = function next(r) {
					return this.k(r, 2)
				}),
				(r.first = function first() {
					var r = this.A
					return r && r[0]
				}),
				(r.last = function last() {
					var r = this.p
					return r && r[0]
				}),
				(r.each = function each(r, t) {
					if (this.i) {
						$r.not(this.h, 'Nested calls are not allowed.'), (this.h = !0), (r = P(r, t))
						for (var n = this.A; n && (n[3] !== this || !1 !== r(n[0])); ) n = n[2]
						this.M(), (this.h = !1)
					}
				}),
				(r.toArray = function toArray() {
					for (var r = new Array(this.i), t = this.A, n = 0; t; ) t[3] === this && (r[n++] = t[0]), (t = t[2])
					return r
				}),
				(r.remove = function remove(r) {
					return this._(this.m(r))
				}),
				(r.pop = function pop() {}),
				(r.clean = function clean() {
					if (this.i)
						if (this.h) {
							for (var r = this.A; r; ) r[3] === this && this.F(r), (r = r[2])
							this.i = 0
						} else this.S()
				}),
				(r.C = function __initNode(r) {
					var t = this.binding,
						n = r[t]
					if (n && n[0] === r) {
						if (n[3] === this) return this._(n), this.C(r)
						n[3] && $r('Object is still in some List')
					} else ((n = [r]).toJSON = EMPTY_FN), U(r, t, n, !1)
					return (n[3] = this), n
				}),
				(r.m = function __getNode(r) {
					var t = r[this.binding]
					return $r.is(t && t[3] === this, 'Object is not in this List'), t
				}),
				(r.k = function __siblingObj(r, t) {
					var n = this.m(r)[t]
					if (n) {
						for (; !n[3]; ) if (!(n = n[t])) return
						return n[0]
					}
				}),
				(r.P = function __doInsert(r, t, n, e) {
					var i
					return (
						(r[1] = e),
						e ? ((t[2] = i = e[2]), (e[2] = r)) : ((t[2] = i = this.A), (this.A = r)),
						i ? (i[1] = t) : (this.p = t),
						(this.i += n)
					)
				}),
				(r.l = function __insert(r, t) {
					var n = this.C(r)
					return this.P(n, n, 1, t)
				}),
				(r.v = function __insertAll(r, t) {
					var n = r.length
					if (n) {
						for (var e = this.C(r[0]), i = e, u = e, o = 1; o < n; o++)
							((u = this.C(r[o]))[1] = i), (i[2] = u), (i = u)
						return this.P(e, u, n, t)
					}
					return -1
				}),
				(r._ = function __remove(r) {
					return this.h ? this.F(r) : this.R(r), --this.i
				}),
				(r.F = function __lazyRemove(r) {
					var t = this.I
					;(r[0][this.binding] = undefined), (r[3] = null), t ? t.push(r) : (this.I = [r])
				}),
				(r.M = function __doLazyRemove() {
					var r = this.I
					if (r) {
						var t = r.length
						if (t) {
							if (this.i) for (; t--; ) this.R(r[t])
							else this.S()
							r.length = 0
						}
					}
				}),
				(r.R = function __doRemove(r) {
					var t = r[1],
						n = r[2]
					t ? (t[2] = n) : (this.A = n), n ? (n[1] = t) : (this.p = t), (r[1] = r[2] = r[3] = null)
				}),
				(r.S = function __clean() {
					for (var r, t = this.A; (r = t); ) (t = r[2]), (r.length = 1)
					;(this.A = undefined), (this.p = undefined), (this.i = 0)
				}),
				List
			)
		})()
	Xr.binding = Gr
	var Dr = '__flist_id__',
		Ur = '__flist_id__',
		Yr = (function() {
			function FnList(r, t) {
				;(this.$ = Y(null)), (this.L = new Xr()), (this.fnBinding = r || Dr), (this.scopeBinding = t || Ur)
			}
			var r = FnList.prototype
			return (
				(r.add = function add(r, t) {
					t = parseScope(t)
					var n = this.L,
						e = this.$,
						i = nodeId(this, r, t),
						u = e[i]
					if (!u) {
						u = [i, r, t]
						var o = n.add(u)
						return o && (e[i] = u), o
					}
					return -1
				}),
				(r.remove = function remove(r, t) {
					var n = this.L,
						e = this.$,
						i = nodeId(this, r, parseScope(t)),
						u = e[i]
					return u ? ((e[i] = undefined), n.remove(u)) : -1
				}),
				(r.has = function has(r, t) {
					return !!this.$[nodeId(this, r, parseScope(t))]
				}),
				(r.size = function size() {
					return this.L.size()
				}),
				(r.clean = function clean() {
					;(this.$ = Y(null)), this.L.clean()
				}),
				(r.each = function each(r, t) {
					;(r = r.bind(t)),
						this.L.each(function(t) {
							return r(t[1], t[2])
						})
				}),
				FnList
			)
		})()
	;(Yr.fnBinding = Dr), (Yr.scopeBinding = Ur)
	var Jr = 1,
		Qr = 1,
		rt = 0
	function nodeId(r, t, n) {
		var e = r.fnBinding,
			i = r.scopeBinding,
			u = t[e],
			o = n ? n[i] : Jr
		return u || (u = U(t, e, ++rt, !1, !1, !1)), o || (o = U(n, i, ++Qr, !1, !1, !1)), u + '&' + o
	}
	function parseScope(r) {
		return r || undefined
	}
	var tt,
		nt = new Yr(),
		et = !1
	function executeTick(r, t) {
		t ? r.call(t) : r()
	}
	function flush() {
		nt.each(executeTick), nt.clean(), (et = !1)
	}
	if (typeof MutationObserver === o) {
		var it = 0,
			ut = new MutationObserver(flush),
			ot = document.createTextNode(it + '')
		ut.observe(ot, { characterData: !0 }),
			(tt = function next() {
				;(ot.data = it + ''), (it = it ? 0 : 1)
			})
	} else
		tt = function next() {
			setTimeout(flush, 0)
		}
	function nextTick(r, t) {
		nt.add(r, t), et || ((et = !0), tt())
	}
	function clearTick(r, t) {
		nt.remove(r, t)
	}
	var at,
		st,
		ct = /([^\n]+)?(\n|$)/g,
		ft = (function() {
			function Source(r) {
				;(this.buff = r), (this.len = r.length), (this.N = []), (this.T = 0)
			}
			var r = Source.prototype
			return (
				(r.position = function position(r) {
					var t,
						n = this.buff,
						e = this.len,
						i = this.N,
						u = this.T,
						o = i.length
					if (!(r < u)) {
						if (u < e) {
							var a
							for (
								ct.lastIndex = t = u;
								(a = ct.exec(n)) && ((i[o++] = [t, a[1] || '']), (t = ct.lastIndex) && !(r < t));

							);
							this.T = t || e
						}
						return o ? [o, (r > e ? e : r) - i[o - 1][0], i[o - 1][1]] : [1, 0, '']
					}
					for (; o--; ) if ((t = r - i[o][0]) >= 0) return [o + 1, t, i[o][1]]
				}),
				(r.source = function source(r) {
					var t = this.buff,
						n = 1,
						e = r ? escapeSourceStr : sourceStr
					return t.replace(ct, function(r, t, i) {
						return pad(String(n++), 3) + ': ' + e(r, t, i)
					})
				}),
				Source
			)
		})()
	function sourceStr(r, t, n) {
		return r || ''
	}
	function escapeSourceStr(r, t, n) {
		return t ? escapeStr(t) + n : n
	}
	function _inheritsLoose(r, t) {
		;(r.prototype = Object.create(t.prototype)), (r.prototype.constructor = r), (r.__proto__ = t)
	}
	function eachCharCodes(r, t, n) {
		var e
		if (d(r)) for (e = r.length; e--; ) eachCharCode(charCode(r, e), t, n)
		else if (x(r)) for (e = r.length; e--; ) eachCharCodes(r[e], t, n)
		else isInt(r) && eachCharCode(r, t, n)
	}
	function eachCharCode(r, t, n) {
		if ((n(r), t)) {
			var e = getAnotherCode(r)
			e && n(e)
		}
	}
	function getAnotherCode(r) {
		return r <= 90 ? (r >= 65 ? r + 32 : 0) : r <= 122 ? r - 32 : 0
	}
	function mixin(r) {
		return function mixin(t) {
			var n = t.prototype
			for (var e in r) H(r, e) && (n[e] = r[e])
			return t
		}
	}
	var ht =
		mixin({ $ruleErr: !0 })(
			(at = (function() {
				function MatchError(r, t, n, e, i) {
					!h(t) && (t = i.capturable),
						(this.capturable = t && n ? n.capturable : t),
						(this.msg = r),
						(this.source = n),
						(this.target = n ? n.target : this),
						(this.context = e),
						(this.rule = i),
						(this.pos = e.startPos())
				}
				return (
					(MatchError.prototype.position = function position() {
						return this.context.source.position(this.pos)
					}),
					MatchError
				)
			})())
		) || at
	function defaultErr(r) {
		return r
	}
	function defaultMatch(r, t, n) {
		n.add(r)
	}
	var lt,
		dt,
		pt,
		mt = 0,
		vt =
			mixin({ $rule: !0 })(
				(st = (function() {
					function Rule(r, t) {
						;(this.id = mt++),
							(this.name = r),
							(this.capturable = !1 !== t.capturable),
							(this.onMatch = t.match || defaultMatch),
							(this.onErr = t.err || defaultErr)
					}
					var r = Rule.prototype
					return (
						(r.mkErr = function mkErr(r, t, n, e) {
							return new ht(r, n, e, t, this)
						}),
						(r.error = function error(r, t, n, e) {
							var i = this.mkErr(r, t, e, n),
								u = this.onErr(i, t, this)
							if (u) return u.$ruleErr ? u : ((i[0] = String(u)), i)
						}),
						(r.matched = function matched(r, t, n) {
							var e = this.onMatch(r, t, n, this)
							if (e) return e.$ruleErr ? e : this.mkErr(String(e), n, !1)
						}),
						(r.enter = function enter(r) {
							return r.create()
						}),
						(r.match = function match(r) {
							return $r()
						}),
						(r.getStart = function getStart(r) {
							return this.startCodes
						}),
						(r.test = function test(r) {
							return !0
						}),
						(r.startCodeTest = function startCodeTest(r) {
							return this.startCodeIdx[r.nextCode()]
						}),
						(r.setStartCodes = function setStartCodes(r, t) {
							var n = [],
								e = []
							eachCharCodes(r, t, function(r) {
								e[r] || (n.push(r), (e[r] = r))
							}),
								(this.startCodes = n),
								this.setCodeIdx(e)
						}),
						(r.setCodeIdx = function setCodeIdx(r) {
							r.length > 1 && ((this.startCodeIdx = r), (this.test = this.startCodeTest))
						}),
						(r.mkExpr = function mkExpr(r) {
							return '<' + this.type + ': ' + r + '>'
						}),
						(r.setExpr = function setExpr(r) {
							;(this.expr = this.mkExpr(r)), (this.EXPECT = 'Expect: ' + r)
						}),
						(r.getExpr = function getExpr(r) {
							return this.name || this.expr
						}),
						(r.toString = function toString() {
							return this.getExpr()
						}),
						Rule
					)
				})())
			) || st,
		gt = (function(r) {
			function MatchRule(t, n, e, i) {
				var u
				return (u = r.call(this, t, i) || this).setStartCodes(n, e), u
			}
			return (
				_inheritsLoose(MatchRule, r),
				(MatchRule.prototype.comsume = function comsume(r, t, n) {
					return n.advance(t), this.matched(r, t, n)
				}),
				MatchRule
			)
		})(vt),
		yt =
			mixin({ type: 'Character' })(
				(lt = (function(r) {
					function CharMatchRule(t, n, e, i) {
						var u,
							o = (u = r.call(this, t, n, e, i) || this).startCodes,
							a = o.length,
							s = '*'
						if (a) {
							for (var c = []; a--; ) c[a] = char(o[a])
							s = '"' + c.join('" | "') + '"'
						}
						return u.setExpr(s), u
					}
					return (
						_inheritsLoose(CharMatchRule, r),
						(CharMatchRule.prototype.match = function match(r) {
							return this.comsume(r.nextChar(), 1, r)
						}),
						CharMatchRule
					)
				})(gt))
			) || lt,
		bt =
			mixin({ type: 'RegExp' })(
				(dt = (function(r) {
					function RegMatchRule(t, n, e, i, u) {
						var o
						e = !1 === e || isInt(e) ? e : !!e || 0
						var a = w && !e,
							s = n.source,
							c = n.ignoreCase
						return (
							(n = new RegExp(
								a ? s : '^(?:' + s + ')',
								(c ? 'i' : '') + (n.multiline ? 'm' : '') + (a ? 'y' : '')
							)),
							((o = r.call(this, t, i, c, u) || this).regexp = n),
							(o.pick = e),
							(o.match = a ? o.stickyMatch : o.execMatch),
							a ? (o.spicker = !1 === e ? pickNone : pickTestStr) : (o.picker = mkPicker(e)),
							o.setExpr(s),
							o
						)
					}
					_inheritsLoose(RegMatchRule, r)
					var t = RegMatchRule.prototype
					return (
						(t.stickyMatch = function stickyMatch(r) {
							var t,
								n = this.regexp,
								e = r.buff(),
								i = r.offset()
							return (
								(n.lastIndex = i),
								n.test(e)
									? ((t = n.lastIndex - i), this.comsume(this.spicker(e, i, t), t, r))
									: this.error(this.EXPECT, r)
							)
						}),
						(t.execMatch = function execMatch(r) {
							var t = this.regexp.exec(r.buff(!0))
							return t ? this.comsume(this.picker(t), t[0].length, r) : this.error(this.EXPECT, r)
						}),
						RegMatchRule
					)
				})(gt))
			) || dt,
		xt = Y(null)
	function mkPicker(r) {
		return (
			xt[r] ||
			(xt[r] =
				!1 === r
					? pickNone
					: !0 === r
					? pickAll
					: r >= 0
					? createFn('return m[' + r + ']', ['m'], 'pick_' + r)
					: createFn(
							'return ' +
								mapArray(new Array(-r), function(r, t) {
									return 'm[' + (t + 1) + ']'
								}).join(' || '),
							['m'],
							'pick_1_' + -r
					  ))
		)
	}
	function pickNone() {
		return null
	}
	function pickAll(r) {
		return r
	}
	function pickTestStr(r, t, n) {
		return cutLStr(r, t, n)
	}
	var Ot,
		kt,
		At =
			mixin({ type: 'String' })(
				(pt = (function(r) {
					function StringMatchRule(t, n, e, i) {
						var u
						return (
							(u =
								r.call(this, t, new RegExp(reEscape(n), e ? 'i' : ''), 0, charCode(n), i) ||
								this).setExpr(n),
							u
						)
					}
					return _inheritsLoose(StringMatchRule, r), StringMatchRule
				})(bt))
			) || pt,
		Mt = (function() {
			function MatchContext(r, t, n, e, i) {
				;(this.source = r),
					(this.parent = i),
					(this.result = []),
					(this.q = t),
					(this.H = n),
					(this.K = e),
					(this.Z = 0),
					i ? ((this.V = i.V), (this.data = i.data)) : this.W()
			}
			var r = MatchContext.prototype
			return (
				(r.W = function __flushCode() {
					var r = this.q,
						t = this.H
					this.V = t < r.length ? charCode(r, t) : 0
				}),
				(r.create = function create() {
					return new MatchContext(this.source, this.q, this.H, this.K + this.Z, this)
				}),
				(r.D = function __setAdvanced(r) {
					$r.notLess(r, 0)
					var t = this.H - this.Z + r
					t < 0 && ((this.q = this.source.buff), (this.H = this.K + r)), (this.Z = r), (this.H = t), this.W()
				}),
				(r.commit = function commit() {
					var r = this.Z
					this.parent.advance(r), (this.K += r), (this.Z = 0), (this.data = null)
				}),
				(r.margeState = function margeState(r) {
					this.D(r.K + r.Z - this.K)
				}),
				(r.rollback = function rollback(r) {
					var t = 0,
						n = 0
					r && ((t = r[0]), (n = r[1])), this.D(t)
					var e = this.result
					e.length > n && (e.length = n)
				}),
				(r.checkpoint = function checkpoint() {
					return [this.Z, this.result.length]
				}),
				(r.advance = function advance(r) {
					;(this.H += r), (this.Z += r), this.W()
				}),
				(r.advanced = function advanced() {
					return this.Z
				}),
				(r.buff = function buff(r) {
					var buff = this.q
					return r && ((this.q = buff = cutStr(buff, this.H)), (this.H = 0)), buff
				}),
				(r.orgBuff = function orgBuff() {
					return this.source.buff
				}),
				(r.offset = function offset() {
					return this.H
				}),
				(r.startPos = function startPos() {
					return this.K
				}),
				(r.currPos = function currPos() {
					return this.K + this.Z
				}),
				(r.pos = function pos() {
					var r = this.K
					return [r, r + this.Z]
				}),
				(r.nextCode = function nextCode() {
					return this.V
				}),
				(r.nextChar = function nextChar() {
					return char(this.V)
				}),
				(r.add = function add(r) {
					var t = this.result
					t[t.length] = r
				}),
				(r.addAll = function addAll(r) {
					for (var t = this.result, n = t.length, e = r.length; e--; ) t[n + e] = r[e]
				}),
				(r.resultSize = function resultSize() {
					return this.result.length
				}),
				MatchContext
			)
		})(),
		_t = -1 >>> 0,
		Ft = (function(r) {
			function ComplexRule(t, n, e, i) {
				var u
				u = r.call(this, t, i) || this
				var o = n[0],
					a = n[1]
				return (
					o < 0 && (o = 0),
					a <= 0 && (a = _t),
					$r.notGreater(o, a),
					(u.rMin = o),
					(u.rMax = a),
					(u.builder = e),
					(o === a && 1 === o) ||
						((u.match = u.rmatch),
						(u.type = u.type + '[' + o + (o === a ? '' : ' - ' + (a === _t ? 'MAX' : a)) + ']')),
					u
				)
			}
			_inheritsLoose(ComplexRule, r)
			var t = ComplexRule.prototype
			return (
				(t.parse = function parse(r, t) {
					var n = new Mt(new ft(r), r, 0, 0)
					n.data = t
					var e = this.match(n)
					if (e) {
						var i,
							u = []
						do {
							;(i = e.position()),
								u.unshift(
									'[' +
										pad(String(i[0]), 3) +
										':' +
										pad(String(i[1]), 2) +
										'] - ' +
										e.rule.toString() +
										': ' +
										e.msg +
										' on "' +
										escapeStr(i[2]) +
										'"'
								)
						} while ((e = e.source))
						throw (u.push('[Source]', n.source.source()), new SyntaxError(u.join('\n')))
					}
					return n.result
				}),
				(t.init = function init() {
					var r = this.builder(this),
						t = r && r.length
					$r.is(t, 'Require Complex Rules'), (this.rules = r)
					var n = this.rnames(r)
					for (this.setExpr(n.join(this.split)); t--; ) n[t] = 'Expect[' + t + ']: ' + n[t]
					return (this.EXPECTS = n), this.U(r), (this.builder = null), this
				}),
				(t.U = function __init(r) {}),
				(t.rmatch = function rmatch(r) {
					return $r()
				}),
				(t.setCodeIdx = function setCodeIdx(t) {
					this.rMin && r.prototype.setCodeIdx.call(this, t)
				}),
				(t.getRules = function getRules() {
					return this.rules || (this.init(), this.rules)
				}),
				(t.getStart = function getStart(r) {
					var t = this.id,
						n = this.startCodes
					return n || ((r && ~idxOfArray(r, t)) || this.rules ? [] : (this.init(), this.startCodes))
				}),
				(t.consume = function consume(r) {
					var t = this.matched(r.result, r.advanced(), r.parent)
					return !t && r.commit(), t
				}),
				(t.rnames = function rnames(r, t) {
					for (var n = r.length, e = new Array(n), i = this.id; n--; )
						e[n] = r[n].getExpr(t ? t.concat(i) : [i])
					return e
				}),
				(t.getExpr = function getExpr(r) {
					var t,
						n = this.id,
						e = this.name
					return (
						e ||
						(r
							? ~(t = idxOfArray(r, n))
								? '<' + this.type + ' -> $' + r[t] + '>'
								: this.mkExpr(this.rnames(this.getRules(), r).join(this.split))
							: this.expr)
					)
				}),
				ComplexRule
			)
		})(vt),
		St =
			mixin({ type: 'And', split: ' ' })(
				(Ot = (function(r) {
					function AndRule() {
						return r.apply(this, arguments) || this
					}
					_inheritsLoose(AndRule, r)
					var t = AndRule.prototype
					return (
						(t.U = function __init(r) {
							this.setStartCodes(r[0].getStart([this.id]))
						}),
						(t.match = function match(r) {
							for (var t, n = this.getRules(), e = n.length, i = r.create(), u = 0; u < e; u++)
								if ((t = this.testRule(n[u], u, i))) return t
							return this.consume(i)
						}),
						(t.rmatch = function rmatch(r) {
							var t,
								n,
								e,
								i = this.rMin,
								u = this.rMax,
								o = this.getRules(),
								a = o.length,
								s = r.create(),
								c = 0
							r: for (; c < u; c++)
								for (e = s.checkpoint(), n = 0; n < a; n++)
									if ((t = this.testRule(o[n], n, s))) {
										if (c < i) return t
										s.rollback(e)
										break r
									}
							return this.consume(s)
						}),
						(t.testRule = function testRule(r, t, n) {
							var e
							return r.test(n)
								? (e = r.match(n))
									? this.error(this.EXPECTS[t], n, e)
									: void 0
								: this.error(this.EXPECTS[t], n)
						}),
						AndRule
					)
				})(Ft))
			) || Ot,
		jt =
			mixin({ type: 'Or', split: ' | ' })(
				(kt = (function(r) {
					function OrRule() {
						return r.apply(this, arguments) || this
					}
					_inheritsLoose(OrRule, r)
					var t = OrRule.prototype
					return (
						(t.U = function __init(r) {
							var t,
								n,
								e,
								i,
								u = this.id,
								o = r.length,
								a = [],
								s = [],
								c = [[]]
							for (t = 0; t < o; t++)
								(s[t] = []),
									eachCharCodes(r[t].getStart([u]), !1, function(r) {
										s[t].push(r), c[r] || ((c[r] = []), a.push(r))
									})
							for (t = 0; t < o; t++)
								for ((i = s[t]).length || (c[0].push(r[t]), (i = a)), n = i.length; n--; )
									(e = c[i[n]]).idx !== t && (e.push(r[t]), (e.idx = t))
							var f = !c[0].length && a
							;(this.startCodes = f || []), f && this.setCodeIdx(c), (this.index = c)
						}),
						(t.match = function match(r) {
							for (
								var t,
									n,
									e = this.index || (this.init(), this.index),
									i = e[r.nextCode()] || e[0],
									u = i.length,
									o = r.create(),
									a = 0;
								a < u;
								a++
							) {
								if (!(t = i[a].match(o) || this.consume(o))) return
								if (!t.capturable) {
									n = t
									break
								}
								;(!n || t.pos >= n.pos) && (n = t), o.rollback()
							}
							return this.error(this.EXPECT, o, n)
						}),
						(t.rmatch = function rmatch(r) {
							var t,
								n,
								e,
								i,
								u,
								o,
								a = this.rMin,
								s = this.rMax,
								c = this.index || (this.init(), this.index),
								f = r.create(),
								h = 0
							r: for (; h < s; h++) {
								if (((i = null), (n = (t = c[f.nextCode()] || c[0]).length)))
									for (o = f.checkpoint(), u = 0; u < n; u++) {
										if (!(e = t[u].match(f))) continue r
										if (!e.capturable) {
											i = e
											break
										}
										;(!i || e.pos >= i.pos) && (i = e), f.rollback(o)
									}
								if (h < a || (i && !i.capturable)) return this.error(this.EXPECT, f, i)
								break
							}
							return this.consume(f)
						}),
						OrRule
					)
				})(Ft))
			) || kt,
		Ct = EMPTY_FN
	function appendMatch(r, t, n) {
		n.addAll(r)
	}
	function attachMatch(r) {
		var t = p(r)
			? r
			: function() {
					return r
			  }
		return function(r, n, e, i) {
			e.add(t(r, n, e, i))
		}
	}
	function match() {
		return mkMatch(arguments)
	}
	function and() {
		return mkComplexRule(arguments, St, [1, 1])
	}
	function any() {
		return mkComplexRule(arguments, St, [0, -1])
	}
	function many() {
		return mkComplexRule(arguments, St, [1, -1])
	}
	function option() {
		return mkComplexRule(arguments, St, [0, 1])
	}
	function or() {
		return mkComplexRule(arguments, jt, [1, 1])
	}
	function anyOne() {
		return mkComplexRule(arguments, jt, [0, -1])
	}
	function manyOne() {
		return mkComplexRule(arguments, jt, [1, -1])
	}
	function optionOne() {
		return mkComplexRule(arguments, jt, [0, 1])
	}
	function mkMatch(r, t) {
		var n,
			e,
			i,
			u,
			o,
			a = 0,
			s = !1
		if (isObj(r[0])) {
			var c = r[0],
				f = c.pattern
			b(f) ? ((i = f), (a = c.pick), (u = c.startCodes)) : isStrOrCodes(f) && ((e = f), (s = c.ignoreCase)),
				(n = c.name),
				(o = c)
		} else {
			var l = 1
			d(r[0]) && isMatchPattern(r[1])
				? ((n = r[0]), b(r[1]) ? (i = r[1]) : (e = r[1]), (l = 2))
				: isMatchPattern(r[0]) && (b(r[0]) ? (i = r[0]) : (e = r[0])),
				i
					? ((h(r[l]) || isInt(r[l])) && (a = r[l++]), isStrOrCodes(r[l]) && (u = r[l++]))
					: h(r[l]) && (s = r[l++]),
				(o = parseRuleOptions(r, l))
		}
		return (
			!o.match && (o.match = t),
			i ? new bt(n, i, o.match !== Ct && a, u, o) : e ? strMatch(n, e, s, o) : $r('invalid match rule {j}', r)
		)
	}
	function isStrOrCodes(r) {
		return d(r) || l(r) || x(r)
	}
	function isMatchPattern(r) {
		return b(r) || isStrOrCodes(r)
	}
	function strMatch(r, t, n, e) {
		return new (d(t) && t.length > 1 ? At : yt)(r, t, n, e)
	}
	function mkComplexRule(r, t, n) {
		var e, i, u, o
		if (isObj(r[0])) {
			var a = r[0],
				s = a.rules
			;(x(s) || p(s)) && (i = s), (u = a.repeat), (e = a.name), (o = a)
		} else {
			var c = 0
			d(r[c]) && (e = r[c++]),
				(x(r[c]) || p(r[c])) && (i = r[c++]),
				x(r[c]) && (u = r[c++]),
				(o = parseRuleOptions(r, c))
		}
		if ((u || (u = n), i)) return new t(e, u, rulesBuilder(i), o)
	}
	function rulesBuilder(r) {
		return function(t) {
			return mapArray(p(r) ? r(t) : r, function(r, n) {
				if (!r) return rr
				var e = r.$rule ? r : mkMatch(x(r) ? r : [r], Ct)
				return $r.is(e, '{}: Invalid Rule Configuration on index {d}: {j}', t, n, r), e
			})
		}
	}
	function parseRuleOptions(r, t) {
		var n = {}
		return h(r[t]) && (n.capturable = r[t++]), (n.match = r[t++]), (n.err = r[t]), n
	}
	;(r.createFn = createFn),
		(r.applyScope = A),
		(r.applyNoScope = M),
		(r.applyScopeN = _),
		(r.applyNoScopeN = F),
		(r.apply = apply),
		(r.applyN = applyN),
		(r.fnName = fnName),
		(r.bind = P),
		(r.eq = eq),
		(r.isNull = isNull),
		(r.isUndef = isUndef),
		(r.isNil = isNil),
		(r.isBool = h),
		(r.isNum = l),
		(r.isStr = d),
		(r.isFn = p),
		(r.isInt = isInt),
		(r.isPrimitive = isPrimitive),
		(r.instOf = instOf),
		(r.is = is),
		(r.isBoolean = m),
		(r.isNumber = v),
		(r.isString = g),
		(r.isDate = y),
		(r.isReg = b),
		(r.isArray = x),
		(r.isTypedArray = O),
		(r.isArrayLike = isArrayLike),
		(r.isObj = isObj),
		(r.isBlank = isBlank),
		(r.stickyReg = w),
		(r.unicodeReg = E),
		(r.reEscape = reEscape),
		(r.prototypeOf = N),
		(r.protoProp = T),
		(r.protoOf = q),
		(r.Y = B),
		(r.setProto = z),
		(r.getOwnProp = getOwnProp),
		(r.hasOwnProp = H),
		(r.propDescriptor = G),
		(r.propAccessor = X),
		(r.defProp = D),
		(r.defPropValue = U),
		(r.parsePath = parsePath),
		(r.formatPath = formatPath),
		(r.get = get),
		(r.set = set),
		(r.charCode = charCode),
		(r.char = char),
		(r.cutStr = cutStr),
		(r.cutLStr = cutLStr),
		(r.trim = trim),
		(r.upper = upper),
		(r.lower = lower),
		(r.upperFirst = upperFirst),
		(r.lowerFirst = lowerFirst),
		(r.escapeStr = escapeStr),
		(r.pad = pad),
		(r.shorten = shorten),
		(r.thousandSeparate = cr),
		(r.binarySeparate = fr),
		(r.octalSeparate = hr),
		(r.hexSeparate = lr),
		(r.plural = plural),
		(r.singular = singular),
		(r.FORMAT_XPREFIX = mr),
		(r.FORMAT_PLUS = vr),
		(r.FORMAT_ZERO = gr),
		(r.FORMAT_SPACE = yr),
		(r.FORMAT_SEPARATOR = br),
		(r.FORMAT_LEFT = xr),
		(r.extendFormatter = extendFormatter),
		(r.getFormatter = getFormatter),
		(r.vformat = vformat),
		(r.format = format),
		(r.formatter = formatter),
		(r.create = Y),
		(r.doAssign = doAssign),
		(r.assign = assign),
		(r.assignIf = assignIf),
		(r.defaultAssignFilter = defaultAssignFilter),
		(r.assignIfFilter = assignIfFilter),
		(r.makeArray = makeArray),
		(r.STOP = Q),
		(r.eachProps = eachProps),
		(r.eachArray = eachArray),
		(r.eachObj = eachObj),
		(r.each = each),
		(r.SKIP = rr),
		(r.mapArray = mapArray),
		(r.mapObj = mapObj),
		(r.map = map),
		(r.idxOfArray = idxOfArray),
		(r.idxOfObj = idxOfObj),
		(r.idxOf = idxOf),
		(r.reduceArray = reduceArray),
		(r.reduceObj = reduceObj),
		(r.reduce = reduce),
		(r.keys = keys),
		(r.values = values),
		(r.arr2obj = arr2obj),
		(r.makeMap = makeMap),
		(r.List = Xr),
		(r.FnList = Yr),
		(r.nextTick = nextTick),
		(r.clearTick = clearTick),
		(r.Source = ft),
		(r.discardMatch = Ct),
		(r.appendMatch = appendMatch),
		(r.attachMatch = attachMatch),
		(r.match = match),
		(r.and = and),
		(r.any = any),
		(r.many = many),
		(r.option = option),
		(r.or = or),
		(r.anyOne = anyOne),
		(r.manyOne = manyOne),
		(r.optionOne = optionOne),
		Object.defineProperty(r, 'J', { value: !0 })
})
