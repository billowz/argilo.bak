{"version":3,"file":"argilo.es.js","sources":["../src/utility/consts.ts","../src/utility/is.ts","../src/utility/fn.ts","../src/utility/reg.ts","../src/utility/proto.ts","../src/utility/prop.ts","../src/utility/create.ts","../src/utility/collection/control.ts","../src/utility/collection/each.ts","../src/utility/collection/map.ts","../src/utility/collection/idxOf.ts","../src/utility/collection/reduce.ts","../src/utility/collection/obj2arr.ts","../src/utility/collection/arr2obj.ts","../src/utility/collection/index.ts","../src/utility/propPath.ts","../src/utility/string.ts","../src/utility/format.ts","../src/utility/assign.ts","../src/utility/List/List.ts","../src/utility/List/FnList.ts","../src/utility/List/index.ts","../src/utility/nextTick.ts","../src/utility/index.ts","../src/index.ts"],"sourcesContent":["/**\n *\n * @author Tao Zeng (tao.zeng.zt@qq.com)\n * @module utility\n * @created 2018-11-09 15:23:35\n * @modified 2018-11-09 15:23:35 by Tao Zeng (tao.zeng.zt@qq.com)\n */\n\nexport const CONSTRUCTOR = 'constructor'\n\nexport const PROTOTYPE = 'prototype'\n\nexport const PROTO = '__proto__'\n\nexport const TYPE_BOOL = 'boolean'\n\nexport const TYPE_FN = 'function'\n\nexport const TYPE_NUM = 'number'\n\nexport const TYPE_STRING = 'string'\n\nexport const TYPE_UNDEF = 'undefined'\n\nexport const GLOBAL: any =\n\ttypeof window !== TYPE_UNDEF\n\t\t? window\n\t\t: typeof global !== TYPE_UNDEF\n\t\t? global\n\t\t: typeof self !== TYPE_UNDEF\n\t\t? self\n\t\t: {}\n\nexport interface ObjArray {\n\tlength: number;\n}\nexport  type IArray = any[] |string | IArguments | ObjArray\n","/**\n * type checker\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Mon Dec 03 2018 17:48:07 GMT+0800 (China Standard Time)\n */\n\nimport { CONSTRUCTOR, GLOBAL, TYPE_BOOL, TYPE_FN, TYPE_NUM, TYPE_STRING, TYPE_UNDEF } from './consts'\n\n/**\n * is equals\n * > o1 === o2 || NaN === NaN\n */\nexport function eq(o1: any, o2: any): boolean {\n\treturn o1 === o2 || (o1 !== o1 && o2 !== o2)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    primitive type                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * is null\n */\nexport function isNull(o: any): boolean {\n\treturn o === null\n}\n\n/**\n * is undefined\n */\nexport function isUndef(o: any): boolean {\n\treturn o === undefined\n}\n\n/**\n * is null or undefined\n */\nexport function isNil(o: any): boolean {\n\treturn o === null || o === undefined\n}\n\n/**\n * is boolean\n */\nexport const isBool: (o: any) => boolean = mkIsPrimitive(TYPE_BOOL)\n\n/**\n * is a number\n */\nexport const isNum: (o: any) => boolean = mkIsPrimitive(TYPE_NUM)\n\n/**\n * is a string\n */\nexport const isStr: (o: any) => boolean = mkIsPrimitive(TYPE_STRING)\n\n/**\n * is a function\n */\nexport const isFn: (o: any) => boolean = mkIsPrimitive(TYPE_FN)\n\n/**\n * is integer number\n */\nexport function isInt(o: any): boolean {\n\treturn o === 0 || (o ? typeof o === TYPE_NUM && o % 1 === 0 : false)\n}\n\n/**\n * is primitive type\n * - null\n * - undefined\n * - boolean\n * - number\n * - string\n * - function\n */\nexport function isPrimitive(o: any): boolean {\n\tif (o === undefined || o === null) {\n\t\treturn true\n\t}\n\tswitch (typeof o) {\n\t\tcase TYPE_BOOL:\n\t\tcase TYPE_NUM:\n\t\tcase TYPE_STRING:\n\t\tcase TYPE_FN:\n\t\t\treturn true\n\t}\n\treturn false\n}\n\nfunction mkIsPrimitive(type: string): (o: any) => boolean {\n\treturn function is(o: any): boolean {\n\t\treturn typeof o === type\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    reference type                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * is instanceof\n */\nexport function instOf(obj: any, Cls: Function): boolean {\n\treturn obj !== undefined && obj !== null && obj instanceof Cls\n}\n\n/**\n * is child instance of Type\n */\nexport function is(o: any, Type: Function | Function[]): boolean {\n\tif (o !== undefined && o !== null) {\n\t\tconst C = o[CONSTRUCTOR] || Object\n\t\tif (Type[CONSTRUCTOR] === Array) {\n\t\t\tvar i = Type.length\n\t\t\twhile (i--) {\n\t\t\t\tif (C === (Type as Function[])[i]) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn C === Type\n\t\t}\n\t}\n\treturn false\n}\n\n/**\n * is boolean or Boolean\n */\nexport const isBoolean: (o: any) => boolean = mkIs(Boolean)\n\n/**\n * is number or Number\n */\nexport const isNumber: (o: any) => boolean = mkIs(Number)\n\n/**\n * is string or String\n */\nexport const isString: (o: any) => boolean = mkIs(String)\n\n/**\n * is Date\n */\nexport const isDate: (o: any) => boolean = mkIs(Date)\n\n/**\n * is RegExp\n */\nexport const isReg: (o: any) => boolean = mkIs(RegExp)\n\n/**\n * is Array\n */\nexport const isArray: (o: any) => boolean = Array.isArray || mkIs(Array)\n\n/**\n * is Typed Array\n */\nexport const isTypedArray: (o: any) => boolean = isFn(ArrayBuffer) ? ArrayBuffer.isView : () => false\n\n/**\n * is Array or pseudo-array\n * - Array\n * - String\n * - IArguments\n * - NodeList\n * - HTMLCollection\n * - Typed Array\n * - {length: int, [length-1]: any}\n */\nexport function isArrayLike(o: any): boolean {\n\tif (o) {\n\t\tswitch (o[CONSTRUCTOR]) {\n\t\t\tcase Array:\n\t\t\tcase String:\n\t\t\tcase GLOBAL.NodeList:\n\t\t\tcase GLOBAL.HTMLCollection:\n\t\t\tcase GLOBAL.Int8Array:\n\t\t\tcase GLOBAL.Uint8Array:\n\t\t\tcase GLOBAL.Int16Array:\n\t\t\tcase GLOBAL.Uint16Array:\n\t\t\tcase GLOBAL.Int32Array:\n\t\t\tcase GLOBAL.Uint32Array:\n\t\t\tcase GLOBAL.Float32Array:\n\t\t\tcase GLOBAL.Float64Array:\n\t\t\t\treturn true\n\t\t}\n\t\tconst len = o.length\n\t\treturn typeof len === TYPE_NUM && (len === 0 || (len > 0 && len % 1 === 0 && len - 1 in o))\n\t}\n\treturn o === ''\n}\n\n/**\n * is simple Object\n * TODO object may has constructor property\n */\nexport function isObj(o: any): boolean {\n\tif (o === undefined || o === null) {\n\t\treturn false\n\t}\n\tconst C = o[CONSTRUCTOR]\n\treturn C === undefined || C === Object\n}\n\nfunction mkIs(Type: Function): (o: any) => boolean {\n\treturn function is(o: any): boolean {\n\t\treturn o !== undefined && o !== null && o[CONSTRUCTOR] === Type\n\t}\n}\n\nconst blankStrReg = /^\\s*$/\n/**\n * is empty\n * - string: trim(string).length === 0\n * - array: array.length === 0\n * - pseudo-array: pseudo-array.length === 0\n */\nexport function isBlank(o: any): boolean {\n\tif (o) {\n\t\tif (o[CONSTRUCTOR] === String) {\n\t\t\treturn blankStrReg.test(o)\n\t\t}\n\t\treturn o.length === 0\n\t}\n\treturn true\n}\n","/**\n * Function utilities\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Fri Nov 23 2018 11:18:33 GMT+0800 (China Standard Time)\n */\n\nimport { GLOBAL, PROTOTYPE } from './consts'\nimport { isNil } from './is'\n\n// ========================================================================================\n/*                                                                                      *\n *                                    create function                                   *\n *                                                                                      */\n// ========================================================================================\n\n/**\n * create function by code string\n * @param body\tfunction body\n * @param args\tfunction argument names\n * @param name\tfunction name\n */\nexport function createFn<T extends Function>(body: string, args?: string[], name?: string): T {\n\treturn name\n\t\t? Function(`return function ${name}(${args ? args.join(', ') : ''}){${body}}`)()\n\t\t: applyScope(Function, Function, args && args.length ? args.concat(body) : [body])\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                    function apply                                    *\n *                                                                                      */\n// ========================================================================================\n\n/**\n * generate apply function\n */\nfunction applyBuilder<T extends Function>(maxArgs: number, scope: any, offset: any): T {\n\tscope = scope ? 'scope' : ''\n\toffset = offset ? 'offset' : ''\n\tconst args = new Array(maxArgs + 1)\n\tconst cases = new Array(maxArgs + 1)\n\tfor (let i = 0; i <= maxArgs; i++) {\n\t\targs[i] = `${i || scope ? ', ' : ''}args[${offset ? `offset${i ? ' + ' + i : ''}` : i}]`\n\t\tcases[i] = `case ${i}: return fn${scope && '.call'}(${scope}${args.slice(0, i).join('')});`\n\t}\n\treturn Function(`return function(fn, ${scope && scope + ', '}args${offset && ', offset, len'}){\nswitch(${offset ? 'len' : 'args.length'}){\n${cases.join('\\n')}\n}\n${offset &&\n\t\t`var arr = new Array(len);\nfor(var i=0; i<len; i++) arr[i] = arr[offset + i];`}\nreturn fn.apply(${scope || 'null'}, ${offset ? 'arr' : 'args'});\n}`)()\n}\n\n/**\n * apply function with scope\n * @param fn\ttarget function\n * @param scope\tscope of function\n * @param args\targuments of function\n */\nexport const applyScope: (fn: Function, scope: any, args: any[] | IArguments) => any = applyBuilder(8, 1, 0)\n\n/**\n * apply function without scope\n * @param fn\t\ttarget function\n * @param args\targuments of function\n */\nexport const applyNoScope: (fn: Function, args: any[] | IArguments) => any = applyBuilder(8, 0, 0)\n\n/**\n * apply function with scope\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport const applyScopeN: (\n\tfn: Function,\n\tscope: any,\n\targs: any[] | IArguments,\n\toffset: number,\n\tlen: number\n) => any = applyBuilder(8, 1, 1)\n\n/**\n * apply function without scope\n * @param fn\t\ttarget function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport const applyNoScopeN: (fn: Function, args: any[] | IArguments, offset: number, len: number) => any = applyBuilder(\n\t8,\n\t0,\n\t1\n)\n\n/**\n * apply function\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n */\nexport function apply(fn: Function, scope: any, args: any[] | IArguments): any {\n\tif (scope === undefined || scope === null || scope === GLOBAL) {\n\t\treturn applyNoScope(fn, args || [])\n\t}\n\treturn applyScope(fn, scope, args || [])\n}\n\n/**\n * apply function\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport function applyN(fn: Function, scope: any, args: any[] | IArguments, offset: number, len: number): any {\n\tif (scope === undefined || scope === null || scope === GLOBAL) {\n\t\treturn applyNoScopeN(fn, args, offset, len)\n\t}\n\treturn applyScopeN(fn, scope, args, offset, len)\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                     function name                                    *\n *                                                                                      */\n// ========================================================================================\n\nconst varGenReg = /\\$\\d+$/\n\n/**\n * get function name\n */\nexport function fnName(fn: Function): string {\n\tconst name: string = (fn as any).name\n\treturn name ? name.replace(varGenReg, '') : 'anonymous'\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                         bind                                         *\n *                                                                                      */\n// ========================================================================================\n\nlet _bind\nconst funcProto = Function[PROTOTYPE]\nif (funcProto.bind) {\n\t_bind = function bind<T extends Function>(fn: T, scope: any): T {\n\t\tconst args = arguments,\n\t\t\targLen = args.length\n\t\tif (isNil(scope)) {\n\t\t\treturn argLen > 2 ? bindPolyfill(fn, scope, args, 2) : fn\n\t\t}\n\t\treturn applyScopeN(fn.bind, fn, args, 1, argLen - 1)\n\t}\n} else {\n\tfuncProto.bind = function bind(scope) {\n\t\treturn bindPolyfill(this, scope, arguments, 1)\n\t}\n\t_bind = function bind<T extends Function>(fn: T, scope: any): T {\n\t\treturn bindPolyfill(fn, scope, arguments, 2)\n\t}\n}\n\n/**\n * bind scope or arguments on function\n * - return source function when without arguments and scope is undefined or null\n * - only bind arguments when scope is undefined or null, well can call the new function proxy with some scope\n *\n * @example\n * \t\tfunction example() {\n * \t\t\tconsole.log(this, arguments);\n * \t\t}\n * \t\tvar proxy = bind(example, null) \t// proxy === example\n * \t\tproxy() \t\t\t\t\t\t\t// log: window | undefined, []\n * \t\tproxy.call(1) \t\t\t\t\t\t// log: 1, []\n *\n * \t\tproxy = bind(example, null, 1) \t\t// proxy !== example\n * \t\tproxy() \t\t\t\t\t\t\t// log: window | undefined, [1]\n * \t\tproxy(2) \t\t\t\t\t\t\t// log: window | undefined, [1, 2]\n * \t\tproxy.call(1, 2) \t\t\t\t\t// log: 1, [1, 2]\n *\n * \t\tproxy = bind(example, {}, 1, 2)\t\t// proxy !== example\n * \t\tproxy() \t\t\t\t\t\t\t// log: {}, [1]\n * \t\tproxy(2) \t\t\t\t\t\t\t// log: {}, [1, 2, 2]\n * \t\tproxy.call(1, 2) \t\t\t\t\t// log: {}, [1, 2, 2]\n *\n * @param fn\tsource function\n * @param scope\tbind scope\n * @param args\tbind arguments\n * @return function proxy\n */\nexport const bind: <T extends Function>(fn: T, scope: any, ...args: any[]) => T = _bind\n\n/**\n * bind\n * > not bind scope when scope is null or undefined\n * @param fn\t\tsource function\n * @param scope\t\tbind scope\n * @param args\t\tbind arguments\n * @param argOffset\toffset of args\n * @return function proxy\n */\nfunction bindPolyfill<T extends Function>(fn: T, scope: any, bindArgs: any[] | IArguments, argOffset: number): T {\n\tconst argLen = bindArgs.length - argOffset\n\tif (scope === undefined) {\n\t\tscope = null\n\t}\n\tif (argLen > 0) {\n\t\t// bind with arguments\n\t\treturn function bindProxy() {\n\t\t\tconst args = arguments\n\t\t\tlet i = args.length\n\t\t\tif (i) {\n\t\t\t\tconst params = new Array(argLen + i)\n\t\t\t\twhile (i--) {\n\t\t\t\t\tparams[argLen + i] = args[i]\n\t\t\t\t}\n\t\t\t\ti = argLen\n\t\t\t\twhile (i--) {\n\t\t\t\t\tparams[i] = bindArgs[i + argOffset]\n\t\t\t\t}\n\t\t\t\treturn apply(fn, scope === null ? this : scope, params) // call with scope or this\n\t\t\t}\n\t\t\treturn applyN(fn, scope === null ? this : scope, bindArgs, argOffset, argLen) // call with scope or this\n\t\t} as any\n\t}\n\tif (scope === null) {\n\t\treturn fn\n\t}\n\tif (scope === GLOBAL) {\n\t\t// bind on GLOBAL\n\t\treturn function bindProxy() {\n\t\t\treturn applyNoScope(fn, arguments)\n\t\t} as any\n\t}\n\treturn function bindProxy() {\n\t\treturn applyScope(fn, scope, arguments)\n\t} as any\n}\n","/**\n * regexp utilities\n * @module utility/reg\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Sep 06 2018 18:27:51 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 20:00:44 GMT+0800 (China Standard Time)\n */\n\nimport { isBool } from './is'\n\n/**\n * is support sticky on RegExp\n */\nexport const regStickySupport = isBool(/(?:)/.sticky)\n\n/**\n * is support unicode on RegExp\n */\nexport const regUnicodeSupport = isBool(/(?:)/.unicode)\n\nconst REG_ESCAPE = /[-\\/\\\\^$*+?.()|[\\]{}]/g\n\n/**\n * escape string for RegExp\n */\nexport function reEscape(str: string): string {\n\treturn str.replace(REG_ESCAPE, '\\\\$&')\n}\n","/**\n * prototype utilities\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:23:56 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 20:00:18 GMT+0800 (China Standard Time)\n */\nimport { CONSTRUCTOR, PROTO, PROTOTYPE } from './consts'\n\nconst __hasOwn = Object[PROTOTYPE].hasOwnProperty\nconst __getProto = Object.getPrototypeOf,\n\t____setProto = Object.setPrototypeOf\n\n/**\n * is support Object.getPrototypeOf and Object.setPrototypeOf\n */\nexport const prototypeOfSupport = !!____setProto\n\nexport const protoPropSupport = { __proto__: [] } instanceof Array\n\n/**\n * Object.getPrototypeOf shim\n */\nexport const protoOf: (o: any) => any = ____setProto\n\t? __getProto\n\t: __getProto\n\t? function getPrototypeOf(obj) {\n\t\t\treturn obj[PROTO] || __getProto(obj)\n\t  }\n\t: function getPrototypeOf(obj) {\n\t\t\treturn (__hasOwn.call(obj, PROTO) ? obj[PROTO] : obj[CONSTRUCTOR][PROTOTYPE]) || null\n\t  }\n\nexport const __setProto: <T>(obj: any, proto: any) => any =\n\t____setProto ||\n\tfunction setPrototypeOf(obj, proto) {\n\t\tobj[PROTO] = proto\n\t\treturn obj\n\t}\n\n/**\n * Object.setPrototypeOf shim\n */\nexport const setProto: <T>(obj: any, proto: any) => any =\n\t____setProto ||\n\t(protoPropSupport\n\t\t? __setProto\n\t\t: function setPrototypeOf(obj, proto) {\n\t\t\t\tfor (let p in proto) {\n\t\t\t\t\tif (__hasOwn.call(proto, p)) {\n\t\t\t\t\t\tobj[p] = proto[p]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn __setProto(obj, proto)\n\t\t  })\n","/**\n * prop utilities\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:22:57 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 20:00:13 GMT+0800 (China Standard Time)\n */\nimport { PROTO, PROTOTYPE } from './consts'\nimport { protoPropSupport } from './proto'\n\nconst __hasOwn = Object[PROTOTYPE].hasOwnProperty\n\n/**\n * has own property\n */\nexport const hasOwnProp: (obj: any, prop: string) => boolean = protoPropSupport\n\t? function hasOwnProp(obj: any, prop: string): boolean {\n\t\t\treturn __hasOwn.call(obj, prop)\n\t  }\n\t: function hasOwnProp(obj: any, prop: string): boolean {\n\t\t\treturn prop !== PROTO && __hasOwn.call(obj, prop)\n\t  }\n\n/**\n * get owner property value\n * @param prop \t\t\tproperty name\n * @param defaultVal \tdefault value\n */\nexport function getOwnProp(obj: any, prop: string, defaultVal?: any): any {\n\treturn hasOwnProp(obj, prop) ? obj[prop] : defaultVal\n}\n\nlet __defProp = Object.defineProperty\n/**\n * is support Object.defineProperty\n */\nexport const defPropSupport: boolean =\n\t__defProp &&\n\t(function() {\n\t\ttry {\n\t\t\tvar val,\n\t\t\t\tobj: any = {}\n\t\t\t__defProp(obj, 's', {\n\t\t\t\tget() {\n\t\t\t\t\treturn val\n\t\t\t\t},\n\t\t\t\tset(value) {\n\t\t\t\t\tval = value\n\t\t\t\t}\n\t\t\t})\n\t\t\tobj.s = 1\n\t\t\treturn obj.s === val\n\t\t} catch (e) {}\n\t})()\n\nif (!defPropSupport) {\n\t__defProp = function defineProperty(\n\t\tobj: any,\n\t\tprop: string | number | symbol,\n\t\tdesc: PropertyDescriptor & ThisType<any>\n\t): any {\n\t\tif (desc.get || desc.set) {\n\t\t\tthrow new Error('not support getter/setter on defineProperty')\n\t\t}\n\t\tobj[prop] = desc.value\n\t\treturn obj\n\t}\n}\n\n/**\n * define property\n */\nexport const defProp = __defProp\n\n/**\n * define property by value\n */\nexport const defPropValue: <V>(\n\tobj: any,\n\tprop: string,\n\tvalue: V,\n\tconfigurable?: boolean,\n\twritable?: boolean,\n\tenumerable?: boolean\n) => V = defPropSupport\n\t? function defPropValue(obj, prop, value, configurable, writable, enumerable) {\n\t\t\t__defProp(obj, prop, {\n\t\t\t\tvalue,\n\t\t\t\tconfigurable: configurable || false,\n\t\t\t\twritable: writable || false,\n\t\t\t\tenumerable: enumerable || false\n\t\t\t})\n\t\t\treturn value\n\t  }\n\t: function defPropValue(obj, prop, value) {\n\t\t\tobj[prop] = value\n\t\t\treturn value\n\t  }\n","/**\n * Object.create shim\n * @module utility/create\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:24:47 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 15:37:23 GMT+0800 (China Standard Time)\n */\n\nimport { CONSTRUCTOR, PROTOTYPE } from './consts'\nimport { defProp, hasOwnProp } from './prop'\nimport { __setProto } from './proto'\n\nfunction __() {}\n\n/**\n * create shim\n */\nfunction doCreate(o: object | null, props?: PropertyDescriptorMap & ThisType<any>): object {\n\t__[PROTOTYPE] = o\n\tconst obj = new __()\n\t__[PROTOTYPE] = null\n\tif (props) {\n\t\tvar k, v\n\t\tfor (k in props) {\n\t\t\tif (hasOwnProp(props, k)) {\n\t\t\t\tdefProp(obj, k, props[k])\n\t\t\t}\n\t\t}\n\t}\n\treturn obj\n}\n\n/**\n * create object\n */\nexport default Object.create ||\n\t(Object.getPrototypeOf\n\t\t? doCreate\n\t\t: function create(o: object | null, props?: PropertyDescriptorMap & ThisType<any>): object {\n\t\t\t\tconst obj = doCreate(o, props)\n\t\t\t\t__setProto(obj, o)\n\t\t\t\treturn obj\n\t\t  })\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:10:41 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 14:17:32 GMT+0800 (China Standard Time)\n */\nexport class Control {\n\tprivate desc: string\n\tconstructor(desc: string) {\n\t\tthis.desc = desc\n\t}\n\ttoString() {\n\t\treturn this.desc\n\t}\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:10:41 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:39:11 GMT+0800 (China Standard Time)\n */\nimport { Control } from './control'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { hasOwnProp } from '../prop'\nimport { isArrayLike, isBool } from '../is'\n\n/**\n * STOP Control\n * > stop each/map/indexOf...\n */\nexport const STOP = new Control('STOP')\n//========================================================================================\n/*                                                                                      *\n *                                each object properties                                *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on object\n * - will stop each on return STOP\n */\nexport type EachPropCallback = (prop: string, obj: object) => Control | void\n\n/**\n * each properties\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties, default: true\n * @return stoped property name or false\n */\nexport function eachProps(obj: object, callback: EachPropCallback, own: boolean): false | string\nexport function eachProps(obj: object, callback: EachPropCallback, scope?: any, own?: boolean): false | string\nexport function eachProps(obj: object, callback: EachPropCallback, scope?: any, own?: boolean): false | string {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tlet k: string\n\tif (own === false) {\n\t\tfor (k in obj) if (callback(k, obj) === STOP) return k\n\t} else {\n\t\tfor (k in obj) if (hasOwnProp(obj, k) && callback(k, obj) === STOP) return k\n\t}\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      each object                                     *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on object\n * - will stop each on callback return STOP\n */\nexport type EachObjCallback = (value: any, prop: string, obj: object) => Control | void\n\n/**\n * each object\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties, default: true\n * @return stoped property name or false\n */\nexport function eachObj(obj: object, callback: EachObjCallback, own: boolean): false | string\nexport function eachObj(obj: object, callback: EachObjCallback, scope?: any, own?: boolean): false | string\nexport function eachObj(obj: object, callback: EachObjCallback, scope?: any, own?: boolean): false | string {\n\tconst args = arguments\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tlet k: string\n\tif (own === false) {\n\t\tfor (k in obj) if (callback(obj[k], k, obj) === STOP) return k\n\t} else {\n\t\tfor (k in obj) if (hasOwnProp(obj, k) && callback(obj[k], k, obj) === STOP) return k\n\t}\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      each array                                      *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on array\n * - will stop each on callback return STOP\n */\nexport type EachArrayCallback = (data: any, index: number, array: IArray) => Control | void\n\n/**\n * each array\n * - will stop each on callback return STOP\n * @param array\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @return stoped index or false\n */\nexport function eachArray(array: IArray, callback: EachArrayCallback, scope?: any): false | number {\n\tcallback = bind(callback, scope)\n\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\tif (callback(array[i], i, array) === STOP) return i\n\t}\n\treturn false\n}\n\n/**\n * reverse each array\n * - will stop each on callback return STOP\n * @param array\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @return stoped index or false\n */\nexport function reachArray(array: IArray, callback: EachArrayCallback, scope?: any): false | number {\n\tcallback = bind(callback, scope)\n\tlet i = array.length\n\twhile (i--) if (callback(array[i], i, array) === STOP) return i\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         each                                         *\n *                                                                                      */\n//========================================================================================\n\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: IArray,\n\tcallback: EachArrayCallback,\n\tscope?: any\n): false | number\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object,\n\tcallback: EachObjCallback,\n\town?: boolean\n): false | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object,\n\tcallback: EachObjCallback,\n\tscope?: any,\n\town?: boolean\n): false | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\town?: boolean\n): false | number | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\tscope?: any,\n\town?: boolean\n): false | number | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: any,\n\tcallback: any,\n\tscope?: any,\n\town?: boolean\n): false | number | string {\n\tif (isArrayLike(obj)) return _eachArray(obj, callback, scope)\n\treturn _eachObj(obj, callback, scope, own)\n}\n\n/**\n * each\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties on object, default: true\n * @return stoped index or false\n */\n\nexport function each(obj: IArray, callback: EachArrayCallback, scope?: any): false | number\nexport function each(obj: object, callback: EachObjCallback, own?: boolean): false | string\nexport function each(obj: object, callback: EachObjCallback, scope?: any, own?: boolean): false | string\nexport function each(\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\town?: boolean\n): false | number | string\nexport function each(\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\tscope?: any,\n\town?: boolean\n): false | number | string\nexport function each(obj: any, callback: any, scope?: any, own?: boolean): false | number | string {\n\treturn doEach(eachArray, eachObj, obj, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:54:35 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport create from '../create'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool } from '../is'\n\n/**\n * SKIP Control\n * > skip map\n */\nexport const SKIP = new Control('SKIP')\n\n//========================================================================================\n/*                                                                                      *\n *                                    map object                                   *\n *                                                                                      */\n//========================================================================================\n\n/**\n * callback on object\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param value\tproperty value\n * @param prop\tproperty name\n * @param obj\tmap target\n */\nexport type MapObjCallback<T> = (callback: any, prop: string, obj: object) => T | Control\n\nexport function doMapObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\town?: boolean\n): { [key: string]: T }\nexport function doMapObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T }\nexport function doMapObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tconst copy: { [key: string]: T } = create(null)\n\teach(\n\t\tobj,\n\t\t(value, prop, obj) => {\n\t\t\tconst v = callback(value, prop, obj)\n\t\t\tif (v === STOP) return STOP\n\t\t\tif (v !== SKIP) copy[prop] = v as T\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn copy\n}\n\n/**\n * object: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param obj\t\tmap target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\tmap own properties, default: true\n */\nexport function mapObj<T>(obj: object, callback: MapObjCallback<T>, own?: boolean): { [key: string]: T }\nexport function mapObj<T>(obj: object, callback: MapObjCallback<T>, scope?: any, own?: boolean): { [key: string]: T }\nexport function mapObj<T>(obj: object, callback: MapObjCallback<T>, scope?: any, own?: boolean): { [key: string]: T } {\n\treturn doMapObj(eachObj, obj, callback, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     indexof Array                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * callback on array\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param data\titem data\n * @param index\titem index\n * @param array\tmap target\n */\nexport type MapArrayCallback<T> = (data: any, index: number, array: IArray) => T | Control\n\nexport function doMapArray<T>(each: typeof eachArray, array: IArray, callback: MapArrayCallback<T>, scope?: any): T[] {\n\tcallback = bind(callback, scope)\n\tconst copy: T[] = []\n\tlet j = 0\n\teach(array, (data, index, array) => {\n\t\tconst v = callback(data, index, array)\n\t\tif (v === STOP) return STOP\n\t\tif (v !== SKIP) copy[j++] = v as T\n\t})\n\treturn copy\n}\n\n/**\n * array: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param array\t\tmap target\n * @param value\t\tcallback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function mapArray<T>(array: IArray, callback: MapArrayCallback<T>, scope?: any): T[] {\n\treturn doMapArray(eachArray, array, callback, scope)\n}\n\n/**\n * revice array: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param array\t\tmap target\n * @param value\t\tmap value of callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function rmapArray<T>(array: IArray, callback: MapArrayCallback<T>, scope?: any): T[] {\n\treturn doMapArray(reachArray, array, callback, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       map                                       *\n *                                                                                      */\n//========================================================================================\n\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray,\n\tcallback: MapArrayCallback<T>,\n\tscope?: any\n): any[]\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\town?: boolean\n): { [key: string]: T }\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T }\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: any,\n\tcallback: any,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | any[] {\n\tif (isArrayLike(obj)) return doMapArray(eacharray, obj, callback, scope)\n\treturn doMapObj(eachobj, obj, callback, scope, own)\n}\n\n/**\n * map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param obj\t\tmap target\n * @param value\t\tmap value of callback\n * @param scope\t\tscope of callback\n * @param own\t\tmap own properties on object, default: true\n * @return array index or property name or -1\n */\nexport function map<T>(obj: IArray, callback: MapArrayCallback<T>, scope?: any): any[]\nexport function map<T>(obj: object, callback: MapObjCallback<T>, own?: boolean): { [key: string]: T }\nexport function map<T>(obj: object, callback: MapObjCallback<T>, scope?: any, own?: boolean): { [key: string]: T }\nexport function map<T>(\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function map<T>(\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function map<T>(obj: object | IArray, callback: any, scope?: any, own?: boolean): { [key: string]: T } | T[] {\n\treturn doMap(eachArray, eachObj, obj, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:38:16 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool, isFn, eq } from '../is'\n\nfunction parseCallback(value: any, scope: any) {\n\tif (isFn(value)) return bind(value, scope)\n\treturn function defaultHandler(data, idx, obj) {\n\t\treturn eq(data, value)\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    index of object                                   *\n *                                                                                      */\n//========================================================================================\n\n/**\n * indexOf callback on object\n * - will stop find on callback return STOP\n * @param value\tproperty value\n * @param prop\tproperty name\n * @param obj\t\tindexOf target\n * @return\n * - boolean: is finded\n * - void: find next\n * - STOP: stop find\n */\nexport type IdxOfObjCallback = (value: any, prop: string, obj: object) => boolean | Control | void\n\nexport function doIdxOfObj(each: typeof eachObj, obj: object, value: any, own?: boolean): -1 | string\nexport function doIdxOfObj(each: typeof eachObj, obj: object, value: IdxOfObjCallback, own?: boolean): -1 | string\nexport function doIdxOfObj(\n\teach: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback,\n\tscope?: any,\n\town?: boolean\n): -1 | string\n\nexport function doIdxOfObj(\n\teach: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback | any,\n\tscope?: any,\n\town?: boolean\n): -1 | string {\n\tif (isBool(scope)) {\n\t\town = scope\n\t\tscope = null\n\t}\n\tconst callback: IdxOfObjCallback = parseCallback(value, scope)\n\tlet idx: -1 | string = -1\n\teach(\n\t\tobj,\n\t\t(data, prop, obj) => {\n\t\t\tconst r = callback(data, prop, obj)\n\t\t\tif (r === true) {\n\t\t\t\tidx = prop\n\t\t\t\treturn STOP\n\t\t\t} else if (r === STOP) return r\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn idx\n}\n\n/**\n * object: indexOf\n * - will stop find on callback return STOP\n * @param obj\t\tfind target\n * @param callback\tfind value or callback\n * @param scope\t\tscope of callback\n * @param own\t\tfind own properties, default: true\n * @return property name or -1\n */\nexport function idxOfObj(obj: object, value: any, own?: boolean): -1 | string\nexport function idxOfObj(obj: object, value: IdxOfObjCallback, own?: boolean): -1 | string\nexport function idxOfObj(obj: object, value: IdxOfObjCallback, scope?: any, own?: boolean): -1 | string\nexport function idxOfObj(obj: object, value: IdxOfObjCallback | any, scope?: any, own?: boolean): -1 | string {\n\treturn doIdxOfObj(eachObj, obj, value, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     indexof Array                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * indexOf callback on array\n * - will stop find on callback return STOP\n * @param data\titem data\n * @param index\titem index\n * @param array\tindexOf target\n * @return\n * - boolean: is finded\n * - void: find next\n * - STOP: stop find\n */\nexport type IdxOfArrayCallback = (data: any, index: number, array: IArray) => boolean | Control | void\n\nexport function doIdxOfArray(each: typeof eachArray, array: IArray, value: any): number\nexport function doIdxOfArray(each: typeof eachArray, array: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function doIdxOfArray(\n\teach: typeof eachArray,\n\tarray: IArray,\n\tvalue: IdxOfArrayCallback | any,\n\tscope?: any\n): number {\n\tconst callback: IdxOfArrayCallback = parseCallback(value, scope)\n\tlet idx = -1\n\teach(array, (data, index, array) => {\n\t\tconst r = callback(data, index, array)\n\t\tif (r === true) {\n\t\t\tidx = index\n\t\t\treturn STOP\n\t\t} else if (r === STOP) return r\n\t})\n\treturn idx\n}\n\n/**\n * array: indexOf\n * - will stop find on callback return STOP\n * @param array\t\tfind target\n * @param value\t\tfind value or callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function idxOfArray(array: IArray, value: any): number\nexport function idxOfArray(array: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function idxOfArray(array: IArray, value: IdxOfArrayCallback | any, scope?: any): number {\n\treturn doIdxOfArray(eachArray, array, value, scope)\n}\n\n/**\n * revice array: indexOf\n * - will stop find on callback return STOP\n * @param array\t\tfind target\n * @param value\t\tfind value of callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function ridxOfArray(array: IArray, value: any): number\nexport function ridxOfArray(array: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function ridxOfArray(array: IArray, value: IdxOfArrayCallback | any, scope?: any): number {\n\treturn doIdxOfArray(reachArray, array, value, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       index of                                       *\n *                                                                                      */\n//========================================================================================\n// find by value\nexport function doIdxOf(eacharray: typeof eachArray, eachobj: typeof eachObj, obj: IArray, value: any): number\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tvalue: any,\n\town?: boolean\n): string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tvalue: any,\n\town?: boolean\n): number | string\n// find by callback\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray,\n\tvalue: IdxOfArrayCallback,\n\tscope?: any\n): number\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback,\n\town?: boolean\n): -1 | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback,\n\tscope?: any,\n\town?: boolean\n): -1 | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\town?: boolean\n): number | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\tscope?: any,\n\town?: boolean\n): number | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: any,\n\tvalue: any,\n\tscope?: any,\n\town?: boolean\n): number | string {\n\tif (isArrayLike(obj)) return doIdxOfArray(eacharray, obj, value, scope)\n\treturn doIdxOfObj(eachobj, obj, value, scope, own)\n}\n\n/**\n * indexOf\n * - will stop find on callback return STOP\n * @param obj\t\tfind target\n * @param value\t\tfind value of callback\n * @param scope\t\tscope of callback\n * @param own\t\tfind own properties on object, default: true\n * @return array index or property name or -1\n */\nexport function idxOf(obj: IArray, value: any): number | string\nexport function idxOf(obj: object, value: any, own?: boolean): number | string\nexport function idxOf(obj: object | IArray, value: any, own?: boolean): number | string\nexport function idxOf(obj: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function idxOf(obj: object, value: IdxOfObjCallback, own?: boolean): -1 | string\nexport function idxOf(obj: object, value: IdxOfObjCallback, scope?: any, own?: boolean): -1 | string\nexport function idxOf(\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\town?: boolean\n): number | string\nexport function idxOf(\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\tscope?: any,\n\town?: boolean\n): number | string\nexport function idxOf(obj: object | IArray, value: any, scope?: any, own?: boolean): number | string {\n\treturn doIdxOf(eachArray, eachObj, obj, value, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 14:02:39 GMT+0800 (China Standard Time)\n */\nimport { Control } from './control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool } from '../is'\n\n//========================================================================================\n/*                                                                                      *\n *                                     reduce object                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * reduce callback on object\n * - will stop reduce on return STOP\n */\nexport type ReduceObjCallback<T> = (accumulator: T, value: any, prop: string, obj: object) => T | Control\n\nexport function doReduceObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\town?: boolean\n): T\nexport function doReduceObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduceObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\teach(\n\t\tobj,\n\t\t(value, prop, obj) => {\n\t\t\tconst rs = callback(accumulator, value, prop, obj)\n\t\t\tif (rs === STOP) return STOP\n\t\t\taccumulator = rs as T\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn accumulator\n}\n\n/**\n * reduce object\n * - will stop reduce on callback return STOP\n * @param obj\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n * @param own\t\t\treduce own properties, default: true\n */\nexport function reduceObj<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, own?: boolean)\nexport function reduceObj<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, scope?: any, own?: boolean)\nexport function reduceObj<T>(\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\treturn doReduceObj(eachObj, obj, accumulator, callback, scope, own)\n}\n//========================================================================================\n/*                                                                                      *\n *                                     reduce array                                     *\n *                                                                                      */\n//========================================================================================\n\n/**\n * reduce callback on array\n * - will stop reduce on return STOP\n */\nexport type ReduceArrayCallback<T> = (accumulator: T, data: any, index: number, array: IArray) => T | Control\n\nexport function doReduceArray<T>(\n\teach: typeof eachArray,\n\tarray: IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T>,\n\tscope?: any\n): T {\n\tcallback = bind(callback, scope)\n\teach(array, (data, index, array) => {\n\t\tconst rs = callback(accumulator, data, index, array)\n\t\tif (rs === STOP) return STOP\n\t\taccumulator = rs as T\n\t})\n\treturn accumulator\n}\n\n/**\n * reduce array\n * - will stop reduce on callback return STOP\n * @param array\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n */\nexport function reduceArray<T>(array: IArray, accumulator: T, callback: ReduceArrayCallback<T>, scope?: any): T {\n\treturn doReduceArray(eachArray, array, accumulator, callback, scope)\n}\n\n/**\n * revice reduce array\n * - will stop reduce on callback return STOP\n * @param array\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n */\nexport function rreduceArray<T>(array: IArray, accumulator: T, callback: ReduceArrayCallback<T>, scope?: any): T {\n\treturn doReduceArray(reachArray, array, accumulator, callback, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        reduce                                        *\n *                                                                                      */\n//========================================================================================\n\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T>,\n\tscope?: any\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T> | ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\tif (isArrayLike(obj))\n\t\treturn doReduceArray(eacharray, obj as IArray, accumulator, callback as ReduceArrayCallback<T>, scope)\n\treturn doReduceObj(eachobj, obj as object, accumulator, callback as ReduceObjCallback<T>, scope, own)\n}\n\n/**\n * reduce\n * - will stop reduce on callback return STOP\n * @param obj\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n * @param own\t\t\treduce own properties of reduce object, default: true\n */\nexport function reduce<T>(obj: IArray, accumulator: T, callback: ReduceArrayCallback<T>, scope?: any): T\nexport function reduce<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, own?: boolean): T\nexport function reduce<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, scope?: any, own?: boolean): T\nexport function reduce<T>(\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\town?: boolean\n): T\nexport function reduce<T>(\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function reduce<T>(\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T> | ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\treturn doReduce(eachArray, eachObj, obj, accumulator, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Jul 26 2018 10:47:47 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:59:31 GMT+0800 (China Standard Time)\n */\nimport { Control } from './control'\nimport { STOP, eachObj, eachProps } from './each'\nimport { SKIP } from './map'\nimport { isBool, isFn } from '../is'\nimport { bind } from '../fn'\n\n//========================================================================================\n/*                                                                                      *\n *                                         keys                                         *\n *                                                                                      */\n//========================================================================================\n\nexport type ObjKeyHandler<T> = (prop: string, obj: object) => T | Control\n\nfunction defaultObjKeyHandler(prop: string, obj: object): any {\n\treturn prop\n}\nexport function doObjKeys<T>(each: typeof eachProps, obj: object, own?: boolean): T[]\nexport function doObjKeys<T>(each: typeof eachProps, obj: object, callback: ObjKeyHandler<T>, own?: boolean): T[]\nexport function doObjKeys<T>(\n\teach: typeof eachProps,\n\tobj: object,\n\tcallback: ObjKeyHandler<T>,\n\tscope?: any,\n\town?: boolean\n): T[]\nexport function doObjKeys<T>(\n\teach: typeof eachProps,\n\tobj: object,\n\tcallback_own?: ObjKeyHandler<T> | boolean,\n\tscope_own?: any,\n\town?: boolean\n): T[]\nexport function doObjKeys<T>(each: typeof eachProps, obj: object): T[] {\n\tconst rs: T[] = [],\n\t\targs = arguments\n\tlet handler: ObjKeyHandler<T> = defaultObjKeyHandler,\n\t\ti = 2,\n\t\tj = 0\n\tif (isFn(args[i])) {\n\t\thandler = args[i++]\n\t\tif (!isBool(args[i])) handler = bind(handler, args[i++])\n\t}\n\teach(\n\t\tobj,\n\t\t(prop, obj) => {\n\t\t\tconst val = handler(prop, obj)\n\t\t\tif (val === STOP) return STOP\n\t\t\tif (val !== SKIP) rs[j++] = val as T\n\t\t},\n\t\tnull,\n\t\targs[i]\n\t)\n\treturn rs\n}\n\n/**\n * @param obj\t\ttarget\n * @param handler\tkey handler\n * @param scope\t\tscope or handler\n * @param own\t\tis get own properties, default: true\n */\nexport function keys<T>(obj: object, own?: boolean): T[]\nexport function keys<T>(obj: object, callback: ObjKeyHandler<T>, own?: boolean): T[]\nexport function keys<T>(obj: object, callback: ObjKeyHandler<T>, scope?: any, own?: boolean): T[]\nexport function keys<T>(obj: object, callback?: ObjKeyHandler<T> | boolean, scope?: any, own?: boolean): T[] {\n\treturn doObjKeys(eachProps, obj, callback, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        values                                        *\n *                                                                                      */\n//========================================================================================\n\nexport type ObjValueHandler<T> = (value: any, prop: string, obj: object) => T | Control\n\nfunction defaultObjValueHandler(value: any, prop: string, obj: object): any {\n\treturn value\n}\nexport function doObjValues<T>(each: typeof eachObj, obj: object, own?: boolean): T[]\nexport function doObjValues<T>(each: typeof eachObj, obj: object, callback: ObjValueHandler<T>, own?: boolean): T[]\nexport function doObjValues<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: ObjValueHandler<T>,\n\tscope?: any,\n\town?: boolean\n): T[]\nexport function doObjValues<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback_own?: ObjValueHandler<T> | boolean,\n\tscope_own?: any,\n\town?: boolean\n): T[]\nexport function doObjValues<T>(each: typeof eachObj, obj: object): T[] {\n\tconst rs: T[] = [],\n\t\targs = arguments\n\tlet handler: ObjValueHandler<T> = defaultObjValueHandler,\n\t\ti = 1,\n\t\tj = 0\n\tif (isFn(args[i])) {\n\t\thandler = args[i++]\n\t\tif (!isBool(args[i])) handler = bind(handler, args[i++])\n\t}\n\teach(\n\t\tobj,\n\t\tfunction(data, prop, obj) {\n\t\t\tconst val = handler(data, prop, obj)\n\t\t\tif (val === STOP) return STOP\n\t\t\tif (val !== SKIP) rs[j++] = val as T\n\t\t},\n\t\tnull,\n\t\targs[i]\n\t)\n\treturn rs\n}\n\n/**\n * @param obj\t\ttarget\n * @param handler\tvalue handler\n * @param scope\t\tscope or handler\n * @param own\t\tis get own properties, default: true\n */\nexport function values<T>(obj: object, own?: boolean): T[]\nexport function values<T>(obj: object, callback: ObjValueHandler<T>, own?: boolean): T[]\nexport function values<T>(obj: object, callback: ObjValueHandler<T>, scope?: any, own?: boolean): T[]\nexport function values<T>(obj: object, callback?: ObjValueHandler<T> | boolean, scope?: any, own?: boolean): T[] {\n\treturn doObjValues(eachObj, obj, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Fri Nov 16 2018 16:29:04 GMT+0800 (China Standard Time)\n * @modified Fri Nov 30 2018 17:42:28 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './control'\nimport { eachArray } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isFn, isStr, isArray } from '../is'\nimport create from '../create'\n\n/**\n * @return STOP or SKIP or [key: string, value: any]\n */\nexport type Arr2ObjCallback = (data: any, index: number, array: IArray) => Control | [string, any]\n\nexport function doArr2Obj(each: typeof eachArray, array: IArray, callback: Arr2ObjCallback, scope?: any): object {\n\tconst obj = create(null)\n\tcallback = bind(callback, scope)\n\teach(array, (data, index, array) => {\n\t\tconst r: Control | [string, any] = callback(data, index, array)\n\t\tif (isArray(r)) {\n\t\t\tobj[r[0]] = r[1]\n\t\t} else {\n\t\t\treturn r as Control\n\t\t}\n\t})\n\treturn obj\n}\n\n/**\n * convert array to object\n */\nexport function arr2obj(array: IArray, callback: Arr2ObjCallback, scope?: any): object {\n\treturn doArr2Obj(eachArray, array, callback, scope)\n}\n\n/**\n * convert array or string to object\n * @param array\n * @param val\tvalue or callback\n * @param split\tsplit char on string\n */\nexport function makeMap(array: IArray, val: Arr2ObjCallback, split?: string): object\nexport function makeMap(array: IArray, val?: any, split?: string): object\nexport function makeMap(array: IArray, val?: any, split?: string): object {\n\tif (isStr(array)) array = (array as string).split(isStr(split) ? split : ',')\n\treturn arr2obj(array, isFn(val) ? val : data => [data, val])\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Nov 15 2018 12:13:54 GMT+0800 (China Standard Time)\n * @modified Tue Dec 04 2018 20:10:32 GMT+0800 (China Standard Time)\n */\n\nexport { STOP, eachProps, eachArray, eachObj, each } from './each'\nexport { SKIP, mapArray, mapObj, map } from './map'\nexport { idxOfArray, idxOfObj, idxOf } from './idxOf'\nexport { reduceArray, reduceObj, reduce } from './reduce'\nexport { keys, values } from './obj2arr'\nexport { arr2obj, makeMap } from './arr2obj'\nexport function makeArray<T>(len: number, callback: (index: number) => T): T[] {\n\tconst array = new Array(len)\n\tlet i = len\n\twhile (i--) array[i] = callback(i)\n\treturn array\n}\n","import create from './create'\nimport { isArray } from './is'\nimport { mapArray } from './collection'\n\nconst pathCache: { [key: string]: string[] } = create(null)\n\n// prop | [index | \"string prop\" | 'string prop']\nconst pathReg = /(?:^|\\.)([a-zA-Z$_][\\w$]*)|\\[\\s*(?:(\\d+)|\"((?:[^\\\\\"]|\\\\.)*)\"|'((?:[^\\\\']|\\\\.)*)')\\s*\\]/g\n\nexport function parsePath(path: string | string[], cacheable?: boolean): string[]\nexport function parsePath(path, cacheable) {\n\tif (isArray(path)) return path\n\n\tlet array = pathCache[path]\n\tif (!array) {\n\t\tarray = []\n\t\tvar match,\n\t\t\tidx = 0,\n\t\t\tcidx,\n\t\t\ti = 0\n\t\twhile ((match = pathReg.exec(path))) {\n\t\t\tcidx = pathReg.lastIndex\n\t\t\tif (cidx !== idx + match[0].length) {\n\t\t\t\tthrow new SyntaxError(`Invalid Path: \"${path}\", unkown character[${path.charAt(idx)}] at offset:${idx}`)\n\t\t\t}\n\t\t\tarray[i++] = match[1] || match[2] || match[3] || match[4]\n\t\t\tidx = cidx\n\t\t}\n\t\tif (cacheable === false) return array\n\t\tpathCache[path] = array\n\t}\n\treturn array.slice()\n}\n\nexport function formatPath(path: string | string[]): string {\n\treturn isArray(path) ? mapArray(path, formatPathHandler).join('') : (path as string)\n}\n\nfunction formatPathHandler(prop: string): string {\n\treturn `[\"${String(prop).replace(\"'\", '\\\\\"')}\"]`\n}\n\nexport function get(obj, path) {\n\tpath = parsePath(path)\n\tconst l = path.length - 1\n\tif (l === -1) return obj\n\tlet i = 0\n\tfor (; i < l; i++) {\n\t\tobj = obj[path[i]]\n\t\tif (obj === null || obj === undefined) return undefined\n\t}\n\treturn obj ? obj[path[i]] : undefined\n}\n\nexport function set(obj, path, value) {\n\tpath = parsePath(path)\n\tconst l = path.length - 1\n\tif (l === -1) return\n\tlet attr,\n\t\tv,\n\t\ti = 0\n\tfor (; i < l; i++) {\n\t\tattr = path[i]\n\t\tv = obj[attr]\n\t\tif (!v) obj[attr] = v = {}\n\t\tobj = v\n\t}\n\tattr = path[i]\n\tobj[attr] = value\n}\n","/**\n * String utilities\n * @module utility/string\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Thu Dec 06 2018 18:45:25 GMT+0800 (China Standard Time)\n */\nimport { createFn } from './fn'\nimport { isNil, isFn, isNum } from './is'\nimport { get } from './propPath'\nimport create from './create'\n\n//========================================================================================\n/*                                                                                      *\n *                                       char code                                      *\n *                                                                                      */\n//========================================================================================\n\n/**\n * get char code\n * > string.charCodeAt\n */\nexport function charCode(str: string, index?: number): number {\n\treturn str.charCodeAt(index || 0)\n}\n\n/**\n * get char by char code\n * > String.fromCharCode\n */\nexport function char(code: number): string {\n\treturn String.fromCharCode(code)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         trim                                         *\n *                                                                                      */\n//========================================================================================\n\nconst TRIM_REG = /(^\\s+)|(\\s+$)/g\n\n/**\n * trim\n */\nexport function trim(str: string): string {\n\treturn str.replace(TRIM_REG, '')\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         case                                         *\n *                                                                                      */\n//========================================================================================\n\nconst FIRST_LOWER_LETTER_REG = /^[a-z]/\n\n/**\n * upper first char\n */\nexport function upperFirst(str: string): string {\n\treturn str.replace(FIRST_LOWER_LETTER_REG, upperHandler)\n}\n\nfunction upperHandler(m) {\n\treturn m.toUpperCase()\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                  parse string value                                  *\n *                                                                                      */\n//========================================================================================\n\n/**\n * convert any value to string\n * - undefined | null: ''\n * - NaN:\n * - Infinity:\n * - other: String(value)\n * TODO support NaN, Infinity\n */\nexport function strval(obj: any): string {\n\treturn isNil(obj) ? '' : String(obj)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        escape                                        *\n *                                                                                      */\n//========================================================================================\n\nconst STR_ESCAPE_MAP = {\n\t\t'\\n': '\\\\n',\n\t\t'\\t': '\\\\t',\n\t\t'\\f': '\\\\f',\n\t\t'\"': '\\\\\"',\n\t\t\"'\": \"\\\\'\"\n\t},\n\tSTR_ESCAPE = /[\\n\\t\\f\"']/g\n\nexport function escapeString(str: string): string {\n\treturn str.replace(STR_ESCAPE, str => STR_ESCAPE_MAP[str])\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                          pad                                         *\n *                                                                                      */\n//========================================================================================\n\nexport function pad(str: any, len: number, chr?: string, leftAlign?: boolean | number): string {\n\tstr = String(str)\n\tconst l = str.length\n\tif (l >= len) return str\n\n\tconst padding = new Array(len - l + 1).join(chr || ' ')\n\treturn leftAlign ? str + padding : padding + str\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                   plural & singular                                  *\n *                                                                                      */\n//========================================================================================\n\nfunction replacor(regs: ([RegExp, string])[]): (str: string) => string {\n\treturn function(str: string): string {\n\t\tfor (let i = 0, reg; i < 4; i++) {\n\t\t\treg = regs[i]\n\t\t\tif (reg[0].test(str)) return str.replace(reg[0], reg[1])\n\t\t}\n\t\treturn str\n\t}\n}\n\nexport const plural: (str: string) => string = replacor([\n\t[/([a-zA-Z]+[^aeiou])y$/, '$1ies'],\n\t[/([a-zA-Z]+[aeiou]y)$/, '$1s'],\n\t[/([a-zA-Z]+[sxzh])$/, '$1es'],\n\t[/([a-zA-Z]+[^sxzhy])$/, '$1s']\n])\n\nexport const singular: (str: string) => string = replacor([\n\t[/([a-zA-Z]+[^aeiou])ies$/, '$1y'],\n\t[/([a-zA-Z]+[aeiou])s$/, '$1'],\n\t[/([a-zA-Z]+[sxzh])es$/, '$1'],\n\t[/([a-zA-Z]+[^sxzhy])s$/, '$1']\n])\n\n//========================================================================================\n/*                                                                                      *\n *                                   thousand separate                                  *\n *                                                                                      */\n//========================================================================================\n\nexport const thousandSeparationReg = /(\\d)(?=(\\d{3})+(?!\\d))/g\nexport function thousandSeparate(number: number): string {\n\tconst split = String(number).split('.')\n\tsplit[0] = split[0].replace(thousandSeparationReg, '$1,')\n\treturn split.join('.')\n}\n","/**\n * @module utility/format\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 03 2018 19:46:41 GMT+0800 (China Standard Time)\n * @modified Thu Dec 06 2018 20:10:18 GMT+0800 (China Standard Time)\n */\n\nimport { createFn } from './fn'\nimport { isFn } from './is'\nimport { get, parsePath } from './propPath'\nimport create from './create'\nimport { pad, thousandSeparationReg, charCode } from './string'\n\n//========================================================================================\n/*                                                                                      *\n *                                      format Rule                                     *\n *                                                                                      */\n//========================================================================================\n\n//   0      1      2     3     4       5       6           7         8      9           10             11             12      13\n// [match, expr, index, prop, flags, width, width-idx, width-prop, fill, precision, precision-idx, precision-prop, cut-fill, type]\nconst paramIdxR = `(\\\\d+|\\\\$|@)`,\n\tparamPropR = `(?:\\\\{((?:[a-zA-Z$_][\\\\w$_]*|\\\\[(?:\\\\d+|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)*\"|'(?:[^\\\\\\\\']|\\\\\\\\.)*')\\\\])(?:\\\\.[a-zA-Z$_][\\\\w$_]*|\\\\[(?:\\\\d+|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)*\"|'(?:[^\\\\\\\\']|\\\\\\\\.)*')\\\\])*)\\\\})`,\n\twidthR = `(?:([1-9]\\\\d*)|&${paramIdxR}${paramPropR})`,\n\tfillR = `(?:=(.))`,\n\tcutSuffixR = `(?:=\"((?:[^\\\\\\\\\"]|\\\\\\\\.)*)\")`,\n\tformatReg = new RegExp(\n\t\t`\\\\\\\\.|(\\\\{${paramIdxR}?${paramPropR}?(?::([#,+\\\\- 0]*)(?:${widthR}${fillR}?)?(?:\\\\.${widthR}${cutSuffixR}?)?)?(?::?([a-zA-Z_][a-zA-Z0-9_$]*))?\\\\})`,\n\t\t'g'\n\t)\n\n//========================================================================================\n/*                                                                                      *\n *                                     format flags                                     *\n *                                                                                      */\n//========================================================================================\n\ntype FormatFlags = number\n\nexport const FORMAT_XPREFIX: FormatFlags = 0x1\nexport const FORMAT_PLUS: FormatFlags = 0x1\nexport const FORMAT_ZERO: FormatFlags = 0x2\nexport const FORMAT_SPACE: FormatFlags = 0x4\nexport const FORMAT_THOUSAND: FormatFlags = 0x8\nexport const FORMAT_LEFT: FormatFlags = 0x16\n\n// flags parser \n\nconst FLAG_MAPPING = {\n\t'#': FORMAT_XPREFIX,\n\t'+': FORMAT_PLUS,\n\t'0': FORMAT_ZERO,\n\t' ': FORMAT_SPACE,\n\t',': FORMAT_THOUSAND,\n\t'-': FORMAT_LEFT\n}\nfunction parseFlags(f: string): FormatFlags {\n\tlet flags: FormatFlags = 0\n\tif (f) {\n\t\tvar i = f.length\n\t\twhile (i--) flags |= FLAG_MAPPING[f.charAt(i)]\n\t}\n\treturn flags\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      Formatters                                      *\n *                                                                                      */\n//========================================================================================\n\ntype FormatCallback = (\n\tval: any,\n\tflags: FormatFlags,\n\twidth: number,\n\tprecision: number | undefined,\n\tcutSuffix: string\n) => string\n\ntype Formatter = {\n\tget: (obj: any, path: string[]) => any\n\tfmt: FormatCallback\n}\n\nconst formatters: {\n\t[k: string]: Formatter\n} = create(null)\n\nexport function extendFormatter(obj: { [key: string]: Formatter | FormatCallback }) {\n\tvar fmt, name\n\tfor (name in obj) {\n\t\tfmt = obj[name]\n\t\tif (isFn(fmt)) {\n\t\t\tformatters[name] = { fmt, get }\n\t\t} else if (isFn(fmt.fmt)) {\n\t\t\tformatters[name] = fmt\n\t\t}\n\t}\n}\n\nfunction getFormatter(name: string): Formatter {\n\tconst f = formatters[name || 's']\n\tif (f) return f\n\tthrow new Error(`Invalid Formatter: ${name}`)\n}\n\nfunction __doFormat(\n\tformatter: Formatter,\n\tval: any,\n\tflags: FormatFlags,\n\twidth: number,\n\tfill: string,\n\tprecision: number | undefined,\n\tcutSuffix: string\n): string {\n\tlet str = formatter.fmt(val, flags, width, precision, cutSuffix)\n\tif (width > str.length) str = pad(str, width, fill, flags & FORMAT_LEFT)\n\treturn str\n}\n\n//========================================================================================\n/*                                                                                      *\n *                           format by every parameter object                           *\n *                                                                                      */\n//========================================================================================\n\n/**\n * Syntax:\n * \t\t\t'{' (<parameter>)? ('!' <property>)? (':' (<flags>)? (<width>)? ('!' <property>)? ('=' <fill-char>)? ('.' <precision>  ('!' <property>)? )? )? (':'? <data-type>)? '}'\n * - parameter\n * \t\t- parameter index\n * \t\t\t{}\t\t\t\t\t\tformat by next unused argument\n * \t\t\t{<number>}\t\t\t\tformat by arguments[number]\n * \t\t\t{@}\t\t\t\t\t\tformat by current used argument\n * \t\t\t{$}\t\t\t\t\t\tformat by next unused argument\n * \t\t- property\n * \t\t\t{.<path>}\t\t\t\tget value on parameter by property path\n * \t\t\t\t\t\t\t\t\tSyntax: '.' (<propName> | '[' (<number> | <string>) ']') ('.' <propName> | '[' (<number> | <string>) ']')*\n * \t\t\t\t\t\t\t\t\teg. .abc.abc | .[\"abc\"]['abc'] | .abc[0] | .[0].abc\n * - flags\n * \t\tspace   prefix non-negative number with a space\n * \t\t+       prefix non-negative number with a plus sign\n * \t\t-       left-justify within the field\n * \t\t,\t\tthousand separation number\n * \t\t#       ensure the leading \"0\" for any octal\n * \t\t\t\tprefix non-zero hexadecimal with \"0x\" or \"0X\"\n * \t\t\t\tprefix non-zero binary with \"0b\" or \"0B\"\n * @example\n * \t\tformat('<{: d}>',  12);\t\t// return \"< 12>\"\n *\t\tformat('<{: d}>',   0);\t\t// return \"< 0>\"\n *\t\tformat('<{: d}>', -12);\t\t// return \"<-12>\"\n *\t\tformat('<{:+d}>',  12);\t\t// return \"<+12>\"\n *\t\tformat('<{:+d}>',   0);\t\t// return \"<+0>\"\n *\t\tformat('<{:+d}>', -12);\t\t// return \"<-12>\"\n *\t\tformat('<{:6s}>',  12);\t\t// return \"<    12>\"\n *\t\tformat('<{:-6s}>', 12);\t\t// return \"<12    >\"\n *\t\tformat('<{:#o}>',  12);\t\t// return \"<014>\"\n *\t\tformat('<{:#x}>',  12);\t\t// return \"<0xc>\"\n *\t\tformat('<{:#X}>',  12);\t\t// return \"<0XC>\"\n *\t\tformat('<{:#b}>',  12);\t\t// return \"<0b1100>\"\n *\t\tformat('<{:#B}>',  12);\t\t// return \"<0B1100>\"\n * - width\n * \t\t\t(<width>)? ('=' <fill-char>)? ('.' <precision>)?\n * \t\t- min width\n * \t\t- precision width\n * - data-type\n * - Rules\n * \t\t- property-path\n * \t\t\t\t(\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t[a-zA-Z$_][\\w$_]*|\n * \t\t\t\t\t\t\\[\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\\d+|\n * \t\t\t\t\t\t\t\"(?:[^\\\\\"]|\\\\.)*\"|\n * \t\t\t\t\t\t\t'(?:[^\\\\']|\\\\.)*'\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t\\]\n * \t\t\t\t\t)\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t\\.[a-zA-Z$_][\\w$_]*|\n * \t\t\t\t\t\t\\[\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\\d+|\n * \t\t\t\t\t\t\t\"(?:[^\\\\\"]|\\\\.)*\"|\n * \t\t\t\t\t\t\t'(?:[^\\\\']|\\\\.)*'\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t\\]\n * \t\t\t\t\t)*\n * \t\t\t\t)\n * \t\t- expression\n * \t\t\t/[^\\\\{]+|\t\t\t\t\t\t\t\t\t\t\t// escape\n * \t\t\t\\\\.|\t\t\t\t\t\t\t\t\t\t\t\t// escape\n * \t\t\t(\t\t\t\t\t\t\t\t\t\t\t\t\t// 1: expression\n * \t\t\t\t\\{\n * \t\t\t\t(\\d+|\\$|@)?\t\t\t\t\t\t\t\t\t\t// 2: parameter index\n * \t\t\t\t(?:!<property-path> )?\t\t\t\t\t\t\t// 3: property path of parameter\n * \t\t\t\t(?:\n * \t\t\t\t\t:\n * \t\t\t\t\t([#,+\\- ]*)\t\t\t\t\t\t\t\t\t// 4: flags\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t(\\d+)|\t\t\t\t\t\t\t\t// 5: width\n * \t\t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\t&\n * \t\t\t\t\t\t\t\t(\\d+|\\$|@)\t\t\t\t\t\t// 6: parameter index of width\n * \t\t\t\t\t\t\t\t(?:!<property-path>)?\t\t\t// 7: property path of width parameter\n * \t\t\t\t\t\t\t)\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t(?:=(.))?\t\t\t\t\t\t\t\t// 8: pad fill\n * \t\t\t\t\t)?\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t\\.\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t(\\d+)|\t\t\t\t\t\t\t\t// 9: width\n * \t\t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\t&\n * \t\t\t\t\t\t\t\t(\\d+|\\$|@)\t\t\t\t\t\t// 10: parameter index of width\n * \t\t\t\t\t\t\t\t(?:!<property-path>)?\t\t\t// 11: property path of width parameter\n * \t\t\t\t\t\t\t)\n * \t\t\t\t\t\t)\n * \t\t\t\t\t)?\n * \t\t\t\t)?\n * \t\t\t\t(?:\n * \t\t\t\t\t:?\n * \t\t\t\t\t([a-zA-Z_][a-zA-Z0-9_$]*))?\t\t\t\t\t// 12: data type\n * \t\t\t\t\\}\n * \t\t\t)/\n */\nexport function vformat<T>(fmt: string, args: T, offset?: number, getParam?: (args: T, idx: number) => any) {\n\toffset = offset || 0\n\tconst state: [number, number] = [offset, offset]\n\tgetParam = getParam || defaultGetParam\n\treturn fmt.replace(formatReg, function(\n\t\ts,\n\t\tm,\n\t\tparam,\n\t\tparamProp,\n\t\tflags,\n\t\twidth,\n\t\twidx,\n\t\twprop,\n\t\tfill,\n\t\tprecision,\n\t\tpidx,\n\t\tpprop,\n\t\tcutSuffix,\n\t\ttype\n\t) {\n\t\tif (!m) return s.charAt(1)\n\n\t\tconst formatter = getFormatter(type)\n\n\t\treturn __doFormat(\n\t\t\tformatter,\n\t\t\tparseParam(param || '$', paramProp, state, args, getParam),\n\t\t\tparseFlags(flags),\n\t\t\tparseWidth(width, widx, wprop, state, args, getParam) || 0,\n\t\t\tfill || ' ',\n\t\t\tparseWidth(precision, pidx, pprop, state, args, getParam),\n\t\t\tcutSuffix || ''\n\t\t)\n\t})\n}\n\nfunction parseWidth<T>(\n\twidth: string,\n\tidx: string | undefined,\n\tprop: string | undefined,\n\tstate: [number, number],\n\targs: T,\n\tgetParam: (args: T, idx: number) => any\n): number | undefined {\n\tif (width) return (width as any) >> 0\n\tif (idx) {\n\t\tconst w = parseParam(idx, prop, state, args, getParam) >> 0\n\t\tif (isFinite(w)) return w\n\t}\n}\n\nfunction parseParam<T>(\n\tparamIdx: string,\n\tprop: string | undefined,\n\tstate: [number, number],\n\targs: T,\n\tgetParam: (args: T, idx: number) => any\n): any {\n\tlet param = getParam(\n\t\targs,\n\t\tparamIdx === '$'\n\t\t\t? state[0]++\n\t\t\t: paramIdx === '@'\n\t\t\t? state[0] === state[1]\n\t\t\t\t? state[0]\n\t\t\t\t: state[0] - 1\n\t\t\t: (paramIdx as any) >> 0\n\t)\n\tif (prop) param = get(param, prop)\n\treturn param\n}\n\nfunction defaultGetParam(args: any, idx: number) {\n\treturn args[idx]\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        format                                        *\n *                                                                                      */\n//========================================================================================\n\nfunction getFormatParam(args: IArguments, idx: number) {\n\treturn args[idx + 1]\n}\n\n/**\n * @see vformat\n */\nexport function format(fmt: string, ...args: any): string\nexport function format(fmt: string): string {\n\treturn vformat(fmt, arguments, 0, getFormatParam)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       formatter                                      *\n *                                                                                      */\n//========================================================================================\n\nconst PROP1_VAR = 'p1',\n\tPROP2_VAR = 'p2',\n\tPROP3_VAR = 'p3',\n\tGET_PARAM_VAR = 'getp',\n\tGET_PROP_VAR = 'get',\n\tSTATE_VAR = 'state'\nfunction createFormatter(m: string[], getParam?: (args: IArguments, idx: number) => any) {\n\tconst formatter = getFormatter(m[13])\n\n\tconst p1 = m[3] && parsePath(m[3]),\n\t\tp2 = m[7] && parsePath(m[7]),\n\t\tp3 = m[11] && parsePath(m[11])\n\n\treturn createFn(\n\t\t`return function(args, ${STATE_VAR}){\n\treturn dofmt(fmt,\n\t\t${getParamCode(m[2] || '$', p1 && PROP1_VAR)},\n\t\tg,\n\t\t${getWidthCode(m[5], m[6], p2 && PROP2_VAR, '0')},\n\t\tf,\n\t\t${getWidthCode(m[9], m[10], p3 && PROP3_VAR, 'void 0')},\n\t\tcf);\n}`,\n\t\t['dofmt', 'fmt', 'g', 'f', 'cf', GET_PROP_VAR, GET_PARAM_VAR, PROP1_VAR, PROP2_VAR, PROP3_VAR]\n\t)(__doFormat, formatter, parseFlags(m[4]), m[8] || ' ', m[12] || '', get, getParam, p1, p2, p3)\n}\n\nfunction getWidthCode(width: string, idx: string, prop: string, def: string): string {\n\treturn width ? width : idx ? getParamCode(idx, prop) : def\n}\n\nfunction getParamCode(idx: string, prop: string): string {\n\tlet code = `${GET_PARAM_VAR}(args, ${\n\t\tidx === '$'\n\t\t\t? `${STATE_VAR}[0]++`\n\t\t\t: idx === '@'\n\t\t\t? `${STATE_VAR}[0] === ${STATE_VAR}[1] ? ${STATE_VAR}[0] : ${STATE_VAR}[0] - 1`\n\t\t\t: idx\n\t})`\n\tif (prop) return `${GET_PROP_VAR}(${code}, ${prop})`\n\treturn code\n}\n\nexport function formatter(\n\tfmt: string,\n\toffset?: number,\n\tgetParam?: (args: IArguments, idx: number) => any\n): (...args: any[]) => string {\n\tlet m,\n\t\tlastIdx = 0,\n\t\tmStart,\n\t\tmEnd,\n\t\tarr = [],\n\t\tcodes = [],\n\t\ti = 0\n\toffset = offset || 0\n\twhile ((m = formatReg.exec(fmt))) {\n\t\tmEnd = formatReg.lastIndex\n\t\tmStart = mEnd - m[0].length\n\t\tlastIdx < mStart && pushStr(fmt.substring(lastIdx, mStart), 0)\n\t\tif (m[1]) {\n\t\t\tcodes[i] = `arr[${i}](arguments, ${STATE_VAR})`\n\t\t\tarr[i++] = createFormatter(m, getParam || defaultGetParam)\n\t\t} else {\n\t\t\tpushStr(m[0].charAt(1), i)\n\t\t}\n\t\tlastIdx = mEnd\n\t}\n\tlastIdx < fmt.length && pushStr(fmt.substring(lastIdx), i)\n\treturn createFn(`return function(){var ${STATE_VAR} = [${offset}, ${offset}]; return ${codes.join(' + ')}}`, [\n\t\t'arr'\n\t])(arr)\n\n\tfunction pushStr(str, append) {\n\t\tif (append && arr[i - 1].length) {\n\t\t\tarr[i - 1] += str\n\t\t} else {\n\t\t\tcodes[i] = `arr[${i}]`\n\t\t\tarr[i++] = str\n\t\t}\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                  default formatters                                  *\n *                                                                                      */\n//========================================================================================\n\nconst TOEXPONENTIAL = 'toExponential',\n\tTOPRECISION = 'toPrecision',\n\tTOFIXED = 'toFixed'\n\nfunction floatFormatter(\n\ttype: string\n): (val: any, flags: FormatFlags, width: number, precision: number | undefined, cutSuffix: string) => string {\n\tconst toStr =\n\t\t\ttype === 'e' || type === 'E'\n\t\t\t\t? (num, precision) => num[TOEXPONENTIAL](precision)\n\t\t\t\t: type === 'f'\n\t\t\t\t? (num, precision) => precision >= 0 && num[TOFIXED](precision)\n\t\t\t\t: (num, precision) => precision && num[TOPRECISION](precision),\n\t\tupper = charCode(type) < 97\n\n\treturn function(val, flags, width, precision) {\n\t\tlet num = parseFloat(val)\n\t\tif (!isFinite(num)) return String(num)\n\n\t\tlet str = toStr(num, precision) || String(num)\n\n\t\tif (flags & FORMAT_THOUSAND) {\n\t\t\tvar split = str.split('.')\n\t\t\tsplit[0] = split[0].replace(thousandSeparationReg, '$1,')\n\t\t\tstr = split.join('.')\n\t\t}\n\t\tstr = prefixNum(num, str, flags, width)\n\t\treturn upper ? str.toUpperCase() : str\n\t}\n}\n\nconst BaseRadixs = {\n\tb: 2,\n\tB: 2,\n\to: 8,\n\tu: 10,\n\tx: 16,\n\tX: 16\n}\nconst BasePrefixs = ['0b', '0', '0x']\nfunction baseFormatter(\n\ttype: string\n): (val: any, flags: FormatFlags, width: number, precision: number | undefined, cutSuffix: string) => string {\n\tconst base = BaseRadixs[type],\n\t\txprefix = base != 10 ? BasePrefixs[base >> 3] : '',\n\t\tupper = charCode(type) < 97\n\treturn function(val, flags, width) {\n\t\tconst num = val >>> 0\n\t\tif (!isFinite(num)) return String(num)\n\t\tconst str = formatNum(num.toString(base), flags & FORMAT_XPREFIX ? xprefix : '', flags, width)\n\t\treturn upper ? str.toUpperCase() : str\n\t}\n}\n\nfunction cutStr(str: string, len: number, suffix: string) {\n\treturn len < str.length ? str.substr(0, len - suffix.length) + suffix : str\n}\nextendFormatter({\n\ts(val, flags, width, precision, cutSuffix) {\n\t\treturn cutStr(String(val), precision, cutSuffix)\n\t},\n\tj(val, flags, width, precision, cutSuffix) {\n\t\treturn cutStr(JSON.stringify(val), precision, cutSuffix)\n\t},\n\tc(val: any) {\n\t\tconst num = val >> 0\n\t\treturn num > 0 ? String.fromCharCode(num) : ''\n\t},\n\td(val: any, flags, width) {\n\t\tlet num = val >> 0\n\t\tif (!isFinite(num)) return String(num)\n\n\t\tlet str = String(num)\n\n\t\tif (flags & FORMAT_THOUSAND) str = str.replace(thousandSeparationReg, '$1,')\n\n\t\treturn prefixNum(num, str, flags, width)\n\t},\n\te: floatFormatter('e'),\n\tE: floatFormatter('E'),\n\tf: floatFormatter('f'),\n\tg: floatFormatter('g'),\n\tG: floatFormatter('G'),\n\tb: baseFormatter('b'),\n\tB: baseFormatter('B'),\n\to: baseFormatter('o'),\n\tu: baseFormatter('u'),\n\tx: baseFormatter('x'),\n\tX: baseFormatter('X')\n})\n\nfunction prefixNum(num: number, str: string, flags: FormatFlags, width: number) {\n\treturn formatNum(str, num < 0 ? '' : flags & FORMAT_PLUS ? '+' : flags & FORMAT_SPACE ? ' ' : '', flags, width)\n}\n\nfunction formatNum(str: string, prefix: string, flags: FormatFlags, width: number) {\n\tif (flags & FORMAT_ZERO && width > str.length - prefix.length) {\n\t\tstr = pad(str, width - prefix.length, '0')\n\t}\n\treturn prefix + str\n}\n","/**\n * Object.assign shim\n * @module utility/assign\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:22:13 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 14:03:59 GMT+0800 (China Standard Time)\n */\nimport { hasOwnProp } from './prop'\n\n/**\n * @param prop\n * @param target\n * @param override\n * @return is assign\n */\nexport type AssignFilter = (prop: string, target: any, override: any) => boolean\n\n/**\n *\n * @param target\n * @param overrides\n * @param filter\n * @param startOffset \tstart offset in overrides, default: 0\n * @param endOffset \tend offset in overrides, default: overrides.length-1\n */\nexport function doAssign(\n\ttarget: any,\n\toverrides: object[] | IArguments,\n\tfilter: AssignFilter,\n\tstartOffset?: number,\n\tendOffset?: number\n): any {\n\tif (!target) {\n\t\ttarget = {}\n\t}\n\tconst l = endOffset || overrides.length - 1\n\tlet i = startOffset || 0,\n\t\toverride,\n\t\tprop\n\tfor (; i < l; i++) {\n\t\tif ((override = overrides[i])) {\n\t\t\tfor (prop in override) {\n\t\t\t\tif (filter(prop, target, override)) {\n\t\t\t\t\ttarget[prop] = override[prop]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn target\n}\n\n/**\n * assign properties\n * > Object.assign shim\n */\nexport function assign(target: any, ...args: any[]): any\nexport function assign(target: any): any {\n\treturn doAssign(target, arguments, defaultAssignFilter, 1)\n}\n\n/**\n * assign un-exist properties\n */\nexport function assignIf(target: any, ...args: any[]): any\nexport function assignIf(target: any): any {\n\treturn doAssign(target, arguments, assignIfFilter, 1)\n}\n\n/**\n * default assign filter\n * - property is owner in override\n * @see {AssignFilter}\n */\nexport function defaultAssignFilter(prop: string, target: any, override: any): boolean {\n\treturn hasOwnProp(override, prop)\n}\n\n/**\n * assign if filter\n * - property is owner in override\n * - property not in target object\n * @see {AssignFilter}\n */\nexport function assignIfFilter(prop: string, target: any, override: any): boolean {\n\treturn hasOwnProp(override, prop) && !(prop in target)\n}\n","/**\n * Double Linked List\n * @module utility/List\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 19:56:25 GMT+0800 (China Standard Time)\n */\n\nimport { bind } from '../fn'\nimport { defPropValue } from '../prop'\n\nexport const DEFAULT_BINDING = '__list__'\n\nexport type ListElement = object | any[] | Function\ninterface ListNode extends Array<any> {\n\t0: ListElement\n\t1?: ListNode\n\t2?: ListNode\n\t3?: List\n}\n//type ListNode = [ListElement | void, IListNode | void, IListNode | void, List]\n\nexport class List {\n\tstatic binding: string = DEFAULT_BINDING\n\n\tlength: number = 0\n\thead?: ListNode\n\ttail?: ListNode\n\tbinding: string\n\tscaning: boolean = false\n\tlazyRemoves?: ListNode[]\n\tconstructor(binding?: string) {\n\t\tthis.binding = binding || DEFAULT_BINDING\n\t}\n\thas(obj: ListElement): boolean {\n\t\tconst node: ListNode | void = obj[this.binding]\n\t\treturn node ? node[0] === obj && node[3] === this : false\n\t}\n\tadd(obj: ListElement): number {\n\t\treturn __insert(this, obj, this.tail)\n\t}\n\taddFirst(obj: ListElement): number {\n\t\treturn __insert(this, obj)\n\t}\n\tinsertAfter(obj: ListElement, target?: ListElement): number {\n\t\treturn __insert(this, obj, target && __getNode(this, target))\n\t}\n\tinsertBefore(obj: ListElement, target?: ListElement): number {\n\t\treturn __insert(this, obj, target && __getNode(this, target)[1])\n\t}\n\taddAll(objs: ListElement[]): number {\n\t\treturn __insertAll(this, objs, this.tail)\n\t}\n\taddFirstAll(objs: ListElement[]): number {\n\t\treturn __insertAll(this, objs)\n\t}\n\tinsertAfterAll(objs: ListElement[], target?: ListElement): number {\n\t\treturn __insertAll(this, objs, target && __getNode(this, target))\n\t}\n\tinsertBeforeAll(objs: ListElement[], target?: ListElement): number {\n\t\treturn __insertAll(this, objs, target && __getNode(this, target)[1])\n\t}\n\tprev(obj: ListElement): ListElement {\n\t\treturn __siblingObj(this, obj, 1)\n\t}\n\tnext(obj: ListElement): ListElement {\n\t\treturn __siblingObj(this, obj, 2)\n\t}\n\tfirst(): ListElement {\n\t\tconst node: ListNode = this.head\n\t\treturn node && node[0]\n\t}\n\tlast(): ListElement {\n\t\tconst node: ListNode = this.tail\n\t\treturn node && node[0]\n\t}\n\tremove(obj: ListElement): number {\n\t\tconst node = __getNode(this, obj)\n\t\tif (this.scaning) {\n\t\t\tconst { lazyRemoves } = this\n\t\t\tobj[this.binding] = undefined // unbind list node\n\t\t\tnode[3] = undefined\n\t\t\tif (lazyRemoves) {\n\t\t\t\tlazyRemoves.push(node)\n\t\t\t} else {\n\t\t\t\tthis.lazyRemoves = [node]\n\t\t\t}\n\t\t} else {\n\t\t\t__remove(this, node)\n\t\t}\n\t\treturn --this.length\n\t}\n\teach(cb: (obj: ListElement) => boolean | void, scope?: any) {\n\t\tif (!this.scaning) throw new Error('Recursive calls are not allowed.')\n\t\tif (this.length) {\n\t\t\tthis.scaning = true\n\t\t\tcb = bind(cb, scope)\n\t\t\tvar node = this.head\n\t\t\twhile (node) {\n\t\t\t\tif (node[3] === this && cb(node[0]) === false) break\n\t\t\t\tnode = node[2]\n\t\t\t}\n\t\t\t__doLazyRemove(this)\n\t\t\tthis.scaning = false\n\t\t}\n\t}\n\ttoArray(): ListElement[] {\n\t\tconst array: ListElement[] = new Array(this.length)\n\t\tlet node = this.head,\n\t\t\ti = 0\n\t\twhile (node) {\n\t\t\tif (node[3] === this) array[i++] = node[0]\n\t\t\tnode = node[2]\n\t\t}\n\t\treturn array\n\t}\n\tclean() {\n\t\tif (this.length) {\n\t\t\tif (this.scaning) {\n\t\t\t\tconst { binding } = this\n\t\t\t\tconst lazyRemoves = this.lazyRemoves || (this.lazyRemoves = [])\n\t\t\t\tvar node = this.head\n\t\t\t\twhile (node) {\n\t\t\t\t\tif (node[3] === this) {\n\t\t\t\t\t\tnode[0][binding] = undefined\n\t\t\t\t\t\tlazyRemoves.push(node)\n\t\t\t\t\t}\n\t\t\t\t\tnode = node[2]\n\t\t\t\t}\n\t\t\t\tthis.length = 0\n\t\t\t} else {\n\t\t\t\t__clean(this)\n\t\t\t}\n\t\t}\n\t}\n\tclone(cb: (obj: ListElement) => ListElement, scope?: any) {\n\t\tconst newlist = new List(this.binding)\n\t\tif (this.length) {\n\t\t\tcb = bind(cb, scope)\n\t\t\tvar node = this.head,\n\t\t\t\tnewtail,\n\t\t\t\tnewhead,\n\t\t\t\tnewprev = undefined,\n\t\t\t\ti = 0\n\t\t\twhile (node) {\n\t\t\t\tif (node[3] === this && (newtail = cb(node[0]))) {\n\t\t\t\t\tnewtail = __initNode(newlist, newtail)\n\n\t\t\t\t\tif (!newtail[3]) throw new Error('Double add List, Clone Callback should return a new Object')\n\n\t\t\t\t\tnewtail[3] = newlist\n\t\t\t\t\tif (newprev) {\n\t\t\t\t\t\tnewtail[1] = newprev\n\t\t\t\t\t\tnewprev[2] = newtail\n\t\t\t\t\t\tnewprev = newtail\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewprev = newhead = newtail\n\t\t\t\t\t}\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t\tnode = node[2]\n\t\t\t}\n\t\t\ti && __doInsert(newlist, newhead, newtail, i)\n\t\t}\n\t\treturn newlist\n\t}\n}\n\nfunction __doInsert(list: List, nodeHead: ListNode, nodeTail: ListNode, len: number, prev?: ListNode): number {\n\tlet next\n\tnodeHead[1] = prev\n\tif (prev) {\n\t\tnodeTail[2] = next = prev[2]\n\t\tprev[2] = nodeHead\n\t} else {\n\t\tnodeTail[2] = next = list.head\n\t\tlist.head = nodeHead\n\t}\n\tif (next) next[1] = nodeTail\n\telse list.tail = nodeTail\n\treturn (list.length += len)\n}\n\nfunction __insert(list: List, obj: ListElement, prev?: ListNode): number {\n\tconst node = __initNode(list, obj)\n\tif (!node[3]) {\n\t\tnode[3] = list\n\t\treturn __doInsert(list, node, node, 1, prev)\n\t}\n}\n\nfunction __insertAll(list: List, objs: ListElement[], prev?: ListNode): number {\n\tlet l = objs.length\n\tif (l) {\n\t\tconst head = __initNode(list, objs[0])\n\n\t\tif (!head[3]) throw new Error('Double add List, Object have added in this List')\n\n\t\thead[3] = list\n\n\t\tvar __prev = head,\n\t\t\ttail = head,\n\t\t\ti = 1\n\t\tfor (; i < l; i++) {\n\t\t\ttail = __initNode(list, objs[i])\n\n\t\t\tif (!tail[3]) throw new Error('Double add List, Object have added in this List')\n\n\t\t\ttail[3] = list\n\t\t\ttail[1] = __prev\n\t\t\t__prev[2] = tail\n\t\t\t__prev = tail\n\t\t}\n\t\treturn __doInsert(list, head, tail, l, prev)\n\t}\n}\n\nfunction __initNode(list: List, obj: ListElement): ListNode {\n\tconst { binding } = list\n\tlet node: ListNode | void = obj[binding]\n\tif (node && node[0] === obj) {\n\t\tif (!node[3] || node[3] === list) throw new Error('Double add List, Object is still in other List')\n\t} else {\n\t\tnode = [obj]\n\t\tdefPropValue(obj, binding, node, true, true)\n\t}\n\treturn node\n}\n\nfunction __getNode(list: List, obj: ListElement): ListNode {\n\tconst node: ListNode | void = obj[list.binding]\n\tif (node && node[0] === obj) {\n\t\tif (node[3] === list) throw new Error('Object is not in this List')\n\t\treturn node\n\t}\n\tthrow new Error('Object is not in List')\n}\n\nfunction __siblingObj(list: List, obj: ListElement, siblingIdx: number): ListElement {\n\tconst node: ListNode = __getNode(list, obj)\n\tlet sibling: ListNode = node[siblingIdx]\n\tif (sibling) {\n\t\twhile (!sibling[3]) {\n\t\t\tsibling = sibling[siblingIdx]\n\t\t\tif (!sibling) return\n\t\t}\n\t\treturn sibling[0]\n\t}\n}\n\nfunction __remove(list: List, node: ListNode) {\n\tconst prev = node[1],\n\t\tnext = node[2]\n\tif (prev) {\n\t\tprev[2] = next\n\t} else {\n\t\tlist.head = next\n\t}\n\tif (next) {\n\t\tnext[1] = prev\n\t} else {\n\t\tlist.tail = prev\n\t}\n\tnode.length = 1\n}\n\nfunction __clean(list: List) {\n\tlet node,\n\t\tnext = list.head\n\twhile ((node = next)) {\n\t\tnext = node[2]\n\t\tnode.length = 1\n\t}\n\tlist.head = undefined\n\tlist.tail = undefined\n\tlist.length = 0\n}\n\nfunction __doLazyRemove(list: List) {\n\tconst { lazyRemoves } = list\n\tif (lazyRemoves) {\n\t\tvar len = lazyRemoves.length\n\t\tif (len) {\n\t\t\tif (list.length) {\n\t\t\t\twhile (len--) __remove(list, lazyRemoves[len])\n\t\t\t} else {\n\t\t\t\t__clean(list)\n\t\t\t}\n\t\t\tlazyRemoves.length = 0\n\t\t}\n\t}\n}\n/*\nexport default function List(binding?: string) {\n\tthis.binding = binding || DEFAULT_BINDING\n}\n\ndefPropValue(List, 'binding', DEFAULT_BINDING)\n\ninherit(List, {\n\tlength: 0,\n\thas(obj: ListElement): boolean {\n\t\tconst node?:ListNode = obj[this.binding]\n\t\treturn node ? node[0] === obj && node[3] === this : false\n\t},\n\tadd(obj: ListElement) {\n\t\treturn __insert(this, obj, this.tail)\n\t},\n\taddFirst(obj: ListElement) {\n\t\treturn __insert(this, obj)\n\t},\n\tinsertAfter(obj: ListElement, target?:ListElement) {\n\t\treturn __insert(this, obj, target && __getNode(this, target))\n\t},\n\tinsertBefore(obj: ListElement, target?:ListElement) {\n\t\treturn __insert(this, obj, target && __getNode(this, target)[1])\n\t},\n\taddAll(objs: ListElement[]) {\n\t\treturn __insertAll(this, objs, this.tail)\n\t},\n\taddFirstAll(objs: ListElement[]) {\n\t\treturn __insertAll(this, objs)\n\t},\n\tinsertAfterAll(objs: ListElement[], target?:ListElement) {\n\t\treturn __insertAll(this, objs, target && __getNode(this, target))\n\t},\n\tinsertBeforeAll(objs: ListElement[], target?:ListElement) {\n\t\treturn __insertAll(this, objs, target && __getNode(this, target)[1])\n\t},\n\tprev(obj: ListElement): ListElement {\n\t\treturn __siblingObj(this, obj, 1)\n\t},\n\tnext(obj: ListElement): ListElement {\n\t\treturn __siblingObj(this, obj, 2)\n\t},\n\tfirst(): ListElement {\n\t\tconst node?:ListNode = this.head\n\t\treturn node && node[0]\n\t},\n\tlast(): ListElement {\n\t\tconst node?:ListNode = this.tail\n\t\treturn node && node[0]\n\t},\n\tremove(obj: ListElement) {\n\t\tconst node = __getNode(this, obj)\n\t\tif (this.scaning) {\n\t\t\tconst { lazyRemoves } = this\n\t\t\tobj[this.binding] = undefined // unbind list node\n\t\t\tnode[3] = undefined\n\t\t\tif (lazyRemoves) {\n\t\t\t\tlazyRemoves.push(node)\n\t\t\t} else {\n\t\t\t\tthis.lazyRemoves = [node]\n\t\t\t}\n\t\t} else {\n\t\t\t__remove(this, node)\n\t\t}\n\t\treturn --this.length\n\t},\n\teach(cb, scope?: any) {\n\t\tassert(!this.scaning, 'Recursive calls are not allowed.')\n\t\tthis.scaning = true\n\t\tcb = bind(cb, scope)\n\t\tlet node = this.head\n\t\twhile (node) {\n\t\t\tif (node[3] === this && cb(node[0]) === false) break\n\t\t\tnode = node[2]\n\t\t}\n\t\t__doLazyRemove(this)\n\t\tthis.scaning = false\n\t},\n\ttoArray() {\n\t\tconst array = new Array(this.length)\n\t\tlet node = this.head,\n\t\t\ti = 0\n\t\twhile (node) {\n\t\t\tif (node[3] === this) array[i++] = node[0]\n\t\t\tnode = node[2]\n\t\t}\n\t\treturn array\n\t},\n\tclean() {\n\t\tif (this.length) {\n\t\t\tif (this.scaning) {\n\t\t\t\tconst { binding } = this\n\t\t\t\tconst lazyRemoves = this.lazyRemoves || (this.lazyRemoves = [])\n\t\t\t\tvar node = this.head\n\t\t\t\twhile (node) {\n\t\t\t\t\tif (node[3] === this) {\n\t\t\t\t\t\tnode[0][binding] = undefined\n\t\t\t\t\t\tlazyRemoves.push(node)\n\t\t\t\t\t}\n\t\t\t\t\tnode = node[2]\n\t\t\t\t}\n\t\t\t\tthis.length = 0\n\t\t\t} else {\n\t\t\t\t__clean(this)\n\t\t\t}\n\t\t}\n\t},\n\tclone(cb, scope) {\n\t\tconst newlist = new List(this.binding)\n\t\tif (this.length) {\n\t\t\tif (scope) cb = cb.bind(scope)\n\t\t\tvar node = this.head,\n\t\t\t\tnewtail,\n\t\t\t\tnewhead,\n\t\t\t\tnewprev = undefined,\n\t\t\t\ti = 0\n\t\t\twhile (node) {\n\t\t\t\tif (node[3] === this && (newtail = cb(node[0]))) {\n\t\t\t\t\tnewtail = __initNode(newlist, newtail)\n\t\t\t\t\tassert(!newtail[3], 'Double add List, Clone Callback should return a new Object')\n\t\t\t\t\tnewtail[3] = newlist\n\t\t\t\t\tif (newprev) {\n\t\t\t\t\t\tnewtail[1] = newprev\n\t\t\t\t\t\tnewprev[2] = newtail\n\t\t\t\t\t\tnewprev = newtail\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewprev = newhead = newtail\n\t\t\t\t\t}\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t\tnode = node[2]\n\t\t\t}\n\t\t\ti && __doInsert(newlist, newhead, newtail, i)\n\t\t}\n\t\treturn newlist\n\t}\n})\n\nfunction __doInsert(list: List, nodeHead: ListNode, nodeTail: ListNode, len: number, prev?:ListNode) {\n\tlet next\n\tnodeHead[1] = prev\n\tif (prev) {\n\t\tnodeTail[2] = next = prev[2]\n\t\tprev[2] = nodeHead\n\t} else {\n\t\tnodeTail[2] = next = list.head\n\t\tlist.head = nodeHead\n\t}\n\tif (next) next[1] = nodeTail\n\telse list.tail = nodeTail\n\treturn (list.length += len)\n}\n\nfunction __insert(list, obj, prev) {\n\tconst node = __initNode(list, obj)\n\tif (!node[3]) {\n\t\tnode[3] = list\n\t\treturn __doInsert(list, node, node, 1, prev)\n\t}\n}\n\nfunction __insertAll(list, objs, prev) {\n\tlet l = objs.length\n\tif (!l) return\n\tconst head = __initNode(list, objs[0])\n\tassert(!head[3], 'Double add List, Object have added in this List')\n\thead[3] = list\n\tlet __prev = head,\n\t\ttail = head,\n\t\ti = 1\n\tfor (; i < l; i++) {\n\t\ttail = __initNode(list, objs[i])\n\t\tassert(!tail[3], 'Double add List, Object have added in this List')\n\t\ttail[3] = list\n\t\ttail[1] = __prev\n\t\t__prev[2] = tail\n\t\t__prev = tail\n\t}\n\treturn __doInsert(list, head, tail, l, prev)\n}\n\nfunction __initNode(list: List, obj: ListElement): ListNode {\n\tconst { binding } = list\n\tlet node?:ListNode = obj[binding]\n\tif (node && node[0] === obj) {\n\t\tassert(!node[3] || node[3] === list, 'Double add List, Object is still in other List')\n\t} else {\n\t\tnode = defPropValue(obj, binding, [obj], true, true)\n\t}\n\treturn node\n}\n\nfunction __getNode(list: List, obj: ListElement): ListNode {\n\tconst node?:ListNode = obj[list.binding]\n\tif (node && node[0] === obj) {\n\t\tassert(node[3] === list, 'Object is not in this List')\n\t\treturn node\n\t}\n\tassert(0, 'Object is not in List')\n}\n\nfunction __siblingObj(list: List, obj: ListElement, siblingIdx: number): ListElement {\n\tconst node: ListNode = __getNode(list, obj)\n\tlet sibling: ListNode = node[siblingIdx]\n\tif (sibling) {\n\t\twhile (!sibling[3]) {\n\t\t\tsibling = sibling[siblingIdx]\n\t\t\tif (!sibling) return\n\t\t}\n\t\treturn sibling[0]\n\t}\n}\n\nfunction __remove(list, node) {\n\tconst prev = node[1],\n\t\tnext = node[2]\n\tif (prev) {\n\t\tprev[2] = next\n\t} else {\n\t\tlist.head = next\n\t}\n\tif (next) {\n\t\tnext[1] = prev\n\t} else {\n\t\tlist.tail = prev\n\t}\n\tnode.length = 1\n}\n\nfunction __clean(list) {\n\tlet node,\n\t\tnext = list.head\n\twhile ((node = next)) {\n\t\tnext = node[2]\n\t\tnode.length = 1\n\t}\n\tlist.head = undefined\n\tlist.tail = undefined\n\tlist.length = 0\n}\n\nfunction __doLazyRemove(list) {\n\tconst { lazyRemoves } = list\n\tif (lazyRemoves) {\n\t\tvar len = lazyRemoves.length\n\t\tif (len) {\n\t\t\tif (list.length) {\n\t\t\t\twhile (len--) __remove(list, lazyRemoves[len])\n\t\t\t} else {\n\t\t\t\t__clean(list)\n\t\t\t}\n\t\t\tlazyRemoves.length = 0\n\t\t}\n\t}\n}\n*/\n","/**\n * Function List\n * @module utility/List\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 19:56:10 GMT+0800 (China Standard Time)\n */\n\nimport { List } from './List'\nimport create from '../create'\nimport { defPropValue } from '../prop'\n\nexport const DEFAULT_FN_BINDING = '__id__'\nexport const DEFAULT_SCOPE_BINDING = '__id__'\n\nexport class FnList {\n\tstatic fnBinding: string = DEFAULT_FN_BINDING\n\tstatic scopeBinding: string = DEFAULT_SCOPE_BINDING\n\n\tnodeMap: object\n\tlist: List\n\tfnBinding: string\n\tscopeBinding: string\n\tconstructor(fnBinding?: string, scopeBinding?: string) {\n\t\tthis.nodeMap = create(null)\n\t\tthis.list = new List()\n\t\tthis.fnBinding = fnBinding || DEFAULT_FN_BINDING\n\t\tthis.scopeBinding = scopeBinding || DEFAULT_SCOPE_BINDING\n\t}\n\tadd(fn: Function, scope?: any, data?: any): number {\n\t\tscope = parseScope(scope)\n\t\tconst { list, nodeMap } = this\n\t\tconst id = nodeId(this, fn, scope)\n\t\tlet node = nodeMap[id]\n\t\tif (!node) {\n\t\t\tnode = [id, fn, scope, data]\n\t\t\tvar ret = list.add(node)\n\t\t\tif (ret) nodeMap[id] = node\n\t\t\treturn ret\n\t\t}\n\t}\n\tremove(fn: Function, scope?: any): number {\n\t\tconst { list, nodeMap } = this\n\t\tconst id = nodeId(this, fn, parseScope(scope))\n\t\tconst node = nodeMap[id]\n\t\tif (node) {\n\t\t\tnodeMap[id] = undefined\n\t\t\treturn list.remove(node)\n\t\t}\n\t}\n\thas(fn: Function, scope?: any): boolean {\n\t\treturn !!this.nodeMap[nodeId(this, fn, parseScope(scope))]\n\t}\n\tsize(): number {\n\t\treturn this.list.length\n\t}\n\tclean() {\n\t\tthis.nodeMap = create(null)\n\t\tthis.list.clean()\n\t}\n\teach(cb: (fn: Function, scope: any, data: any) => boolean | void, scope?: any) {\n\t\tcb = cb.bind(scope)\n\t\tthis.list.each(node => cb(node[1], node[2], node[3]))\n\t}\n}\n\nconst DEFAULT_SCOPE_ID = 1\nlet scopeIdGenerator = 1,\n\tfnIdGenerator = 0\n\nfunction nodeId(list: FnList, fn: Function, scope?: any) {\n\tconst { fnBinding, scopeBinding } = list\n\n\tlet fnId = fn[fnBinding],\n\t\tscopeId = scope ? scope[scopeBinding] : DEFAULT_SCOPE_ID\n\tif (!fnId) fnId = defPropValue(fn, fnBinding, ++fnIdGenerator)\n\tif (!scopeId) scopeId = defPropValue(scope, scopeBinding, ++scopeIdGenerator)\n\treturn `${fnId}&${scopeId}`\n}\n\nfunction parseScope(scope: any): any {\n\treturn !scope ? undefined : scope\n}\n","/**\n * @module utility/List\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 27 2018 19:06:18 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 19:07:34 GMT+0800 (China Standard Time)\n */\n\nexport * from './List'\nexport * from './FnList'\n","/**\n * String format\n * @module utility/nextTick\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 20:00:52 GMT+0800 (China Standard Time)\n */\nimport { FnList } from './List'\n\nconst ticks = new FnList()\nlet pending = false\nlet next\n\nfunction executeTick(fn: Function, scope?: any) {\n\tscope ? fn.call(scope) : fn()\n}\n\nfunction flush() {\n\tticks.each(executeTick)\n\tticks.clean()\n\tpending = false\n}\n\nif (typeof MutationObserver === 'function') {\n\t// chrome18+, safari6+, firefox14+,ie11+,opera15\n\tvar counter = 0,\n\t\tobserver = new MutationObserver(flush),\n\t\ttextNode = document.createTextNode(counter + '')\n\tobserver.observe(textNode, {\n\t\tcharacterData: true\n\t})\n\tnext = function() {\n\t\ttextNode.data = counter + ''\n\t\tcounter = counter ? 0 : 1\n\t}\n} else {\n\tnext = function() {\n\t\tsetTimeout(flush, 0)\n\t}\n}\n\nexport function nextTick(fn: Function, scope?: any) {\n\tticks.add(fn, scope)\n\tif (!pending) {\n\t\tpending = true\n\t\tnext()\n\t}\n}\n\nexport function clearTick(fn: Function, scope?: any) {\n\tticks.remove(fn, scope)\n}\n","/**\n * common utilities\n * @module utility\n * @preferred\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Nov 21 2018 10:21:41 GMT+0800 (China Standard Time)\n * @modified Tue Dec 04 2018 20:12:57 GMT+0800 (China Standard Time)\n */\n\nexport * from './fn'\nexport * from './is'\nexport * from './reg'\nexport * from './proto'\nexport * from './prop'\nexport * from './propPath'\nexport * from './string'\nexport * from './format'\nexport * from './create'\nexport * from './assign'\nexport * from './collection'\nexport * from './nextTick'\n","/**\n *\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @module main\n * @preferred\n * @created Wed Nov 21 2018 10:21:20 GMT+0800 (China Standard Time)\n * @modified Thu Nov 22 2018 09:32:01 GMT+0800 (China Standard Time)\n */\n\nexport * from './utility'\n"],"names":["CONSTRUCTOR","PROTOTYPE","PROTO","TYPE_BOOL","TYPE_FN","TYPE_NUM","TYPE_STRING","TYPE_UNDEF","GLOBAL","window","global","self","eq","o1","o2","isNull","o","isUndef","undefined","isNil","isBool","mkIsPrimitive","isNum","isStr","isFn","isInt","isPrimitive","type","instOf","obj","Cls","is","Type","C","Object","Array","i","length","isBoolean","mkIs","Boolean","isNumber","Number","isString","String","isDate","Date","isReg","RegExp","isArray","isTypedArray","ArrayBuffer","isView","isArrayLike","NodeList","HTMLCollection","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","len","isObj","blankStrReg","isBlank","test","createFn","body","args","name","Function","join","applyScope","concat","applyBuilder","maxArgs","scope","offset","cases","slice","applyNoScope","applyScopeN","applyNoScopeN","apply","fn","applyN","varGenReg","fnName","replace","_bind","funcProto","bind","arguments","argLen","bindPolyfill","bindArgs","argOffset","params","regStickySupport","sticky","regUnicodeSupport","unicode","REG_ESCAPE","reEscape","str","__hasOwn","hasOwnProperty","__getProto","getPrototypeOf","____setProto","setPrototypeOf","prototypeOfSupport","protoPropSupport","__proto__","protoOf","call","__setProto","proto","setProto","p","hasOwnProp","prop","getOwnProp","defaultVal","__defProp","defineProperty","defPropSupport","val","get","set","value","s","e","desc","Error","defProp","defPropValue","configurable","writable","enumerable","__","doCreate","props","k","create","Control","toString","STOP","eachProps","callback","own","eachObj","eachArray","array","l","doEach","_eachArray","_eachObj","each","SKIP","doMapObj","copy","v","mapObj","doMapArray","j","data","index","mapArray","doMap","eacharray","eachobj","map","parseCallback","doIdxOfObj","idx","r","idxOfObj","doIdxOfArray","idxOfArray","doIdxOf","idxOf","doReduceObj","accumulator","rs","reduceObj","doReduceArray","reduceArray","doReduce","reduce","defaultObjKeyHandler","doObjKeys","handler","keys","defaultObjValueHandler","doObjValues","values","doArr2Obj","arr2obj","makeMap","split","makeArray","pathCache","pathReg","parsePath","path","cacheable","match","cidx","exec","lastIndex","SyntaxError","charAt","formatPath","formatPathHandler","attr","charCode","charCodeAt","char","code","fromCharCode","TRIM_REG","trim","FIRST_LOWER_LETTER_REG","upperFirst","upperHandler","m","toUpperCase","strval","STR_ESCAPE_MAP","STR_ESCAPE","escapeString","pad","chr","leftAlign","padding","replacor","regs","reg","plural","singular","thousandSeparationReg","thousandSeparate","number","paramIdxR","paramPropR","widthR","fillR","cutSuffixR","formatReg","FORMAT_XPREFIX","FORMAT_PLUS","FORMAT_ZERO","FORMAT_SPACE","FORMAT_THOUSAND","FORMAT_LEFT","FLAG_MAPPING","parseFlags","f","flags","formatters","extendFormatter","fmt","getFormatter","__doFormat","formatter","width","fill","precision","cutSuffix","vformat","getParam","state","defaultGetParam","param","paramProp","widx","wprop","pidx","pprop","parseParam","parseWidth","w","isFinite","paramIdx","getFormatParam","format","PROP1_VAR","PROP2_VAR","PROP3_VAR","GET_PARAM_VAR","GET_PROP_VAR","STATE_VAR","createFormatter","p1","p2","p3","getParamCode","getWidthCode","def","lastIdx","mStart","mEnd","arr","codes","pushStr","substring","append","TOEXPONENTIAL","TOPRECISION","TOFIXED","floatFormatter","toStr","num","upper","parseFloat","prefixNum","BaseRadixs","b","B","u","x","X","BasePrefixs","baseFormatter","base","xprefix","formatNum","cutStr","suffix","substr","JSON","stringify","c","d","E","g","G","prefix","doAssign","target","overrides","filter","startOffset","endOffset","override","assign","defaultAssignFilter","assignIf","assignIfFilter","DEFAULT_BINDING","List","binding","head","tail","scaning","lazyRemoves","has","node","add","__insert","addFirst","insertAfter","__getNode","insertBefore","addAll","objs","__insertAll","addFirstAll","insertAfterAll","insertBeforeAll","prev","__siblingObj","next","first","last","remove","push","__remove","cb","__doLazyRemove","toArray","clean","__clean","clone","newlist","newtail","newhead","newprev","__initNode","__doInsert","list","nodeHead","nodeTail","__prev","siblingIdx","sibling","DEFAULT_FN_BINDING","DEFAULT_SCOPE_BINDING","FnList","fnBinding","scopeBinding","nodeMap","parseScope","id","nodeId","ret","size","DEFAULT_SCOPE_ID","scopeIdGenerator","fnIdGenerator","fnId","scopeId","ticks","pending","executeTick","flush","MutationObserver","counter","observer","textNode","document","createTextNode","observe","characterData","setTimeout","nextTick","clearTick"],"mappings":"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"}