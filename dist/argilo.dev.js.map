{"version":3,"file":"argilo.dev.js","sources":["../src/utility/consts.ts","../src/utility/is.ts","../src/utility/fn.ts","../src/utility/reg.ts","../src/utility/proto.ts","../src/utility/prop.ts","../src/utility/create.ts","../src/utility/collection/control.ts","../src/utility/collection/each.ts","../src/utility/collection/map.ts","../src/utility/collection/idxOf.ts","../src/utility/collection/reduce.ts","../src/utility/collection/obj2arr.ts","../src/utility/collection/arr2obj.ts","../src/utility/collection/index.ts","../src/utility/propPath.ts","../src/utility/string.ts","../src/utility/format.ts","../src/utility/assign.ts","../src/utility/assert.ts","../src/utility/List/List.ts","../src/utility/List/FnList.ts","../src/utility/List/index.ts","../src/utility/nextTick.ts","../src/utility/AST/Source.ts","../src/utility/AST/util.ts","../src/utility/mixin.ts","../src/utility/AST/Rule.ts","../src/utility/AST/MatchContext.ts","../src/utility/AST/ComplexRule.ts","../src/utility/AST/AndRule.ts","../src/utility/AST/OrRule.ts","../src/utility/AST/MatchRule.ts","../src/utility/AST/CharMatchRule.ts","../src/utility/AST/RegMatchRule.ts","../src/utility/AST/StringMatchRule.ts","../src/utility/AST/api.ts","../src/utility/AST/test.ts","../src/utility/index.ts","../src/index.ts"],"sourcesContent":["/**\n *\n * @author Tao Zeng (tao.zeng.zt@qq.com)\n * @module utility\n * @created 2018-11-09 15:23:35\n * @modified 2018-11-09 15:23:35 by Tao Zeng (tao.zeng.zt@qq.com)\n */\n\nexport const CONSTRUCTOR = 'constructor'\n\nexport const PROTOTYPE = 'prototype'\n\nexport const PROTO = '__proto__'\n\nexport const TYPE_BOOL = 'boolean'\n\nexport const TYPE_FN = 'function'\n\nexport const TYPE_NUM = 'number'\n\nexport const TYPE_STRING = 'string'\n\nexport const TYPE_UNDEF = 'undefined'\n\nexport const GLOBAL: any =\n\ttypeof window !== TYPE_UNDEF\n\t\t? window\n\t\t: typeof global !== TYPE_UNDEF\n\t\t? global\n\t\t: typeof self !== TYPE_UNDEF\n\t\t? self\n\t\t: {}\n\nexport interface ObjArray {\n\tlength: number;\n}\nexport  type IArray = any[] |string | IArguments | ObjArray\n","/**\n * type checker\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Sat Dec 15 2018 18:43:45 GMT+0800 (China Standard Time)\n */\n\nimport { CONSTRUCTOR, GLOBAL, TYPE_BOOL, TYPE_FN, TYPE_NUM, TYPE_STRING, TYPE_UNDEF } from './consts'\n\n/**\n * is equals\n * > o1 === o2 || NaN === NaN\n */\nexport function eq(o1: any, o2: any): boolean {\n\treturn o1 === o2 || (o1 !== o1 && o2 !== o2)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    primitive type                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * is null\n */\nexport function isNull(o: any): boolean {\n\treturn o === null\n}\n\n/**\n * is undefined\n */\nexport function isUndef(o: any): boolean {\n\treturn o === undefined\n}\n\n/**\n * is null or undefined\n */\nexport function isNil(o: any): boolean {\n\treturn o === null || o === undefined\n}\n\n/**\n * is boolean\n */\nexport const isBool: (o: any) => boolean = mkIsPrimitive(TYPE_BOOL)\n\n/**\n * is a number\n */\nexport const isNum: (o: any) => boolean = mkIsPrimitive(TYPE_NUM)\n\n/**\n * is a string\n */\nexport const isStr: (o: any) => boolean = mkIsPrimitive(TYPE_STRING)\n\n/**\n * is a function\n */\nexport const isFn: (o: any) => boolean = mkIsPrimitive(TYPE_FN)\n\n/**\n * is integer number\n */\nexport function isInt(o: any): boolean {\n\treturn o === 0 || (o ? typeof o === TYPE_NUM && o % 1 === 0 : false)\n}\n\n/**\n * is primitive type\n * - null\n * - undefined\n * - boolean\n * - number\n * - string\n * - function\n */\nexport function isPrimitive(o: any): boolean {\n\tif (o === undefined || o === null) {\n\t\treturn true\n\t}\n\tswitch (typeof o) {\n\t\tcase TYPE_BOOL:\n\t\tcase TYPE_NUM:\n\t\tcase TYPE_STRING:\n\t\tcase TYPE_FN:\n\t\t\treturn true\n\t}\n\treturn false\n}\n\nfunction mkIsPrimitive(type: string): (o: any) => boolean {\n\treturn function is(o: any): boolean {\n\t\treturn typeof o === type\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    reference type                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * is instanceof\n */\nexport function instOf(obj: any, Cls: Function): boolean {\n\treturn obj !== undefined && obj !== null && obj instanceof Cls\n}\n\n/**\n * is child instance of Type\n */\nexport function is(o: any, Type: Function | Function[]): boolean {\n\tif (o !== undefined && o !== null) {\n\t\tconst C = o[CONSTRUCTOR] || Object\n\t\tif (Type[CONSTRUCTOR] === Array) {\n\t\t\tvar i = Type.length\n\t\t\twhile (i--) {\n\t\t\t\tif (C === (Type as Function[])[i]) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn C === Type\n\t\t}\n\t}\n\treturn false\n}\n\n/**\n * is boolean or Boolean\n */\nexport const isBoolean: (o: any) => boolean = mkIs(Boolean)\n\n/**\n * is number or Number\n */\nexport const isNumber: (o: any) => boolean = mkIs(Number)\n\n/**\n * is string or String\n */\nexport const isString: (o: any) => boolean = mkIs(String)\n\n/**\n * is Date\n */\nexport const isDate: (o: any) => boolean = mkIs(Date)\n\n/**\n * is RegExp\n */\nexport const isReg: (o: any) => boolean = mkIs(RegExp)\n\n/**\n * is Array\n */\nexport const isArray: (o: any) => boolean = Array.isArray || mkIs(Array)\n\n/**\n * is Typed Array\n */\nexport const isTypedArray: (o: any) => boolean = isFn(ArrayBuffer) ? ArrayBuffer.isView : () => false\n\n/**\n * is Array or pseudo-array\n * - Array\n * - String\n * - IArguments\n * - NodeList\n * - HTMLCollection\n * - Typed Array\n * - {length: int, [length-1]: any}\n */\nexport function isArrayLike(o: any): boolean {\n\tif (o) {\n\t\tswitch (o[CONSTRUCTOR]) {\n\t\t\tcase Array:\n\t\t\tcase String:\n\t\t\tcase GLOBAL.NodeList:\n\t\t\tcase GLOBAL.HTMLCollection:\n\t\t\tcase GLOBAL.Int8Array:\n\t\t\tcase GLOBAL.Uint8Array:\n\t\t\tcase GLOBAL.Int16Array:\n\t\t\tcase GLOBAL.Uint16Array:\n\t\t\tcase GLOBAL.Int32Array:\n\t\t\tcase GLOBAL.Uint32Array:\n\t\t\tcase GLOBAL.Float32Array:\n\t\t\tcase GLOBAL.Float64Array:\n\t\t\t\treturn true\n\t\t}\n\t\tconst len = o.length\n\t\treturn typeof len === TYPE_NUM && (len === 0 || (len > 0 && len % 1 === 0 && len - 1 in o))\n\t}\n\treturn o === ''\n}\n\n/**\n * is simple Object\n * TODO object may has constructor property\n */\nexport function isObj(o: any): boolean {\n\tif (o === undefined || o === null) {\n\t\treturn false\n\t}\n\tconst C = o[CONSTRUCTOR]\n\treturn C === undefined || C === Object\n}\n\nfunction mkIs(Type: Function): (o: any) => boolean {\n\treturn function is(o: any): boolean {\n\t\treturn o !== undefined && o !== null && o[CONSTRUCTOR] === Type\n\t}\n}\n\nconst blankStrReg = /^\\s*$/\n/**\n * is empty\n * - string: trim(string).length === 0\n * - array: array.length === 0\n * - pseudo-array: pseudo-array.length === 0\n */\nexport function isBlank(o: any): boolean {\n\tif (o) {\n\t\tif (o[CONSTRUCTOR] === String) {\n\t\t\treturn blankStrReg.test(o)\n\t\t}\n\t\treturn o.length === 0\n\t}\n\treturn true\n}\n","/**\n * Function utilities\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Fri Nov 23 2018 11:18:33 GMT+0800 (China Standard Time)\n */\n\nimport { GLOBAL, PROTOTYPE } from './consts'\nimport { isNil } from './is'\n\n// ========================================================================================\n/*                                                                                      *\n *                                    create function                                   *\n *                                                                                      */\n// ========================================================================================\n\n/**\n * create function by code string\n * @param body\tfunction body\n * @param args\tfunction argument names\n * @param name\tfunction name\n */\nexport function createFn<T extends Function>(body: string, args?: string[], name?: string): T {\n\treturn name\n\t\t? Function(`return function ${name}(${args ? args.join(', ') : ''}){${body}}`)()\n\t\t: applyScope(Function, Function, args && args.length ? args.concat(body) : [body])\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                    function apply                                    *\n *                                                                                      */\n// ========================================================================================\n\n/**\n * generate apply function\n */\nfunction applyBuilder<T extends Function>(maxArgs: number, scope: any, offset: any): T {\n\tscope = scope ? 'scope' : ''\n\toffset = offset ? 'offset' : ''\n\tconst args = new Array(maxArgs + 1)\n\tconst cases = new Array(maxArgs + 1)\n\tfor (let i = 0; i <= maxArgs; i++) {\n\t\targs[i] = `${i || scope ? ', ' : ''}args[${offset ? `offset${i ? ' + ' + i : ''}` : i}]`\n\t\tcases[i] = `case ${i}: return fn${scope && '.call'}(${scope}${args.slice(0, i).join('')});`\n\t}\n\treturn Function(`return function(fn, ${scope && scope + ', '}args${offset && ', offset, len'}){\nswitch(${offset ? 'len' : 'args.length'}){\n${cases.join('\\n')}\n}\n${offset &&\n\t\t`var arr = new Array(len);\nfor(var i=0; i<len; i++) arr[i] = arr[offset + i];`}\nreturn fn.apply(${scope || 'null'}, ${offset ? 'arr' : 'args'});\n}`)()\n}\n\n/**\n * apply function with scope\n * @param fn\ttarget function\n * @param scope\tscope of function\n * @param args\targuments of function\n */\nexport const applyScope: (fn: Function, scope: any, args: any[] | IArguments) => any = applyBuilder(8, 1, 0)\n\n/**\n * apply function without scope\n * @param fn\t\ttarget function\n * @param args\targuments of function\n */\nexport const applyNoScope: (fn: Function, args: any[] | IArguments) => any = applyBuilder(8, 0, 0)\n\n/**\n * apply function with scope\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport const applyScopeN: (\n\tfn: Function,\n\tscope: any,\n\targs: any[] | IArguments,\n\toffset: number,\n\tlen: number\n) => any = applyBuilder(8, 1, 1)\n\n/**\n * apply function without scope\n * @param fn\t\ttarget function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport const applyNoScopeN: (fn: Function, args: any[] | IArguments, offset: number, len: number) => any = applyBuilder(\n\t8,\n\t0,\n\t1\n)\n\n/**\n * apply function\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n */\nexport function apply(fn: Function, scope: any, args: any[] | IArguments): any {\n\tif (scope === undefined || scope === null || scope === GLOBAL) {\n\t\treturn applyNoScope(fn, args || [])\n\t}\n\treturn applyScope(fn, scope, args || [])\n}\n\n/**\n * apply function\n * @param fn\t\ttarget function\n * @param scope\t\tscope of function\n * @param args\t\targuments of function\n * @param offset\tstart offset of args\n * @param len\t\targ size from offset\n */\nexport function applyN(fn: Function, scope: any, args: any[] | IArguments, offset: number, len: number): any {\n\tif (scope === undefined || scope === null || scope === GLOBAL) {\n\t\treturn applyNoScopeN(fn, args, offset, len)\n\t}\n\treturn applyScopeN(fn, scope, args, offset, len)\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                     function name                                    *\n *                                                                                      */\n// ========================================================================================\n\nconst varGenReg = /\\$\\d+$/\n\n/**\n * get function name\n */\nexport function fnName(fn: Function): string {\n\tconst name: string = (fn as any).name\n\treturn name ? name.replace(varGenReg, '') : 'anonymous'\n}\n\n// ========================================================================================\n/*                                                                                      *\n *                                         bind                                         *\n *                                                                                      */\n// ========================================================================================\n\nlet _bind\nconst funcProto = Function[PROTOTYPE]\nif (funcProto.bind) {\n\t_bind = function bind<T extends Function>(fn: T, scope: any): T {\n\t\tconst args = arguments,\n\t\t\targLen = args.length\n\t\tif (isNil(scope)) {\n\t\t\treturn argLen > 2 ? bindPolyfill(fn, scope, args, 2) : fn\n\t\t}\n\t\treturn applyScopeN(fn.bind, fn, args, 1, argLen - 1)\n\t}\n} else {\n\tfuncProto.bind = function bind(scope) {\n\t\treturn bindPolyfill(this, scope, arguments, 1)\n\t}\n\t_bind = function bind<T extends Function>(fn: T, scope: any): T {\n\t\treturn bindPolyfill(fn, scope, arguments, 2)\n\t}\n}\n\n/**\n * bind scope or arguments on function\n * - return source function when without arguments and scope is undefined or null\n * - only bind arguments when scope is undefined or null, well can call the new function proxy with some scope\n *\n * @example\n * \t\tfunction example() {\n * \t\t\tconsole.log(this, arguments);\n * \t\t}\n * \t\tvar proxy = bind(example, null) \t// proxy === example\n * \t\tproxy() \t\t\t\t\t\t\t// log: window | undefined, []\n * \t\tproxy.call(1) \t\t\t\t\t\t// log: 1, []\n *\n * \t\tproxy = bind(example, null, 1) \t\t// proxy !== example\n * \t\tproxy() \t\t\t\t\t\t\t// log: window | undefined, [1]\n * \t\tproxy(2) \t\t\t\t\t\t\t// log: window | undefined, [1, 2]\n * \t\tproxy.call(1, 2) \t\t\t\t\t// log: 1, [1, 2]\n *\n * \t\tproxy = bind(example, {}, 1, 2)\t\t// proxy !== example\n * \t\tproxy() \t\t\t\t\t\t\t// log: {}, [1]\n * \t\tproxy(2) \t\t\t\t\t\t\t// log: {}, [1, 2, 2]\n * \t\tproxy.call(1, 2) \t\t\t\t\t// log: {}, [1, 2, 2]\n *\n * @param fn\tsource function\n * @param scope\tbind scope\n * @param args\tbind arguments\n * @return function proxy\n */\nexport const bind: <T extends Function>(fn: T, scope: any, ...args: any[]) => T = _bind\n\n/**\n * bind\n * > not bind scope when scope is null or undefined\n * @param fn\t\tsource function\n * @param scope\t\tbind scope\n * @param args\t\tbind arguments\n * @param argOffset\toffset of args\n * @return function proxy\n */\nfunction bindPolyfill<T extends Function>(fn: T, scope: any, bindArgs: any[] | IArguments, argOffset: number): T {\n\tconst argLen = bindArgs.length - argOffset\n\tif (scope === undefined) {\n\t\tscope = null\n\t}\n\tif (argLen > 0) {\n\t\t// bind with arguments\n\t\treturn function bindProxy() {\n\t\t\tconst args = arguments\n\t\t\tlet i = args.length\n\t\t\tif (i) {\n\t\t\t\tconst params = new Array(argLen + i)\n\t\t\t\twhile (i--) {\n\t\t\t\t\tparams[argLen + i] = args[i]\n\t\t\t\t}\n\t\t\t\ti = argLen\n\t\t\t\twhile (i--) {\n\t\t\t\t\tparams[i] = bindArgs[i + argOffset]\n\t\t\t\t}\n\t\t\t\treturn apply(fn, scope === null ? this : scope, params) // call with scope or this\n\t\t\t}\n\t\t\treturn applyN(fn, scope === null ? this : scope, bindArgs, argOffset, argLen) // call with scope or this\n\t\t} as any\n\t}\n\tif (scope === null) {\n\t\treturn fn\n\t}\n\tif (scope === GLOBAL) {\n\t\t// bind on GLOBAL\n\t\treturn function bindProxy() {\n\t\t\treturn applyNoScope(fn, arguments)\n\t\t} as any\n\t}\n\treturn function bindProxy() {\n\t\treturn applyScope(fn, scope, arguments)\n\t} as any\n}\n","/**\n * regexp utilities\n * @module utility/reg\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Sep 06 2018 18:27:51 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 20:00:44 GMT+0800 (China Standard Time)\n */\n\nimport { isBool } from './is'\n\n/**\n * is support sticky on RegExp\n */\nexport const regStickySupport = isBool(/(?:)/.sticky)\n\n/**\n * is support unicode on RegExp\n */\nexport const regUnicodeSupport = isBool(/(?:)/.unicode)\n\nconst REG_ESCAPE = /[-\\/\\\\^$*+?.()|[\\]{}]/g\n\n/**\n * escape string for RegExp\n */\nexport function reEscape(str: string): string {\n\treturn str.replace(REG_ESCAPE, '\\\\$&')\n}\n","/**\n * prototype utilities\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:23:56 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 20:00:18 GMT+0800 (China Standard Time)\n */\nimport { CONSTRUCTOR, PROTO, PROTOTYPE } from './consts'\n\nconst __hasOwn = Object[PROTOTYPE].hasOwnProperty\nconst __getProto = Object.getPrototypeOf,\n\t____setProto = Object.setPrototypeOf\n\n/**\n * is support Object.getPrototypeOf and Object.setPrototypeOf\n */\nexport const prototypeOfSupport = !!____setProto\n\nexport const protoPropSupport = { __proto__: [] } instanceof Array\n\n/**\n * Object.getPrototypeOf shim\n */\nexport const protoOf: (o: any) => any = ____setProto\n\t? __getProto\n\t: __getProto\n\t? function getPrototypeOf(obj) {\n\t\t\treturn obj[PROTO] || __getProto(obj)\n\t  }\n\t: function getPrototypeOf(obj) {\n\t\t\treturn (__hasOwn.call(obj, PROTO) ? obj[PROTO] : obj[CONSTRUCTOR][PROTOTYPE]) || null\n\t  }\n\nexport const __setProto: <T>(obj: any, proto: any) => any =\n\t____setProto ||\n\tfunction setPrototypeOf(obj, proto) {\n\t\tobj[PROTO] = proto\n\t\treturn obj\n\t}\n\n/**\n * Object.setPrototypeOf shim\n */\nexport const setProto: <T>(obj: any, proto: any) => any =\n\t____setProto ||\n\t(protoPropSupport\n\t\t? __setProto\n\t\t: function setPrototypeOf(obj, proto) {\n\t\t\t\tfor (let p in proto) {\n\t\t\t\t\tif (__hasOwn.call(proto, p)) {\n\t\t\t\t\t\tobj[p] = proto[p]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn __setProto(obj, proto)\n\t\t  })\n","/**\n * prop utilities\n * @module utility\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:22:57 GMT+0800 (China Standard Time)\n * @modified Mon Dec 10 2018 12:44:40 GMT+0800 (China Standard Time)\n */\nimport { PROTO, PROTOTYPE } from './consts'\nimport { protoPropSupport } from './proto'\n\nconst __hasOwn = Object[PROTOTYPE].hasOwnProperty\n\n/**\n * has own property\n */\nexport const hasOwnProp: (obj: any, prop: string) => boolean = protoPropSupport\n\t? function hasOwnProp(obj: any, prop: string): boolean {\n\t\t\treturn __hasOwn.call(obj, prop)\n\t  }\n\t: function hasOwnProp(obj: any, prop: string): boolean {\n\t\t\treturn prop !== PROTO && __hasOwn.call(obj, prop)\n\t  }\n\n/**\n * get owner property value\n * @param prop \t\t\tproperty name\n * @param defaultVal \tdefault value\n */\nexport function getOwnProp(obj: any, prop: string, defaultVal?: any): any {\n\treturn hasOwnProp(obj, prop) ? obj[prop] : defaultVal\n}\n\nlet __defProp = Object.defineProperty\n/**\n * is support Object.defineProperty\n */\nexport const defPropSupport: boolean =\n\t__defProp &&\n\t(function() {\n\t\ttry {\n\t\t\tvar val,\n\t\t\t\tobj: any = {}\n\t\t\t__defProp(obj, 's', {\n\t\t\t\tget() {\n\t\t\t\t\treturn val\n\t\t\t\t},\n\t\t\t\tset(value) {\n\t\t\t\t\tval = value\n\t\t\t\t}\n\t\t\t})\n\t\t\tobj.s = 1\n\t\t\treturn obj.s === val\n\t\t} catch (e) {}\n\t})()\n\nif (!defPropSupport) {\n\t__defProp = function defineProperty(\n\t\tobj: any,\n\t\tprop: string | number | symbol,\n\t\tdesc: PropertyDescriptor & ThisType<any>\n\t): any {\n\t\tif (desc.get || desc.set) {\n\t\t\tthrow new Error('not support getter/setter on defineProperty')\n\t\t}\n\t\tobj[prop] = desc.value\n\t\treturn obj\n\t}\n}\n\n/**\n * define property\n */\nexport const defProp = __defProp\n\n/**\n * define property by value\n */\nexport const defPropValue: <V>(\n\tobj: any,\n\tprop: string,\n\tvalue: V,\n\tenumerable?: boolean,\n\tconfigurable?: boolean,\n\twritable?: boolean\n) => V = defPropSupport\n\t? function defPropValue(obj, prop, value, configurable, writable, enumerable) {\n\t\t\t__defProp(obj, prop, {\n\t\t\t\tvalue,\n\t\t\t\tenumerable: enumerable !== false,\n\t\t\t\tconfigurable: configurable !== false,\n\t\t\t\twritable: writable !== false\n\t\t\t})\n\t\t\treturn value\n\t  }\n\t: function defPropValue(obj, prop, value) {\n\t\t\tobj[prop] = value\n\t\t\treturn value\n\t  }\n","/**\n * Object.create shim\n * @module utility/create\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:24:47 GMT+0800 (China Standard Time)\n * @modified Mon Dec 10 2018 11:45:30 GMT+0800 (China Standard Time)\n */\n\nimport { CONSTRUCTOR, PROTOTYPE } from './consts'\nimport { defProp, hasOwnProp } from './prop'\nimport { __setProto } from './proto'\n\nfunction __() {}\n\n/**\n * create shim\n */\nfunction doCreate(o: object | null, props?: PropertyDescriptorMap & ThisType<any>): object {\n\t__[PROTOTYPE] = o\n\tconst obj = new __()\n\t__[PROTOTYPE] = null\n\tif (props) {\n\t\tvar k, v\n\t\tfor (k in props) {\n\t\t\tif (hasOwnProp(props, k)) {\n\t\t\t\tdefProp(obj, k, props[k])\n\t\t\t}\n\t\t}\n\t}\n\treturn obj\n}\n\n/**\n * create object\n */\nexport const create = Object.create ||\n\t(Object.getPrototypeOf\n\t\t? doCreate\n\t\t: function create(o: object | null, props?: PropertyDescriptorMap & ThisType<any>): object {\n\t\t\t\tconst obj = doCreate(o, props)\n\t\t\t\t__setProto(obj, o)\n\t\t\t\treturn obj\n\t\t  })\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:10:41 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 14:17:32 GMT+0800 (China Standard Time)\n */\nexport class Control {\n\tprivate desc: string\n\tconstructor(desc: string) {\n\t\tthis.desc = desc\n\t}\n\ttoString() {\n\t\treturn this.desc\n\t}\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:10:41 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:39:11 GMT+0800 (China Standard Time)\n */\nimport { Control } from './control'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { hasOwnProp } from '../prop'\nimport { isArrayLike, isBool } from '../is'\n\n/**\n * STOP Control\n * > stop each/map/indexOf...\n */\nexport const STOP = new Control('STOP')\n//========================================================================================\n/*                                                                                      *\n *                                each object properties                                *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on object\n * - will stop each on return STOP\n */\nexport type EachPropCallback = (prop: string, obj: object) => Control | void\n\n/**\n * each properties\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties, default: true\n * @return stoped property name or false\n */\nexport function eachProps(obj: object, callback: EachPropCallback, own: boolean): false | string\nexport function eachProps(obj: object, callback: EachPropCallback, scope?: any, own?: boolean): false | string\nexport function eachProps(obj: object, callback: EachPropCallback, scope?: any, own?: boolean): false | string {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tlet k: string\n\tif (own === false) {\n\t\tfor (k in obj) if (callback(k, obj) === STOP) return k\n\t} else {\n\t\tfor (k in obj) if (hasOwnProp(obj, k) && callback(k, obj) === STOP) return k\n\t}\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      each object                                     *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on object\n * - will stop each on callback return STOP\n */\nexport type EachObjCallback = (value: any, prop: string, obj: object) => Control | void\n\n/**\n * each object\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties, default: true\n * @return stoped property name or false\n */\nexport function eachObj(obj: object, callback: EachObjCallback, own: boolean): false | string\nexport function eachObj(obj: object, callback: EachObjCallback, scope?: any, own?: boolean): false | string\nexport function eachObj(obj: object, callback: EachObjCallback, scope?: any, own?: boolean): false | string {\n\tconst args = arguments\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tlet k: string\n\tif (own === false) {\n\t\tfor (k in obj) if (callback(obj[k], k, obj) === STOP) return k\n\t} else {\n\t\tfor (k in obj) if (hasOwnProp(obj, k) && callback(obj[k], k, obj) === STOP) return k\n\t}\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      each array                                      *\n *                                                                                      */\n//========================================================================================\n\n/**\n * each callback on array\n * - will stop each on callback return STOP\n */\nexport type EachArrayCallback = (data: any, index: number, array: IArray) => Control | void\n\n/**\n * each array\n * - will stop each on callback return STOP\n * @param array\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @return stoped index or false\n */\nexport function eachArray(array: IArray, callback: EachArrayCallback, scope?: any): false | number {\n\tcallback = bind(callback, scope)\n\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\tif (callback(array[i], i, array) === STOP) return i\n\t}\n\treturn false\n}\n\n/**\n * reverse each array\n * - will stop each on callback return STOP\n * @param array\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @return stoped index or false\n */\nexport function reachArray(array: IArray, callback: EachArrayCallback, scope?: any): false | number {\n\tcallback = bind(callback, scope)\n\tlet i = array.length\n\twhile (i--) if (callback(array[i], i, array) === STOP) return i\n\treturn false\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         each                                         *\n *                                                                                      */\n//========================================================================================\n\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: IArray,\n\tcallback: EachArrayCallback,\n\tscope?: any\n): false | number\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object,\n\tcallback: EachObjCallback,\n\town?: boolean\n): false | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object,\n\tcallback: EachObjCallback,\n\tscope?: any,\n\town?: boolean\n): false | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\town?: boolean\n): false | number | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\tscope?: any,\n\town?: boolean\n): false | number | string\nexport function doEach(\n\t_eachArray: typeof eachArray,\n\t_eachObj: typeof eachObj,\n\tobj: any,\n\tcallback: any,\n\tscope?: any,\n\town?: boolean\n): false | number | string {\n\tif (isArrayLike(obj)) return _eachArray(obj, callback, scope)\n\treturn _eachObj(obj, callback, scope, own)\n}\n\n/**\n * each\n * - will stop each on callback return STOP\n * @param obj\t\teach target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\teach own properties on object, default: true\n * @return stoped index or false\n */\n\nexport function each(obj: IArray, callback: EachArrayCallback, scope?: any): false | number\nexport function each(obj: object, callback: EachObjCallback, own?: boolean): false | string\nexport function each(obj: object, callback: EachObjCallback, scope?: any, own?: boolean): false | string\nexport function each(\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\town?: boolean\n): false | number | string\nexport function each(\n\tobj: object | IArray,\n\tcallback: EachObjCallback | EachArrayCallback,\n\tscope?: any,\n\town?: boolean\n): false | number | string\nexport function each(obj: any, callback: any, scope?: any, own?: boolean): false | number | string {\n\treturn doEach(eachArray, eachObj, obj, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:54:35 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport {create} from '../create'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool } from '../is'\n\n/**\n * SKIP Control\n * > skip map\n */\nexport const SKIP = new Control('SKIP')\n\n//========================================================================================\n/*                                                                                      *\n *                                    map object                                   *\n *                                                                                      */\n//========================================================================================\n\n/**\n * callback on object\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param value\tproperty value\n * @param prop\tproperty name\n * @param obj\tmap target\n */\nexport type MapObjCallback<T> = (callback: any, prop: string, obj: object) => T | Control\n\nexport function doMapObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\town?: boolean\n): { [key: string]: T }\nexport function doMapObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T }\nexport function doMapObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\tconst copy: { [key: string]: T } = create(null)\n\teach(\n\t\tobj,\n\t\t(value, prop, obj) => {\n\t\t\tconst v = callback(value, prop, obj)\n\t\t\tif (v === STOP) return STOP\n\t\t\tif (v !== SKIP) copy[prop] = v as T\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn copy\n}\n\n/**\n * object: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param obj\t\tmap target\n * @param callback\tcallback\n * @param scope\t\tscope of callback\n * @param own\t\tmap own properties, default: true\n */\nexport function mapObj<T>(obj: object, callback: MapObjCallback<T>, own?: boolean): { [key: string]: T }\nexport function mapObj<T>(obj: object, callback: MapObjCallback<T>, scope?: any, own?: boolean): { [key: string]: T }\nexport function mapObj<T>(obj: object, callback: MapObjCallback<T>, scope?: any, own?: boolean): { [key: string]: T } {\n\treturn doMapObj(eachObj, obj, callback, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     indexof Array                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * callback on array\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param data\titem data\n * @param index\titem index\n * @param array\tmap target\n */\nexport type MapArrayCallback<T> = (data: any, index: number, array: IArray) => T | Control\n\nexport function doMapArray<T>(each: typeof eachArray, array: IArray, callback: MapArrayCallback<T>, scope?: any): T[] {\n\tcallback = bind(callback, scope)\n\tconst copy: T[] = []\n\tlet j = 0\n\teach(array, (data, index, array) => {\n\t\tconst v = callback(data, index, array)\n\t\tif (v === STOP) return STOP\n\t\tif (v !== SKIP) copy[j++] = v as T\n\t})\n\treturn copy\n}\n\n/**\n * array: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param array\t\tmap target\n * @param value\t\tcallback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function mapArray<T>(array: IArray, callback: MapArrayCallback<T>, scope?: any): T[] {\n\treturn doMapArray(eachArray, array, callback, scope)\n}\n\n/**\n * revice array: map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param array\t\tmap target\n * @param value\t\tmap value of callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function rmapArray<T>(array: IArray, callback: MapArrayCallback<T>, scope?: any): T[] {\n\treturn doMapArray(reachArray, array, callback, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       map                                       *\n *                                                                                      */\n//========================================================================================\n\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray,\n\tcallback: MapArrayCallback<T>,\n\tscope?: any\n): any[]\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\town?: boolean\n): { [key: string]: T }\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tcallback: MapObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T }\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function doMap<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: any,\n\tcallback: any,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | any[] {\n\tif (isArrayLike(obj)) return doMapArray(eacharray, obj, callback, scope)\n\treturn doMapObj(eachobj, obj, callback, scope, own)\n}\n\n/**\n * map\n * - will stop map on callback return STOP\n * - will ignore item on callback return SKIP\n * @param obj\t\tmap target\n * @param value\t\tmap value of callback\n * @param scope\t\tscope of callback\n * @param own\t\tmap own properties on object, default: true\n * @return array index or property name or -1\n */\nexport function map<T>(obj: IArray, callback: MapArrayCallback<T>, scope?: any): any[]\nexport function map<T>(obj: object, callback: MapObjCallback<T>, own?: boolean): { [key: string]: T }\nexport function map<T>(obj: object, callback: MapObjCallback<T>, scope?: any, own?: boolean): { [key: string]: T }\nexport function map<T>(\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function map<T>(\n\tobj: object | IArray,\n\tcallback: MapObjCallback<T> | MapArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): { [key: string]: T } | any[]\nexport function map<T>(obj: object | IArray, callback: any, scope?: any, own?: boolean): { [key: string]: T } | T[] {\n\treturn doMap(eachArray, eachObj, obj, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:38:16 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool, isFn, eq } from '../is'\n\nfunction parseCallback(value: any, scope: any) {\n\tif (isFn(value)) return bind(value, scope)\n\treturn function defaultHandler(data, idx, obj) {\n\t\treturn eq(data, value)\n\t}\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                    index of object                                   *\n *                                                                                      */\n//========================================================================================\n\n/**\n * indexOf callback on object\n * - will stop find on callback return STOP\n * @param value\tproperty value\n * @param prop\tproperty name\n * @param obj\t\tindexOf target\n * @return\n * - boolean: is finded\n * - void: find next\n * - STOP: stop find\n */\nexport type IdxOfObjCallback = (value: any, prop: string, obj: object) => boolean | Control | void\n\nexport function doIdxOfObj(each: typeof eachObj, obj: object, value: any, own?: boolean): -1 | string\nexport function doIdxOfObj(each: typeof eachObj, obj: object, value: IdxOfObjCallback, own?: boolean): -1 | string\nexport function doIdxOfObj(\n\teach: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback,\n\tscope?: any,\n\town?: boolean\n): -1 | string\n\nexport function doIdxOfObj(\n\teach: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback | any,\n\tscope?: any,\n\town?: boolean\n): -1 | string {\n\tif (isBool(scope)) {\n\t\town = scope\n\t\tscope = null\n\t}\n\tconst callback: IdxOfObjCallback = parseCallback(value, scope)\n\tlet idx: -1 | string = -1\n\teach(\n\t\tobj,\n\t\t(data, prop, obj) => {\n\t\t\tconst r = callback(data, prop, obj)\n\t\t\tif (r === true) {\n\t\t\t\tidx = prop\n\t\t\t\treturn STOP\n\t\t\t} else if (r === STOP) return r\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn idx\n}\n\n/**\n * object: indexOf\n * - will stop find on callback return STOP\n * @param obj\t\tfind target\n * @param callback\tfind value or callback\n * @param scope\t\tscope of callback\n * @param own\t\tfind own properties, default: true\n * @return property name or -1\n */\nexport function idxOfObj(obj: object, value: any, own?: boolean): -1 | string\nexport function idxOfObj(obj: object, value: IdxOfObjCallback, own?: boolean): -1 | string\nexport function idxOfObj(obj: object, value: IdxOfObjCallback, scope?: any, own?: boolean): -1 | string\nexport function idxOfObj(obj: object, value: IdxOfObjCallback | any, scope?: any, own?: boolean): -1 | string {\n\treturn doIdxOfObj(eachObj, obj, value, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     indexof Array                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * indexOf callback on array\n * - will stop find on callback return STOP\n * @param data\titem data\n * @param index\titem index\n * @param array\tindexOf target\n * @return\n * - boolean: is finded\n * - void: find next\n * - STOP: stop find\n */\nexport type IdxOfArrayCallback = (data: any, index: number, array: IArray) => boolean | Control | void\n\nexport function doIdxOfArray(each: typeof eachArray, array: IArray, value: any): number\nexport function doIdxOfArray(each: typeof eachArray, array: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function doIdxOfArray(\n\teach: typeof eachArray,\n\tarray: IArray,\n\tvalue: IdxOfArrayCallback | any,\n\tscope?: any\n): number {\n\tconst callback: IdxOfArrayCallback = parseCallback(value, scope)\n\tlet idx = -1\n\teach(array, (data, index, array) => {\n\t\tconst r = callback(data, index, array)\n\t\tif (r === true) {\n\t\t\tidx = index\n\t\t\treturn STOP\n\t\t} else if (r === STOP) return r\n\t})\n\treturn idx\n}\n\n/**\n * array: indexOf\n * - will stop find on callback return STOP\n * @param array\t\tfind target\n * @param value\t\tfind value or callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function idxOfArray(array: IArray, value: any): number\nexport function idxOfArray(array: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function idxOfArray(array: IArray, value: IdxOfArrayCallback | any, scope?: any): number {\n\treturn doIdxOfArray(eachArray, array, value, scope)\n}\n\n/**\n * revice array: indexOf\n * - will stop find on callback return STOP\n * @param array\t\tfind target\n * @param value\t\tfind value of callback\n * @param scope\t\tscope of callback\n * @return array index or -1\n */\nexport function ridxOfArray(array: IArray, value: any): number\nexport function ridxOfArray(array: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function ridxOfArray(array: IArray, value: IdxOfArrayCallback | any, scope?: any): number {\n\treturn doIdxOfArray(reachArray, array, value, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       index of                                       *\n *                                                                                      */\n//========================================================================================\n// find by value\nexport function doIdxOf(eacharray: typeof eachArray, eachobj: typeof eachObj, obj: IArray, value: any): number\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tvalue: any,\n\town?: boolean\n): string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tvalue: any,\n\town?: boolean\n): number | string\n// find by callback\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray,\n\tvalue: IdxOfArrayCallback,\n\tscope?: any\n): number\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback,\n\town?: boolean\n): -1 | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\tvalue: IdxOfObjCallback,\n\tscope?: any,\n\town?: boolean\n): -1 | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\town?: boolean\n): number | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\tscope?: any,\n\town?: boolean\n): number | string\nexport function doIdxOf(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: any,\n\tvalue: any,\n\tscope?: any,\n\town?: boolean\n): number | string {\n\tif (isArrayLike(obj)) return doIdxOfArray(eacharray, obj, value, scope)\n\treturn doIdxOfObj(eachobj, obj, value, scope, own)\n}\n\n/**\n * indexOf\n * - will stop find on callback return STOP\n * @param obj\t\tfind target\n * @param value\t\tfind value of callback\n * @param scope\t\tscope of callback\n * @param own\t\tfind own properties on object, default: true\n * @return array index or property name or -1\n */\nexport function idxOf(obj: IArray, value: any): number | string\nexport function idxOf(obj: object, value: any, own?: boolean): number | string\nexport function idxOf(obj: object | IArray, value: any, own?: boolean): number | string\nexport function idxOf(obj: IArray, value: IdxOfArrayCallback, scope?: any): number\nexport function idxOf(obj: object, value: IdxOfObjCallback, own?: boolean): -1 | string\nexport function idxOf(obj: object, value: IdxOfObjCallback, scope?: any, own?: boolean): -1 | string\nexport function idxOf(\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\town?: boolean\n): number | string\nexport function idxOf(\n\tobj: object | IArray,\n\tvalue: IdxOfObjCallback | IdxOfArrayCallback,\n\tscope?: any,\n\town?: boolean\n): number | string\nexport function idxOf(obj: object | IArray, value: any, scope?: any, own?: boolean): number | string {\n\treturn doIdxOf(eachArray, eachObj, obj, value, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 17:12:06 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 14:02:39 GMT+0800 (China Standard Time)\n */\nimport { Control } from './control'\nimport { STOP, eachArray, reachArray, eachObj } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isArrayLike, isBool } from '../is'\n\n//========================================================================================\n/*                                                                                      *\n *                                     reduce object                                    *\n *                                                                                      */\n//========================================================================================\n\n/**\n * reduce callback on object\n * - will stop reduce on return STOP\n */\nexport type ReduceObjCallback<T> = (accumulator: T, value: any, prop: string, obj: object) => T | Control\n\nexport function doReduceObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\town?: boolean\n): T\nexport function doReduceObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduceObj<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\tif (isBool(scope)) {\n\t\town = scope\n\t} else {\n\t\tcallback = bind(callback, scope)\n\t}\n\teach(\n\t\tobj,\n\t\t(value, prop, obj) => {\n\t\t\tconst rs = callback(accumulator, value, prop, obj)\n\t\t\tif (rs === STOP) return STOP\n\t\t\taccumulator = rs as T\n\t\t},\n\t\tnull,\n\t\town\n\t)\n\treturn accumulator\n}\n\n/**\n * reduce object\n * - will stop reduce on callback return STOP\n * @param obj\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n * @param own\t\t\treduce own properties, default: true\n */\nexport function reduceObj<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, own?: boolean)\nexport function reduceObj<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, scope?: any, own?: boolean)\nexport function reduceObj<T>(\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\treturn doReduceObj(eachObj, obj, accumulator, callback, scope, own)\n}\n//========================================================================================\n/*                                                                                      *\n *                                     reduce array                                     *\n *                                                                                      */\n//========================================================================================\n\n/**\n * reduce callback on array\n * - will stop reduce on return STOP\n */\nexport type ReduceArrayCallback<T> = (accumulator: T, data: any, index: number, array: IArray) => T | Control\n\nexport function doReduceArray<T>(\n\teach: typeof eachArray,\n\tarray: IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T>,\n\tscope?: any\n): T {\n\tcallback = bind(callback, scope)\n\teach(array, (data, index, array) => {\n\t\tconst rs = callback(accumulator, data, index, array)\n\t\tif (rs === STOP) return STOP\n\t\taccumulator = rs as T\n\t})\n\treturn accumulator\n}\n\n/**\n * reduce array\n * - will stop reduce on callback return STOP\n * @param array\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n */\nexport function reduceArray<T>(array: IArray, accumulator: T, callback: ReduceArrayCallback<T>, scope?: any): T {\n\treturn doReduceArray(eachArray, array, accumulator, callback, scope)\n}\n\n/**\n * revice reduce array\n * - will stop reduce on callback return STOP\n * @param array\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n */\nexport function rreduceArray<T>(array: IArray, accumulator: T, callback: ReduceArrayCallback<T>, scope?: any): T {\n\treturn doReduceArray(reachArray, array, accumulator, callback, scope)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        reduce                                        *\n *                                                                                      */\n//========================================================================================\n\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T>,\n\tscope?: any\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function doReduce<T>(\n\teacharray: typeof eachArray,\n\teachobj: typeof eachObj,\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T> | ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\tif (isArrayLike(obj))\n\t\treturn doReduceArray(eacharray, obj as IArray, accumulator, callback as ReduceArrayCallback<T>, scope)\n\treturn doReduceObj(eachobj, obj as object, accumulator, callback as ReduceObjCallback<T>, scope, own)\n}\n\n/**\n * reduce\n * - will stop reduce on callback return STOP\n * @param obj\t\t\treduce target\n * @param accumulator\taccumulator\n * @param callback\t\tvalue callback\n * @param scope\t\t\tscope of callback\n * @param own\t\t\treduce own properties of reduce object, default: true\n */\nexport function reduce<T>(obj: IArray, accumulator: T, callback: ReduceArrayCallback<T>, scope?: any): T\nexport function reduce<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, own?: boolean): T\nexport function reduce<T>(obj: object, accumulator: T, callback: ReduceObjCallback<T>, scope?: any, own?: boolean): T\nexport function reduce<T>(\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\town?: boolean\n): T\nexport function reduce<T>(\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceObjCallback<T> | ReduceArrayCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T\nexport function reduce<T>(\n\tobj: object | IArray,\n\taccumulator: T,\n\tcallback: ReduceArrayCallback<T> | ReduceObjCallback<T>,\n\tscope?: any,\n\town?: boolean\n): T {\n\treturn doReduce(eachArray, eachObj, obj, accumulator, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Jul 26 2018 10:47:47 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 13:59:31 GMT+0800 (China Standard Time)\n */\nimport { Control } from './control'\nimport { STOP, eachObj, eachProps } from './each'\nimport { SKIP } from './map'\nimport { isBool, isFn } from '../is'\nimport { bind } from '../fn'\n\n//========================================================================================\n/*                                                                                      *\n *                                         keys                                         *\n *                                                                                      */\n//========================================================================================\n\nexport type ObjKeyHandler<T> = (prop: string, obj: object) => T | Control\n\nfunction defaultObjKeyHandler(prop: string, obj: object): any {\n\treturn prop\n}\nexport function doObjKeys<T>(each: typeof eachProps, obj: object, own?: boolean): T[]\nexport function doObjKeys<T>(each: typeof eachProps, obj: object, callback: ObjKeyHandler<T>, own?: boolean): T[]\nexport function doObjKeys<T>(\n\teach: typeof eachProps,\n\tobj: object,\n\tcallback: ObjKeyHandler<T>,\n\tscope?: any,\n\town?: boolean\n): T[]\nexport function doObjKeys<T>(\n\teach: typeof eachProps,\n\tobj: object,\n\tcallback_own?: ObjKeyHandler<T> | boolean,\n\tscope_own?: any,\n\town?: boolean\n): T[]\nexport function doObjKeys<T>(each: typeof eachProps, obj: object): T[] {\n\tconst rs: T[] = [],\n\t\targs = arguments\n\tlet handler: ObjKeyHandler<T> = defaultObjKeyHandler,\n\t\ti = 2,\n\t\tj = 0\n\tif (isFn(args[i])) {\n\t\thandler = args[i++]\n\t\tif (!isBool(args[i])) handler = bind(handler, args[i++])\n\t}\n\teach(\n\t\tobj,\n\t\t(prop, obj) => {\n\t\t\tconst val = handler(prop, obj)\n\t\t\tif (val === STOP) return STOP\n\t\t\tif (val !== SKIP) rs[j++] = val as T\n\t\t},\n\t\tnull,\n\t\targs[i]\n\t)\n\treturn rs\n}\n\n/**\n * @param obj\t\ttarget\n * @param handler\tkey handler\n * @param scope\t\tscope or handler\n * @param own\t\tis get own properties, default: true\n */\nexport function keys<T>(obj: object, own?: boolean): T[]\nexport function keys<T>(obj: object, callback: ObjKeyHandler<T>, own?: boolean): T[]\nexport function keys<T>(obj: object, callback: ObjKeyHandler<T>, scope?: any, own?: boolean): T[]\nexport function keys<T>(obj: object, callback?: ObjKeyHandler<T> | boolean, scope?: any, own?: boolean): T[] {\n\treturn doObjKeys(eachProps, obj, callback, scope, own)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        values                                        *\n *                                                                                      */\n//========================================================================================\n\nexport type ObjValueHandler<T> = (value: any, prop: string, obj: object) => T | Control\n\nfunction defaultObjValueHandler(value: any, prop: string, obj: object): any {\n\treturn value\n}\nexport function doObjValues<T>(each: typeof eachObj, obj: object, own?: boolean): T[]\nexport function doObjValues<T>(each: typeof eachObj, obj: object, callback: ObjValueHandler<T>, own?: boolean): T[]\nexport function doObjValues<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback: ObjValueHandler<T>,\n\tscope?: any,\n\town?: boolean\n): T[]\nexport function doObjValues<T>(\n\teach: typeof eachObj,\n\tobj: object,\n\tcallback_own?: ObjValueHandler<T> | boolean,\n\tscope_own?: any,\n\town?: boolean\n): T[]\nexport function doObjValues<T>(each: typeof eachObj, obj: object): T[] {\n\tconst rs: T[] = [],\n\t\targs = arguments\n\tlet handler: ObjValueHandler<T> = defaultObjValueHandler,\n\t\ti = 1,\n\t\tj = 0\n\tif (isFn(args[i])) {\n\t\thandler = args[i++]\n\t\tif (!isBool(args[i])) handler = bind(handler, args[i++])\n\t}\n\teach(\n\t\tobj,\n\t\tfunction(data, prop, obj) {\n\t\t\tconst val = handler(data, prop, obj)\n\t\t\tif (val === STOP) return STOP\n\t\t\tif (val !== SKIP) rs[j++] = val as T\n\t\t},\n\t\tnull,\n\t\targs[i]\n\t)\n\treturn rs\n}\n\n/**\n * @param obj\t\ttarget\n * @param handler\tvalue handler\n * @param scope\t\tscope or handler\n * @param own\t\tis get own properties, default: true\n */\nexport function values<T>(obj: object, own?: boolean): T[]\nexport function values<T>(obj: object, callback: ObjValueHandler<T>, own?: boolean): T[]\nexport function values<T>(obj: object, callback: ObjValueHandler<T>, scope?: any, own?: boolean): T[]\nexport function values<T>(obj: object, callback?: ObjValueHandler<T> | boolean, scope?: any, own?: boolean): T[] {\n\treturn doObjValues(eachObj, obj, callback, scope, own)\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Fri Nov 16 2018 16:29:04 GMT+0800 (China Standard Time)\n * @modified Fri Nov 30 2018 17:42:28 GMT+0800 (China Standard Time)\n */\n\nimport { Control } from './control'\nimport { eachArray } from './each'\nimport { IArray } from '../consts'\nimport { bind } from '../fn'\nimport { isFn, isStr, isArray } from '../is'\nimport {create} from '../create'\n\n/**\n * @return STOP or SKIP or [key: string, value: any]\n */\nexport type Arr2ObjCallback = (data: any, index: number, array: IArray) => Control | [string, any]\n\nexport function doArr2Obj(each: typeof eachArray, array: IArray, callback: Arr2ObjCallback, scope?: any): object {\n\tconst obj = create(null)\n\tcallback = bind(callback, scope)\n\teach(array, (data, index, array) => {\n\t\tconst r: Control | [string, any] = callback(data, index, array)\n\t\tif (isArray(r)) {\n\t\t\tobj[r[0]] = r[1]\n\t\t} else {\n\t\t\treturn r as Control\n\t\t}\n\t})\n\treturn obj\n}\n\n/**\n * convert array to object\n */\nexport function arr2obj(array: IArray, callback: Arr2ObjCallback, scope?: any): object {\n\treturn doArr2Obj(eachArray, array, callback, scope)\n}\n\n/**\n * convert array or string to object\n * @param array\n * @param val\tvalue or callback\n * @param split\tsplit char on string\n */\nexport function makeMap(array: IArray, val: Arr2ObjCallback, split?: string): object\nexport function makeMap(array: IArray, val?: any, split?: string): object\nexport function makeMap(array: IArray, val?: any, split?: string): object {\n\tif (isStr(array)) array = (array as string).split(isStr(split) ? split : ',')\n\treturn arr2obj(array, isFn(val) ? val : data => [data, val])\n}\n","/**\n * @module utility/collection\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Thu Nov 15 2018 12:13:54 GMT+0800 (China Standard Time)\n * @modified Tue Dec 04 2018 20:10:32 GMT+0800 (China Standard Time)\n */\n\nexport { STOP, eachProps, eachArray, eachObj, each } from './each'\nexport { SKIP, mapArray, mapObj, map } from './map'\nexport { idxOfArray, idxOfObj, idxOf } from './idxOf'\nexport { reduceArray, reduceObj, reduce } from './reduce'\nexport { keys, values } from './obj2arr'\nexport { arr2obj, makeMap } from './arr2obj'\nexport function makeArray<T>(len: number, callback: (index: number) => T): T[] {\n\tconst array = new Array(len)\n\tlet i = len\n\twhile (i--) array[i] = callback(i)\n\treturn array\n}\n","/**\n * @module utility/prop\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Fri Nov 30 2018 14:41:02 GMT+0800 (China Standard Time)\n * @modified Mon Dec 10 2018 16:59:08 GMT+0800 (China Standard Time)\n */\n\nimport {create} from './create'\nimport { isArray } from './is'\nimport { mapArray } from './collection'\n\nconst pathCache: { [key: string]: string[] } = create(null)\n\n// prop | [index | \"string prop\" | 'string prop']\nconst pathReg = /(?:^|\\.)([a-zA-Z$_][\\w$]*)|\\[\\s*(?:(\\d+)|\"((?:[^\\\\\"]|\\\\.)*)\"|'((?:[^\\\\']|\\\\.)*)')\\s*\\]/g\n\nexport function parsePath(path: string | string[], cacheable?: boolean): string[]\nexport function parsePath(path, cacheable) {\n\tif (isArray(path)) return path\n\n\tlet array = pathCache[path]\n\tif (!array) {\n\t\tarray = []\n\t\tvar match,\n\t\t\tidx = 0,\n\t\t\tcidx,\n\t\t\ti = 0\n\t\twhile ((match = pathReg.exec(path))) {\n\t\t\tcidx = pathReg.lastIndex\n\t\t\tif (cidx !== idx + match[0].length) {\n\t\t\t\tthrow new SyntaxError(`Invalid Path: \"${path}\", unkown character[${path.charAt(idx)}] at offset:${idx}`)\n\t\t\t}\n\t\t\tarray[i++] = match[1] || match[2] || match[3] || match[4]\n\t\t\tidx = cidx\n\t\t}\n\t\tif (cacheable === false) return array\n\t\tpathCache[path] = array\n\t}\n\treturn array.slice()\n}\n\nexport function formatPath(path: string | string[]): string {\n\treturn isArray(path) ? mapArray(path, formatPathHandler).join('') : (path as string)\n}\n\nfunction formatPathHandler(prop: string): string {\n\treturn `[\"${String(prop).replace(\"'\", '\\\\\"')}\"]`\n}\n\nexport function get(obj, path) {\n\tpath = parsePath(path)\n\tconst l = path.length - 1\n\tif (l === -1) return obj\n\tlet i = 0\n\tfor (; i < l; i++) {\n\t\tobj = obj[path[i]]\n\t\tif (obj === null || obj === undefined) return undefined\n\t}\n\treturn obj ? obj[path[i]] : undefined\n}\n\nexport function set(obj, path, value) {\n\tpath = parsePath(path)\n\tconst l = path.length - 1\n\tif (l === -1) return\n\tlet attr,\n\t\tv,\n\t\ti = 0\n\tfor (; i < l; i++) {\n\t\tattr = path[i]\n\t\tv = obj[attr]\n\t\tif (!v) obj[attr] = v = {}\n\t\tobj = v\n\t}\n\tattr = path[i]\n\tobj[attr] = value\n}\n","/**\n * String utilities\n * @module utility/string\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 13:57:32 GMT+0800 (China Standard Time)\n * @modified Sat Dec 08 2018 16:16:42 GMT+0800 (China Standard Time)\n */\nimport { createFn } from './fn'\nimport { isNil, isFn, isNum } from './is'\nimport { get } from './propPath'\nimport {create} from './create'\n\n//========================================================================================\n/*                                                                                      *\n *                                       char code                                      *\n *                                                                                      */\n//========================================================================================\n\n/**\n * get char code\n * > string.charCodeAt\n */\nexport function charCode(str: string, index?: number): number {\n\treturn str.charCodeAt(index || 0)\n}\n\n/**\n * get char by char code\n * > String.fromCharCode\n */\nexport function char(code: number): string {\n\treturn String.fromCharCode(code)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         trim                                         *\n *                                                                                      */\n//========================================================================================\n\nconst TRIM_REG = /(^\\s+)|(\\s+$)/g\n\n/**\n * trim\n */\nexport function trim(str: string): string {\n\treturn str.replace(TRIM_REG, '')\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                         case                                         *\n *                                                                                      */\n//========================================================================================\n\nconst FIRST_LOWER_LETTER_REG = /^[a-z]/\n\n/**\n * upper first char\n */\nexport function upperFirst(str: string): string {\n\treturn str.replace(FIRST_LOWER_LETTER_REG, upper)\n}\n\nexport function upper(m: string): string {\n\treturn m.toUpperCase()\n}\n\nexport function lower(m: string): string {\n\treturn m.toLowerCase()\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                  parse string value                                  *\n *                                                                                      */\n//========================================================================================\n\n/**\n * convert any value to string\n * - undefined | null: ''\n * - NaN:\n * - Infinity:\n * - other: String(value)\n * TODO support NaN, Infinity\n */\nexport function strval(obj: any): string {\n\treturn isNil(obj) ? '' : String(obj)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        escape                                        *\n *                                                                                      */\n//========================================================================================\n\nconst STR_ESCAPE_MAP = {\n\t\t'\\n': '\\\\n',\n\t\t'\\t': '\\\\t',\n\t\t'\\f': '\\\\f',\n\t\t'\"': '\\\\\"',\n\t\t\"'\": \"\\\\'\"\n\t},\n\tSTR_ESCAPE = /[\\n\\t\\f\"']/g\n\nexport function escapeStr(str: string): string {\n\treturn str.replace(STR_ESCAPE, str => STR_ESCAPE_MAP[str])\n}\n","/**\n * @module utility/format\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 03 2018 19:46:41 GMT+0800 (China Standard Time)\n * @modified Mon Dec 17 2018 19:24:20 GMT+0800 (China Standard Time)\n */\n\nimport { createFn } from './fn'\nimport { isFn } from './is'\nimport { get, parsePath } from './propPath'\nimport { create } from './create'\nimport { charCode, upper, escapeStr } from './string'\n\n//========================================================================================\n/*                                                                                      *\n *                                       pad & cut                                      *\n *                                                                                      */\n//========================================================================================\n\nexport function pad(str: string, len: number, chr?: string, leftAlign?: boolean | number): string {\n\treturn len > str.length ? __pad(str, len, chr, leftAlign) : str\n}\n\nexport function cut(str: string, len: number, suffix?: string): string {\n\treturn len < str.length ? ((suffix = suffix || ''), str.substr(0, len - suffix.length) + suffix) : str\n}\n\nfunction __pad(str: string, len: number, chr: string, leftAlign: boolean | number): string {\n\tconst padding = new Array(len - str.length + 1).join(chr || ' ')\n\treturn leftAlign ? str + padding : padding + str\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       Separator                                      *\n *                                                                                      */\n//========================================================================================\n\nexport const thousandSeparate = mkSeparator(3),\n\tbinarySeparate = mkSeparator(8, '01'),\n\toctalSeparate = mkSeparator(4, '0-7'),\n\thexSeparate = mkSeparator(4, '\\\\da-fA-F')\n\nfunction mkSeparator(group: number, valReg?: string): (numStr: string) => string {\n\tvalReg = valReg || '\\\\d'\n\tconst reg = new RegExp(\n\t\t`^(?:[+-]|\\\\s+|0[xXbBoO])|([${valReg}])(?=([${valReg}]{${group}})+(?![${valReg}]))|[^${valReg}].*`,\n\t\t'g'\n\t)\n\treturn numStr => numStr.replace(reg, separatorHandler)\n}\nfunction separatorHandler(m, d) {\n\treturn d ? d + ',' : m\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                   plural & singular                                  *\n *                                                                                      */\n//========================================================================================\n\nconst PLURAL_REG = /([a-zA-Z]+)([^aeiou])y$|([sxzh])$|([aeiou]y)$|([^sxzhy])$/\nexport function plural(str: string): string {\n\treturn str.replace(PLURAL_REG, pluralHandler)\n}\nfunction pluralHandler(m, v, ies, es, ys, s) {\n\treturn v + (ies ? ies + 'ies' : es ? es + 'es' : (ys || s) + 's')\n}\n\nconst SINGULAR_REG = /([a-zA-Z]+)([^aeiou])ies$|([sxzh])es$|([aeiou]y)s$|([^sxzhy])s$/\nexport function singular(str: string): string {\n\treturn str.replace(SINGULAR_REG, singularHandler)\n}\nfunction singularHandler(m, v, ies, es, ys, s) {\n\treturn v + (ies ? ies + 'y' : es || ys || s)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                     format flags                                     *\n *                                                                                      */\n//========================================================================================\n\ntype FormatFlags = number\n\nexport const FORMAT_XPREFIX: FormatFlags = 0x1\nexport const FORMAT_PLUS: FormatFlags = 0x2\nexport const FORMAT_ZERO: FormatFlags = 0x4\nexport const FORMAT_SPACE: FormatFlags = 0x8\nexport const FORMAT_SEPARATOR: FormatFlags = 0x10\nexport const FORMAT_LEFT: FormatFlags = 0x20\n\nconst FLAG_MAPPING = {\n\t'#': FORMAT_XPREFIX,\n\t'+': FORMAT_PLUS,\n\t'0': FORMAT_ZERO,\n\t' ': FORMAT_SPACE,\n\t',': FORMAT_SEPARATOR,\n\t'-': FORMAT_LEFT\n}\nfunction parseFlags(f: string): FormatFlags {\n\tlet flags: FormatFlags = 0\n\tif (f) {\n\t\tvar i = f.length\n\t\twhile (i--) flags |= FLAG_MAPPING[f.charAt(i)]\n\t}\n\treturn flags\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                      format Rule                                     *\n *                                                                                      */\n//========================================================================================\n\n//   0      1      2     3     4       5       6           7         8      9           10             11             12        13\n// [match, expr, index, prop, flags, width, width-idx, width-prop, fill, precision, precision-idx, precision-prop, cut-suffix, type]\nconst paramIdxR = `(\\\\d+|\\\\$|@)`,\n\tparamPropR = `(?:\\\\{((?:[a-zA-Z$_][\\\\w$_]*|\\\\[(?:\\\\d+|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)*\"|'(?:[^\\\\\\\\']|\\\\\\\\.)*')\\\\])(?:\\\\.[a-zA-Z$_][\\\\w$_]*|\\\\[(?:\\\\d+|\"(?:[^\\\\\\\\\"]|\\\\\\\\.)*\"|'(?:[^\\\\\\\\']|\\\\\\\\.)*')\\\\])*)\\\\})`,\n\twidthR = `(?:([1-9]\\\\d*)|&${paramIdxR}${paramPropR})`,\n\tfillR = `(?:=(.))`,\n\tcutSuffixR = `(?:=\"((?:[^\\\\\\\\\"]|\\\\\\\\.)*)\")`,\n\tformatReg = new RegExp(\n\t\t`\\\\\\\\.|(\\\\{${paramIdxR}?${paramPropR}?(?::([#,+\\\\- 0]*)(?:${widthR}${fillR}?)?(?:\\\\.${widthR}${cutSuffixR}?)?)?([a-zA-Z_][a-zA-Z0-9_$]*)?\\\\})`,\n\t\t'g'\n\t)\n\n//========================================================================================\n/*                                                                                      *\n *                                      Formatters                                      *\n *                                                                                      */\n//========================================================================================\n\ntype FormatCallback = (\n\tval: any,\n\tflags: FormatFlags,\n\twidth: number,\n\tfill: string,\n\tprecision: number,\n\tcutSuffix: string\n) => string\n\nconst formatters: {\n\t[k: string]: FormatCallback\n} = create(null)\n\nexport function extendFormatter(obj: { [key: string]: FormatCallback }) {\n\tvar fmt, name\n\tfor (name in obj) {\n\t\tfmt = obj[name]\n\t\tisFn(fmt) && (formatters[name] = fmt)\n\t}\n}\n\nexport function getFormatter(name: string): FormatCallback {\n\tconst f = formatters[name || 's']\n\tif (f) return f\n\tthrow new Error(`Invalid Formatter: ${name}`)\n}\n\n//========================================================================================\n/*                                                                                      *\n *                           format by every parameter object                           *\n *                                                                                      */\n//========================================================================================\n\n/**\n * Syntax:\n * @example\n * \t'{'\n * \t\t(<parameter>)?\n * \t\t(\n * \t\t\t':'\n * \t\t\t(<flags>)?\n * \t\t\t(\n * \t\t\t\t<width> ('=' <fill-char>)?\n * \t\t\t)?\n * \t\t\t(\n * \t\t\t\t'.'\n * \t\t\t\t<precision> ('=' '\"' <cut-suffix> '\"')?\n * \t\t\t)?\n * \t\t)?\n * \t\t(<type>)?\n * \t'}'\n *\n * - parameter\n * \t\t- {}\t\t\t\t\tformat by next unused argument\n * \t\t- {<number>}\t\t\tformat by arguments[number]\n * \t\t- {@}\t\t\t\t\tformat by current used argument\n * \t\t- {$}\t\t\t\t\tformat by next unused argument\n * \t\t- {{name}}\t\t\t\tformat by \"name\" property on next unused argument\n * \t\t- {<number>{name}}\t\tformat by \"name\" property on arguments[number]\n * \t\t- {@{name}}\t\t\t\tformat by \"name\" property on current used argument\n * \t\t- {${name}}\t\t\t\tformat by \"name\" property on next unused argument\n * @example\n * \t\tformat('<{} {}>', 'abc')\t\t\t\t// return \"<abc undefined>\"\n * \t\tformat('<{$} {$}>', 'abc')\t\t\t\t// return \"<abc undefined>\"\n * \t\tformat('<{@} {} {@}>', 'abc')\t\t\t// return \"<abc abc abc>\"\n * \t\tformat('<{0} {} {0}>', 'abc')\t\t\t// return \"<abc abc abc>\"\n * \t\tformat('<{0{value}} {${value}} {@{value}} {{value.a}}>', {value: 'abc'}, {value: {a: 'cbd'}})\n * \t\t// return \"<abc abc abc bcd>\"\n * \t\tformat('<{0{[0]}} {${[0]}} {@{[0]}} {{[0].a}}>', ['abc'], [{a: 'cbd'}])\n * \t\t// return \"<abc abc abc bcd>\"\n *\n * - flags\n * \t\t- {:#}    \tFORMAT_XPREFIX\n * \t\t\t\t\tensure the leading \"0\" for any octal\n * \t\t\t\t\tprefix non-zero hexadecimal with \"0x\" or \"0X\"\n * \t\t\t\t\tprefix non-zero binary with \"0b\" or \"0B\"\n * \t\t- {:+}    \tFORMAT_PLUS\n * \t\t\t\t\tForces to preceed the result with a plus or minus sign (+ or -) even for positive numbers.\n * \t\t\t\t\tBy default, only negative numbers are preceded with a - sign\n * \t\t- {:0}\t\tFORMAT_ZERO\n * \t\t\t\t\tLeft-pads the number with zeroes (0) instead of spaces when padding is specified\n * \t\t- {: }   \tFORMAT_SPACE\n * \t\t\t\t\tIf no sign is going to be written, a blank space is inserted before the value\n * \t\t- {:,}\t\tFORMAT_SEPARATOR\n * \t\t\t\t\tuse thousand separator on decimal number\n * \t\t\t\t\thexadecimal number: FFFFFFFF => FFFF,FFFF\n * \t\t\t\t\toctal number: 77777777 => 7777,7777\n * \t\t\t\t\tbinary number: 1111111111111111 => 11111111,11111111\n * \t\t{:-}    \tFORMAT_LEFT\n * \t\t\t\t\tLeft-justify within the given field width; Right justification is the default\n * @example\n * \t\tformat('<{: d}>',  12);\t\t// return \"< 12>\"\n *\t\tformat('<{: d}>',   0);\t\t// return \"< 0>\"\n *\t\tformat('<{: d}>', -12);\t\t// return \"<-12>\"\n *\t\tformat('<{:+d}>',  12);\t\t// return \"<+12>\"\n *\t\tformat('<{:+d}>',   0);\t\t// return \"<+0>\"\n *\t\tformat('<{:+d}>', -12);\t\t// return \"<-12>\"\n *\t\tformat('<{:6s}>',  12);\t\t// return \"<    12>\"\n *\t\tformat('<{:-6s}>', 12);\t\t// return \"<12    >\"\n *\t\tformat('<{:#o}>',  12);\t\t// return \"<014>\"\n *\t\tformat('<{:#x}>',  12);\t\t// return \"<0xc>\"\n *\t\tformat('<{:#X}>',  12);\t\t// return \"<0XC>\"\n *\t\tformat('<{:#b}>',  12);\t\t// return \"<0b1100>\"\n *\t\tformat('<{:#B}>',  12);\t\t// return \"<0B1100>\"\n\n * - width\n * \t\tMinimum number of characters to be printed.\n * \t\tIf the value to be printed is shorter than this number, the result is padded with pad char(default is space).\n * \t\tThe value is not truncated even if the result is larger.\n *\t\t- width value\n * \t\t\t{:<number>}\n * \t\t\t{:&@}\n * \t\t\t{:&$}\n * \t\t\t{:&<number>}\n * \t\t\t{:&@{<prop>}}\n * \t\t\t{:&${<prop>}}\n * \t\t\t{:&<number>{<prop>}}\n *\t\t- pad char\n * \t\t\t{:&@=<pad-char>}\n * \t\t\t{:&$=<pad-char>}\n * \t\t\t{:&<number>=<pad-char>}\n * \t\t\t{:&@{<prop>}=<pad-char>}\n * \t\t\t{:&${<prop>}=<pad-char>}\n * \t\t\t{:&<number>{<prop>}=<pad-char>}\n * @example\n *\n * - precision\n * \t\tFor integer specifiers (d,  o, u, x, X): precision specifies the minimum number of digits to be written.\n * \t\tIf the value to be written is shorter than this number, the result is padded with leading zeros.\n * \t\tThe value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0.\n * \t\tFor a, A, e, E, f and F specifiers: this is the number of digits to be printed after the decimal point (by default, this is 6).\n * \t\tFor g and G specifiers: This is the maximum number of significant digits to be printed.\n * \t\tFor s: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered.\n * \t\tIf the period is specified without an explicit value for precision, 0 is assumed.\n * \t\t- precision value\n * \t\t\t{:.<number>}\n * \t\t\t{:.&@}\n * \t\t\t{:.&$}\n * \t\t\t{:.&<number>}\n * \t\t\t{:.&@{<prop>}}\n * \t\t\t{:.&${<prop>}}\n * \t\t\t{:.&<number>{<prop>}}\n * \t\t- cut suffix\n * \t\t\t{:.&@=\"<suffix>\"}\n * \t\t\t{:.&$=\"<suffix>\"}\n * \t\t\t{:.&<number>=\"<suffix>\"}\n * \t\t\t{:.&@{<prop>}=\"<suffix>\"}\n * \t\t\t{:.&${<prop>}=\"<suffix>\"}\n * \t\t\t{:.&<number>{<prop>}=\"<suffix>\"}\n * - type\n * \t\t- default types\n *\t\t\t- {c}\t\tCharacter\n * \t\t\t- {s}\t\tString\n * \t\t\t- {j}\t\tJSON String\n * \t\t\t- {y}\t\tDate Year\n * \t\t\t- {m}\t\tDate Month\n * \t\t\t- {w}\t\tDate Weekly\n * \t\t\t- {W}\t\tDate Weekly\n * \t\t\t- {D}\t\tDate\n * \t\t\t- {H}\t\tDate\n * \t\t\t- {M}\t\tDate\n * \t\t\t- {S}\t\tDate\n * \t\t\t- {d} \t\tSigned decimal integer\n *\t\t\t- {u}\t\tUnsigned decimal integer\n *\t\t\t- {o}\t\tUnsigned octal\n *\t\t\t- {x}\t\tUnsigned hexadecimal integer\n *\t\t\t- {X}\t\tUnsigned hexadecimal integer (uppercase)\n *\t\t\t- {f}\t\tDecimal floating point, lowercase,\n *\t\t\t- {e}\t\tScientific notation (mantissa/exponent), lowercase\n *\t\t\t- {E}\t\tScientific notation (mantissa/exponent), uppercase\n *\t\t\t- {g}\t\tUse the shortest representation: %e or %f\n *\t\t\t- {G}\t\tUse the shortest representation: %E or %F\n * - Rules\n * \t\t- property-path\n * \t\t\t\t(\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t[a-zA-Z$_][\\w$_]*|\n * \t\t\t\t\t\t\\[\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\\d+|\n * \t\t\t\t\t\t\t\"(?:[^\\\\\"]|\\\\.)*\"|\n * \t\t\t\t\t\t\t'(?:[^\\\\']|\\\\.)*'\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t\\]\n * \t\t\t\t\t)\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t\\.[a-zA-Z$_][\\w$_]*|\n * \t\t\t\t\t\t\\[\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\\d+|\n * \t\t\t\t\t\t\t\"(?:[^\\\\\"]|\\\\.)*\"|\n * \t\t\t\t\t\t\t'(?:[^\\\\']|\\\\.)*'\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t\\]\n * \t\t\t\t\t)*\n * \t\t\t\t)\n * \t\t- expression\n * \t\t\t/\\\\.|\t\t\t\t\t\t\t\t\t\t\t\t// escape\n * \t\t\t(\t\t\t\t\t\t\t\t\t\t\t\t\t// 1: expression\n * \t\t\t\t\\{\n * \t\t\t\t(\\d+|\\$|@)?\t\t\t\t\t\t\t\t\t\t// 2: parameter index\n * \t\t\t\t(?:\\{<property-path>\\})?\t\t\t\t\t\t// 3: property path of parameter\n * \t\t\t\t(?:\n * \t\t\t\t\t:\n * \t\t\t\t\t([#,+\\- ]*)\t\t\t\t\t\t\t\t\t// 4: flags\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t(\\d+)|\t\t\t\t\t\t\t\t// 5: width\n * \t\t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\t&\n * \t\t\t\t\t\t\t\t(\\d+|\\$|@)\t\t\t\t\t\t// 6: parameter index of width\n * \t\t\t\t\t\t\t\t(?:\\{<property-path>\\})?\t\t// 7: property path of width parameter\n * \t\t\t\t\t\t\t)\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t(?:=(.))?\t\t\t\t\t\t\t\t// 8: pad fill\n * \t\t\t\t\t)?\n * \t\t\t\t\t(?:\n * \t\t\t\t\t\t\\.\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t(\\d+)|\t\t\t\t\t\t\t\t// 9: width\n * \t\t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t\t&\n * \t\t\t\t\t\t\t\t(\\d+|\\$|@)\t\t\t\t\t\t// 10: parameter index of width\n * \t\t\t\t\t\t\t\t(?:\\{<property-path>\\})?\t\t// 11: property path of width parameter\n * \t\t\t\t\t\t\t)\n * \t\t\t\t\t\t)\n * \t\t\t\t\t\t(?:\n * \t\t\t\t\t\t\t=\n * \t\t\t\t\t\t\t\"\n * \t\t\t\t\t\t\t((?:[^\\\\\"]|\\\\.)*)\t\t\t\t\t// 12: cut su\n * \t\t\t\t\t\t\t\"\n * \t\t\t\t\t\t)\n * \t\t\t\t\t)?\n * \t\t\t\t)?\n * \t\t\t\t([a-zA-Z_][a-zA-Z0-9_$]*)?\t\t\t\t\t\t// 13: data type\n * \t\t\t\t\\}\n * \t\t\t)/\n * @param fmt \t\tformat String\n * @param args\t\tformat arguments\n * @param offset\tstart offset of arguments\n * @param getParam\tget parameter on arguments callback\n */\nexport function vformat<T>(fmt: string, args: T, offset?: number, getParam?: (args: T, idx: number) => any): string {\n\toffset = offset || 0\n\tconst start = offset\n\tgetParam = getParam || defaultGetParam\n\treturn fmt.replace(formatReg, function(\n\t\ts,\n\t\tm,\n\t\tparam,\n\t\tparamProp,\n\t\tflags,\n\t\twidth,\n\t\twidx,\n\t\twprop,\n\t\tfill,\n\t\tprecision,\n\t\tpidx,\n\t\tpprop,\n\t\tcutSuffix,\n\t\ttype\n\t) {\n\t\tif (!m) return s.charAt(1)\n\t\treturn getFormatter(type)(\n\t\t\tparseParam(param || '$', paramProp),\n\t\t\tparseFlags(flags),\n\t\t\tparseWidth(width, widx, wprop) || 0,\n\t\t\tfill,\n\t\t\tparseWidth(precision, pidx, pprop),\n\t\t\tcutSuffix\n\t\t)\n\t})\n\n\tfunction parseWidth<T>(width: string, idx: string, prop: string): number {\n\t\tif (width) return (width as any) >> 0\n\t\tif (idx) {\n\t\t\tconst w = parseParam(idx, prop) >> 0\n\t\t\tif (isFinite(w)) return w\n\t\t}\n\t}\n\n\tfunction parseParam<T>(paramIdx: string, prop: string): any {\n\t\tlet param = getParam(\n\t\t\targs,\n\t\t\tparamIdx === '$'\n\t\t\t\t? offset++\n\t\t\t\t: paramIdx === '@'\n\t\t\t\t? offset === start\n\t\t\t\t\t? offset\n\t\t\t\t\t: offset - 1\n\t\t\t\t: (paramIdx as any) >> 0\n\t\t)\n\t\treturn prop ? get(param, prop) : param\n\t}\n}\n\nfunction defaultGetParam(args: any, idx: number) {\n\treturn args[idx]\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                        format                                        *\n *                                                                                      */\n//========================================================================================\n\n/**\n * @see vformat\n * @param fmt\tformat string\n * @param args\tformat arguments\n */\nexport function format(fmt: string, ...args: any): string\nexport function format(fmt: string): string {\n\treturn vformat(fmt, arguments, 0, getFormatParam)\n}\n\nfunction getFormatParam(args: IArguments, idx: number) {\n\treturn args[idx + 1]\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                       formatter                                      *\n *                                                                                      */\n//========================================================================================\n\nconst GET_PARAM_VAR = 'getp',\n\tGET_PROP_VAR = 'get',\n\tSTATE_VAR = 'state'\nfunction createFormatter(m: string[], getParam?: (args: IArguments, idx: number) => any) {\n\treturn createFn(\n\t\t`return function(args, ${STATE_VAR}){\nreturn fmt(${getParamCode(m[2] || '$', m[3])},\n\"${parseFlags(m[4])}\",\n${getWidthCode(m[5], m[6], m[7], '0')},\n\"${m[8] ? escapeStr(m[8]) : ' '}\",\n${getWidthCode(m[9], m[10], m[11], 'void 0')},\n\"${m[12] ? escapeStr(m[12]) : ''}\");\n}`,\n\t\t['fmt', GET_PROP_VAR, GET_PARAM_VAR]\n\t)(getFormatter(m[13]), get, getParam)\n}\n\nfunction getWidthCode(width: string, idx: string, prop: string, def: string): string {\n\treturn width ? width : idx ? getParamCode(idx, prop) : def\n}\n\nfunction getParamCode(idx: string, prop: string): string {\n\tlet code = `${GET_PARAM_VAR}(args, ${\n\t\tidx === '$'\n\t\t\t? `${STATE_VAR}[0]++`\n\t\t\t: idx === '@'\n\t\t\t? `${STATE_VAR}[0] === ${STATE_VAR}[1] ? ${STATE_VAR}[0] : ${STATE_VAR}[0] - 1`\n\t\t\t: idx\n\t})`\n\tif (prop) {\n\t\tconst path = parsePath(prop)\n\t\tvar i = path.length\n\t\twhile (i--) path[i] = `\"${escapeStr(path[i])}\"`\n\t\treturn `${GET_PROP_VAR}(${code}, [${path.join(', ')}])`\n\t}\n\treturn code\n}\n/**\n * @see vformat\n * @param fmt\t\tformat string\n * @param offset\tstart offset of arguments\n * @param getParam\tget parameter on arguments callback\n */\nexport function formatter(\n\tfmt: string,\n\toffset?: number,\n\tgetParam?: (args: IArguments, idx: number) => any\n): (...args: any[]) => string {\n\tlet m,\n\t\tlastIdx = 0,\n\t\tmStart,\n\t\tmEnd,\n\t\tarr = [],\n\t\tcodes = [],\n\t\ti = 0\n\toffset = offset || 0\n\twhile ((m = formatReg.exec(fmt))) {\n\t\tmEnd = formatReg.lastIndex\n\t\tmStart = mEnd - m[0].length\n\t\tlastIdx < mStart && pushStr(fmt.substring(lastIdx, mStart), 0)\n\t\tif (m[1]) {\n\t\t\tcodes[i] = `arr[${i}](arguments, ${STATE_VAR})`\n\t\t\tarr[i++] = createFormatter(m, getParam || defaultGetParam)\n\t\t} else {\n\t\t\tpushStr(m[0].charAt(1), i)\n\t\t}\n\t\tlastIdx = mEnd\n\t}\n\tlastIdx < fmt.length && pushStr(fmt.substring(lastIdx), i)\n\treturn createFn(`return function(){var ${STATE_VAR} = [${offset}, ${offset}]; return ${codes.join(' + ')}}`, [\n\t\t'arr'\n\t])(arr)\n\n\tfunction pushStr(str, append) {\n\t\tif (append && arr[i - 1].match) {\n\t\t\tarr[i - 1] += str\n\t\t} else {\n\t\t\tcodes[i] = `arr[${i}]`\n\t\t\tarr[i++] = str\n\t\t}\n\t}\n}\n/*\nsetTimeout(() => {\n\tvar f,\n\t\tn = 100000\n\tconsole.time()\n\tfor (var i = 0; i < n; i++) {\n\t\tf = formatter(`{:.10=\"...\"}`)\n\t}\n\tconsole.timeEnd()\n\tconsole.time()\n\tfor (var i = 0; i < n; i++) {\n\t\tf('abbdddded')\n\t}\n\tconsole.timeEnd()\n\tconsole.time()\n\tfor (var i = 0; i < n; i++) {\n\t\tformat(`{:.10=\"...\"}`, 'abbdddded')\n\t}\n\tconsole.timeEnd()\n\tconsole.log(formatter(`{:.10=\"...\"}`).toString())\n}) */\n//========================================================================================\n/*                                                                                      *\n *                                  default formatters                                  *\n *                                                                                      */\n//========================================================================================\n\nfunction strFormatter(toStr: (val: any, flags: FormatFlags) => string): FormatCallback {\n\treturn function(val, flags, width, fill, precision, cutSuffix) {\n\t\tconst str = toStr(val, flags)\n\t\treturn width > str.length ? __pad(str, width, fill, flags & FORMAT_LEFT) : cut(str, precision, cutSuffix)\n\t}\n}\n\nfunction numFormatter(\n\tparseNum: (val: any) => number,\n\tgetPrefix: (num: number, flags: FormatFlags) => string,\n\ttoStr: (num: number, flags: FormatFlags, precision: number) => string,\n\tseparator: (numStr: string) => string\n): FormatCallback {\n\treturn function(val, flags, width, fill, precision) {\n\t\tconst num = parseNum(val)\n\t\tif (!isFinite(num)) return String(num)\n\n\t\tconst prefix = getPrefix(num, flags),\n\t\t\tplen = prefix.length\n\t\tlet str = toStr(num < 0 ? -num : num, flags, precision)\n\n\t\treturn flags & FORMAT_ZERO\n\t\t\t? ((str = prefix + pad(str, width - plen, '0')), flags & FORMAT_SEPARATOR ? separator(str) : str)\n\t\t\t: (flags & FORMAT_SEPARATOR && (str = separator(str)), pad(prefix + str, width, fill, flags & FORMAT_LEFT))\n\t}\n}\n\nfunction decimalPrefix(num: number, flags: FormatFlags): string {\n\treturn num < 0 ? '-' : flags & FORMAT_PLUS ? '+' : flags & FORMAT_SPACE ? ' ' : ''\n}\n\n// base formatter \nconst BASE_RADIXS = {\n\tb: [2, binarySeparate],\n\to: [8, octalSeparate],\n\tu: [10, thousandSeparate],\n\tx: [16, hexSeparate]\n}\nconst BASE_PREFIXS = ['0b', '0o', '0x']\nfunction baseFormatter(type: string): FormatCallback {\n\tconst base = BASE_RADIXS[type.toLowerCase()],\n\t\tn = base[0],\n\t\t__toStr = num => num.toString(n),\n\t\ttoStr = type === 'X' ? num => upper(__toStr(num)) : __toStr\n\tlet xprefix = n === 10 ? '' : BASE_PREFIXS[n >> 3]\n\tcharCode(type) < 96 && (xprefix = upper(xprefix))\n\treturn numFormatter(v => v >>> 0, (num, flags) => (flags & FORMAT_XPREFIX ? xprefix : ''), toStr, base[1])\n}\n\n// float formatter \nfunction floatFormatter(type: string): FormatCallback {\n\tconst ____toStr = upper(type) === 'E' ? toExponential : type === 'f' ? toFixed : toPrecision,\n\t\t__toStr = (num, flags, precision) => ____toStr(num, precision) || String(num),\n\t\ttoStr = charCode(type) > 96 ? __toStr : (num, flags, precision) => upper(__toStr(num, flags, precision))\n\treturn numFormatter(parseFloat, decimalPrefix, toStr, thousandSeparate)\n}\n\nfunction toExponential(num: number, precision: number): string {\n\treturn num.toExponential(precision)\n}\nfunction toPrecision(num: number, precision: number): string {\n\treturn precision && num.toPrecision(precision)\n}\nfunction toFixed(num: number, precision: number): string {\n\treturn precision >= 0 && num.toFixed(precision)\n}\n\n// register formatters \nextendFormatter({\n\ts: strFormatter(toStr),\n\tj: strFormatter(v =>\n\t\tv === undefined || isFn(v) || (v.toJSON && v.toJSON() === undefined) ? toStr(v) : JSON.stringify(v)\n\t),\n\tc(val: any) {\n\t\tconst num = val >> 0\n\t\treturn num > 0 ? String.fromCharCode(num) : ''\n\t},\n\td: numFormatter(val => val >> 0, decimalPrefix, toStr, thousandSeparate),\n\te: floatFormatter('e'),\n\tE: floatFormatter('E'),\n\tf: floatFormatter('f'),\n\tg: floatFormatter('g'),\n\tG: floatFormatter('G'),\n\tb: baseFormatter('b'),\n\tB: baseFormatter('B'),\n\to: baseFormatter('o'),\n\tO: baseFormatter('O'),\n\tu: baseFormatter('u'),\n\tx: baseFormatter('x'),\n\tX: baseFormatter('X')\n})\n\nfunction toStr(v: any): string {\n\treturn String(v)\n}\n","/**\n * Object.assign shim\n * @module utility/assign\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Jul 25 2018 15:22:13 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 14:03:59 GMT+0800 (China Standard Time)\n */\nimport { hasOwnProp } from './prop'\n\n/**\n * @param prop\n * @param target\n * @param override\n * @return is assign\n */\nexport type AssignFilter = (prop: string, target: any, override: any) => boolean\n\n/**\n *\n * @param target\n * @param overrides\n * @param filter\n * @param startOffset \tstart offset in overrides, default: 0\n * @param endOffset \tend offset in overrides, default: overrides.length-1\n */\nexport function doAssign(\n\ttarget: any,\n\toverrides: object[] | IArguments,\n\tfilter: AssignFilter,\n\tstartOffset?: number,\n\tendOffset?: number\n): any {\n\tif (!target) {\n\t\ttarget = {}\n\t}\n\tconst l = endOffset || overrides.length - 1\n\tlet i = startOffset || 0,\n\t\toverride,\n\t\tprop\n\tfor (; i < l; i++) {\n\t\tif ((override = overrides[i])) {\n\t\t\tfor (prop in override) {\n\t\t\t\tif (filter(prop, target, override)) {\n\t\t\t\t\ttarget[prop] = override[prop]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn target\n}\n\n/**\n * assign properties\n * > Object.assign shim\n */\nexport function assign(target: any, ...args: any[]): any\nexport function assign(target: any): any {\n\treturn doAssign(target, arguments, defaultAssignFilter, 1)\n}\n\n/**\n * assign un-exist properties\n */\nexport function assignIf(target: any, ...args: any[]): any\nexport function assignIf(target: any): any {\n\treturn doAssign(target, arguments, assignIfFilter, 1)\n}\n\n/**\n * default assign filter\n * - property is owner in override\n * @see {AssignFilter}\n */\nexport function defaultAssignFilter(prop: string, target: any, override: any): boolean {\n\treturn hasOwnProp(override, prop)\n}\n\n/**\n * assign if filter\n * - property is owner in override\n * - property not in target object\n * @see {AssignFilter}\n */\nexport function assignIfFilter(prop: string, target: any, override: any): boolean {\n\treturn hasOwnProp(override, prop) && !(prop in target)\n}\n","/**\n * @module utility/assert\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Nov 28 2018 11:01:45 GMT+0800 (China Standard Time)\n * @modified Tue Dec 18 2018 17:25:26 GMT+0800 (China Standard Time)\n */\n\nimport {\n\teq,\n\tisBool,\n\tisNum,\n\tisStr,\n\tisBoolean,\n\tisNumber,\n\tisString,\n\tisDate,\n\tisNull,\n\tisUndef,\n\tisNil,\n\tisFn,\n\tisInt,\n\tisPrimitive,\n\tisReg,\n\tisArray,\n\tisArrayLike,\n\tisTypedArray,\n\tisObj,\n\tisBlank\n} from '../utility/is'\nimport { create } from './create'\nimport { upperFirst, escapeStr } from '../utility/string'\nimport { createFn } from '../utility/fn'\nimport { eachObj, makeArray } from '../utility/collection'\nimport { formatter } from './format'\nimport { isError } from 'util'\n\nconst formatters = [],\n\tformatArgHandlers: ((args: any[] | IArguments, offset: number) => any)[] = []\nfunction parseMessage(msg: string, args: any[] | IArguments, msgIdx: number): string {\n\tconst fs =\n\t\tformatters[msgIdx] ||\n\t\t((formatArgHandlers[msgIdx] = (args, offset) => {\n\t\t\treturn args[0][offset >= msgIdx ? offset + 1 : offset]\n\t\t}),\n\t\t(formatters[msgIdx] = create(null)))\n\treturn (fs[msg] || (fs[msg] = formatter(msg, msgIdx, formatArgHandlers[msgIdx])))(args)\n}\n\nexport interface assert {\n\t(msg?: string, ...args: any[]): never\n\tis(actual: any, msg?: string, ...args: any[]): assert\n\tnot(actual: any, msg?: string, ...args: any[]): assert\n\teq(actual: any, expect: any, msg?: string, ...args: any[]): assert\n\tblank(actual: any, msg?: string, ...args: any[]): assert\n\tnul(actual: any, msg?: string, ...args: any[]): assert\n\tnil(actual: any, msg?: string, ...args: any[]): assert\n\tundef(actual: any, msg?: string, ...args: any[]): assert\n\tbool(actual: any, msg?: string, ...args: any[]): assert\n\tnum(actual: any, msg?: string, ...args: any[]): assert\n\tint(actual: any, msg?: string, ...args: any[]): assert\n\tstr(actual: any, msg?: string, ...args: any[]): assert\n\tfn(actual: any, msg?: string, ...args: any[]): assert\n\tprimitive(actual: any, msg?: string, ...args: any[]): assert\n\tboolean(actual: any, msg?: string, ...args: any[]): assert\n\tnumber(actual: any, msg?: string, ...args: any[]): assert\n\tstring(actual: any, msg?: string, ...args: any[]): assert\n\tdate(actual: any, msg?: string, ...args: any[]): assert\n\treg(actual: any, msg?: string, ...args: any[]): assert\n\tarray(actual: any, msg?: string, ...args: any[]): assert\n\ttypedArray(actual: any, msg?: string, ...args: any[]): assert\n\tarrayLike(actual: any, msg?: string, ...args: any[]): assert\n\tobj(actual: any, msg?: string, ...args: any[]): assert\n\tnan(actual: any, msg?: string, ...args: any[]): assert\n\tfinite(actual: number | string, msg?: string, ...args: any[]): assert\n\tless(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\tgreater(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\tmatch(actual: string, expect: any, msg?: string, ...args: any[]): assert\n\trange(actual: number, start: number, end: number, msg?: string, ...args: any[]): assert\n\n\tnotEq(actual: any, expect: any, msg?: string, ...args: any[]): assert\n\tnotBlank(actual: any, msg?: string, ...args: any[]): assert\n\tnotNul(actual: any, msg?: string, ...args: any[]): assert\n\tnotNil(actual: any, msg?: string, ...args: any[]): assert\n\tnotUndef(actual: any, msg?: string, ...args: any[]): assert\n\tnotBool(actual: any, msg?: string, ...args: any[]): assert\n\tnotNum(actual: any, msg?: string, ...args: any[]): assert\n\tnotInt(actual: any, msg?: string, ...args: any[]): assert\n\tnotStr(actual: any, msg?: string, ...args: any[]): assert\n\tnotFn(actual: any, msg?: string, ...args: any[]): assert\n\tnotPrimitive(actual: any, msg?: string, ...args: any[]): assert\n\tnotBoolean(actual: any, msg?: string, ...args: any[]): assert\n\tnotNumber(actual: any, msg?: string, ...args: any[]): assert\n\tnotString(actual: any, msg?: string, ...args: any[]): assert\n\tnotDate(actual: any, msg?: string, ...args: any[]): assert\n\tnotReg(actual: any, msg?: string, ...args: any[]): assert\n\tnotArray(actual: any, msg?: string, ...args: any[]): assert\n\tnotTypedArray(actual: any, msg?: string, ...args: any[]): assert\n\tnotArrayLike(actual: any, msg?: string, ...args: any[]): assert\n\tnotObj(actual: any, msg?: string, ...args: any[]): assert\n\tnotNan(actual: any, msg?: string, ...args: any[]): assert\n\tnotFinite(actual: any, msg?: string, ...args: any[]): assert\n\tthrow(fn: () => any, err: Error | string, msg?: string, ...args: any[]): assert\n\tnotThrow(fn: () => any, err: Error | string, msg?: string, ...args: any[]): assert\n\tnotLess(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\tnotGreater(actual: number, expect: number, msg?: string, ...args: any[]): assert\n\tnotMatch(actual: string, expect: any, msg?: string, ...args: any[]): assert\n\tnotRange(actual: number, start: number, end: number, msg?: string, ...args: any[]): assert\n}\n\nexport const assert = <assert>function assert(msg?: string): never {\n\tthrow new Error(parseMessage(msg || 'Error', arguments, 0))\n}\n\nfunction catchErr(fn): Error {\n\ttry {\n\t\tfn()\n\t} catch (e) {\n\t\treturn e\n\t}\n}\n\nfunction checkErr(expect: Error | string, err: Error): boolean {\n\tlet msg = isStr(expect) ? (expect as string) : (expect as Error).message\n\treturn msg === err.message\n}\nconst ERROR = new Error()\nconst throwMsg = mkMsg(objFormatter(1), 'throw')\nassert.throw = function(fn: () => any, expect: Error | string, msg?: string): assert {\n\tconst err = catchErr(fn)\n\tif (!err || (expect && !checkErr(expect, err))) {\n\t\targuments[0] = err\n\t\t!expect && (arguments[2] = ERROR)\n\t\tthrow new Error(parseMessage(msg || throwMsg[0], arguments, 2))\n\t}\n\treturn assert\n}\n\nassert.notThrow = function(fn: () => any, expect: Error | string, msg?: string): assert {\n\tconst err = catchErr(fn)\n\tif (err && (!expect || !checkErr(expect, err))) {\n\t\targuments[0] = err\n\t\t!expect && (arguments[2] = ERROR)\n\t\tthrow new Error(parseMessage(msg || throwMsg[0], arguments, 2))\n\t}\n\treturn assert\n}\n\nfunction extendAssert<T extends Function>(\n\tname: string,\n\tcondition: string | ((...args: any) => boolean) | [string | ((...args: any) => boolean), string?],\n\targs: string | number | string[],\n\tdmsg: string,\n\tErr?: { new (message?: string): Error }\n): T {\n\tconst params: string[] = isStr(args)\n\t\t\t? (args as string).split(/,/g)\n\t\t\t: isNum(args)\n\t\t\t? makeArray(args as number, i => `arg${i + 1}`)\n\t\t\t: (args as string[]),\n\t\tparamStr = params.join(', '),\n\t\tcond = isArray(condition) ? condition[0] : condition,\n\t\texpr = (isArray(condition) ? condition[1] : '') + (isStr(cond) ? `(${cond})` : `cond(${paramStr})`)\n\n\treturn (assert[name] = createFn(\n\t\t`return function assert${upperFirst(name)}(${paramStr}, msg){\n\tif (${expr})\n\t\tthrow new Err(parseMsg(msg || dmsg, arguments, ${params.length}));\n\treturn assert;\n}`,\n\t\t['Err', 'parseMsg', 'dmsg', 'cond', 'assert']\n\t)(Err || Error, parseMessage, dmsg, cond, assert))\n}\n\ntype APIDescriptor = [\n\tstring | ((...args: any) => boolean), // condition\n\tstring | number | string[], // arguments\n\t[string, string], // expect or [err msg, not err msg]\n\t({ new (message?: string): Error })?\n]\n\n// [condition, argcount?, [msg, not msg], Error]\nfunction extendAsserts(apis: { [method: string]: APIDescriptor }) {\n\teachObj(apis, (desc: APIDescriptor, name) => {\n\t\tconst condition = desc[0],\n\t\t\targs = desc[1],\n\t\t\tmsg = desc[2],\n\t\t\tErr = desc[3] || TypeError\n\n\t\tmsg[0] && extendAssert(name, [condition, '!'], args, msg[0], Err)\n\t\tmsg[1] && extendAssert('not' + upperFirst(name), condition, args, msg[1], Err)\n\t})\n}\n\nconst NULL = 'null'\nconst UNDEFINED = 'undefined'\nconst BOOLEAN = 'boolean'\nconst NUMBER = 'number'\nconst INTEGER = 'integer'\nconst STRING = 'string'\nconst FUNCTION = 'function'\nconst ARRAY = 'Array'\nconst TYPED_ARRAY = 'TypedArray'\n\nextendAssert('is', '!o', 'o', expectMsg('Exist'))\nextendAssert('not', 'o', 'o', expectMsg('Not Exist'))\nextendAsserts({\n\teq: [eq, 2, mkMsg(objFormatter(1))],\n\tnul: [isNull, 1, mkMsg(NULL)],\n\tnil: [isNil, 1, mkMsg(typeExpect(NULL, UNDEFINED))],\n\tundef: [isUndef, 1, mkMsg(UNDEFINED)],\n\tbool: [isBool, 1, mkMsg(BOOLEAN)],\n\tnum: [isNum, 1, mkMsg(NUMBER)],\n\tint: [isInt, 1, mkMsg(INTEGER)],\n\tstr: [isStr, 1, mkMsg(STRING)],\n\tfn: [isFn, 1, mkMsg(FUNCTION)],\n\tprimitive: [\n\t\tisPrimitive,\n\t\t1,\n\t\tmkMsg(`Primitive type(${typeExpect(NULL, UNDEFINED, BOOLEAN, NUMBER, INTEGER, STRING, FUNCTION)})`)\n\t],\n\tboolean: [isBoolean, 1, mkMsg(packTypeExpect(BOOLEAN))],\n\tnumber: [isNumber, 1, mkMsg(packTypeExpect(NUMBER))],\n\tstring: [isString, 1, mkMsg(packTypeExpect(STRING))],\n\tdate: [isDate, 1, mkMsg('Date')],\n\treg: [isReg, 1, mkMsg('RegExp')],\n\tarray: [isArray, 1, mkMsg(ARRAY)],\n\ttypedArray: [isTypedArray, 1, mkMsg('TypedArray')],\n\tarrayLike: [\n\t\tisArrayLike,\n\t\t1,\n\t\tmkMsg(typeExpect(ARRAY, packTypeExpect(STRING), 'Arguments', TYPED_ARRAY, 'NodeList', 'HTMLCollection'))\n\t],\n\tobj: [isObj, 1, mkMsg('Object')],\n\tnan: [isNaN, 1, mkMsg('NaN')],\n\tfinite: [isFinite, 1, mkMsg('Finite')],\n\tblank: [isBlank, 1, mkMsg('Blank')],\n\tless: ['o<t', 'o,t', mkMsg(objFormatter(1), 'less than')],\n\tgreater: ['o>t', 'o,t', mkMsg(objFormatter(1), 'greater than')],\n\tmatch: ['reg.test(str)', 'str,reg', mkMsg(objFormatter(1), 'match')],\n\trange: ['o>=s&&o<e', 'o,s,e', mkMsg(`[{1} - {2})`)]\n})\n\nfunction mkMsg(expect: string, to?: string): [string, string] {\n\treturn [expectMsg(expect, false, to), expectMsg(expect, true, to)]\n}\nfunction expectMsg(expect: string, not?: boolean, to?: string): string {\n\treturn `Expected ${objFormatter(0)} ${not ? 'not ' : ''}${to || 'to'} ${expect}`\n}\n\nfunction objFormatter(idx) {\n\treturn `{${idx}:.20=\"...\"j}`\n}\n\nfunction packTypeExpect(base: string, all?: boolean): string {\n\treturn all ? typeExpect(base, upperFirst(base)) : upperFirst(base)\n}\nfunction typeExpect(...types: string[]): string\nfunction typeExpect(): string {\n\treturn Array.prototype.join.call(arguments, ' | ')\n}\n","/**\n * Double Linked List\n * @module utility/List\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Mon Dec 10 2018 19:07:47 GMT+0800 (China Standard Time)\n */\n\nimport { bind } from '../fn'\nimport { defPropValue } from '../prop'\nimport { assert } from '../assert'\n\nconst DEFAULT_BINDING = '__this__'\n\ninterface ListNode<T> extends Array<any> {\n\t0: T\n\t1?: ListNode<T>\n\t2?: ListNode<T>\n\t3?: List<T>\n}\n//type ListNode = [ListElement, IListNode, IListNode, List]\n\nexport class List<T> {\n\tstatic readonly binding: string = DEFAULT_BINDING\n\n\treadonly binding: string\n\tprotected head?: ListNode<T>\n\tprotected tail?: ListNode<T>\n\tprotected length: number = 0\n\tprotected scaning: boolean = false\n\tprotected lazyRemoves?: ListNode<T>[]\n\tconstructor(binding?: string) {\n\t\tthis.binding = binding || DEFAULT_BINDING\n\t}\n\tsize(): number {\n\t\treturn this.length\n\t}\n\thas(obj: T): boolean {\n\t\tconst node: ListNode<T> = obj[this.binding]\n\t\treturn node ? node[0] === obj && node[3] === this : false\n\t}\n\tadd(obj: T): number {\n\t\treturn this.__insert(obj, this.tail)\n\t}\n\taddFirst(obj: T): number {\n\t\treturn this.__insert(obj)\n\t}\n\tinsertAfter(obj: T, target?: T): number {\n\t\treturn this.__insert(obj, target && this.__getNode(target))\n\t}\n\tinsertBefore(obj: T, target?: T): number {\n\t\treturn this.__insert(obj, target && this.__getNode(target)[1])\n\t}\n\taddAll(objs: T[]): number {\n\t\treturn this.__insertAll(objs, this.tail)\n\t}\n\taddFirstAll(objs: T[]): number {\n\t\treturn this.__insertAll(objs)\n\t}\n\tinsertAfterAll(objs: T[], target?: T): number {\n\t\treturn this.__insertAll(objs, target && this.__getNode(target))\n\t}\n\tinsertBeforeAll(objs: T[], target?: T): number {\n\t\treturn this.__insertAll(objs, target && this.__getNode(target)[1])\n\t}\n\tprev(obj: T): T {\n\t\treturn this.__siblingObj(obj, 1)\n\t}\n\tnext(obj: T): T {\n\t\treturn this.__siblingObj(obj, 2)\n\t}\n\tfirst(): T {\n\t\tconst node: ListNode<T> = this.head\n\t\treturn node && node[0]\n\t}\n\tlast(): T {\n\t\tconst node: ListNode<T> = this.tail\n\t\treturn node && node[0]\n\t}\n\teach(cb: (obj: T) => boolean | void, scope?: any) {\n\t\tif (this.length) {\n\t\t\tassert.not(this.scaning, 'Recursive calls are not allowed.')\n\t\t\tthis.scaning = true\n\t\t\tcb = bind(cb, scope)\n\t\t\tvar node = this.head\n\t\t\twhile (node) {\n\t\t\t\tif (node[3] === this && cb(node[0]) === false) break\n\t\t\t\tnode = node[2]\n\t\t\t}\n\t\t\tthis.__doLazyRemove()\n\t\t\tthis.scaning = false\n\t\t}\n\t}\n\ttoArray(): T[] {\n\t\tconst array: T[] = new Array(this.length)\n\t\tlet node = this.head,\n\t\t\ti = 0\n\t\twhile (node) {\n\t\t\tif (node[3] === this) array[i++] = node[0]\n\t\t\tnode = node[2]\n\t\t}\n\t\treturn array\n\t}\n\tremove(obj: T): number {\n\t\treturn this.__remove(this.__getNode(obj))\n\t}\n\tpop(){\n\n\t}\n\tclean() {\n\t\tif (this.length) {\n\t\t\tif (this.scaning) {\n\t\t\t\tvar node = this.head\n\t\t\t\twhile (node) {\n\t\t\t\t\tnode[3] === this && this.__lazyRemove(node)\n\t\t\t\t\tnode = node[2]\n\t\t\t\t}\n\t\t\t\tthis.length = 0\n\t\t\t} else {\n\t\t\t\tthis.__clean()\n\t\t\t}\n\t\t}\n\t}\n\ttoJSON(){}\n\n\tprotected __initNode(obj: T): ListNode<T> {\n\t\tconst { binding } = this\n\t\tlet node: ListNode<T> = obj[binding]\n\t\tif (node && node[0] === obj) {\n\t\t\tif (node[3] === this) {\n\t\t\t\tthis.__remove(node)\n\t\t\t\treturn this.__initNode(obj)\n\t\t\t} else if (node[3]) {\n\t\t\t\tassert('Object is still in some List')\n\t\t\t}\n\t\t} else {\n\t\t\tnode = [obj]\n\t\t\tdefPropValue(obj, binding, node, false)\n\t\t}\n\t\tnode[3] = this\n\t\treturn node\n\t}\n\n\tprotected __getNode(obj: T): ListNode<T> {\n\t\tconst node: ListNode<T> = obj[this.binding]\n\t\tassert.is(node && node[3] === this, 'Object is not in this List')\n\t\treturn node\n\t}\n\n\tprotected __siblingObj(obj: T, siblingIdx: number): T {\n\t\tconst node: ListNode<T> = this.__getNode(obj)\n\t\tlet sibling: ListNode<T> = node[siblingIdx]\n\t\tif (sibling) {\n\t\t\twhile (!sibling[3]) {\n\t\t\t\tsibling = sibling[siblingIdx]\n\t\t\t\tif (!sibling) return\n\t\t\t}\n\t\t\treturn sibling[0]\n\t\t}\n\t}\n\n\tprivate __doInsert(nodeHead: ListNode<T>, nodeTail: ListNode<T>, len: number, prev?: ListNode<T>): number {\n\t\tlet next\n\t\tnodeHead[1] = prev\n\t\tif (prev) {\n\t\t\tnodeTail[2] = next = prev[2]\n\t\t\tprev[2] = nodeHead\n\t\t} else {\n\t\t\tnodeTail[2] = next = this.head\n\t\t\tthis.head = nodeHead\n\t\t}\n\t\tif (next) next[1] = nodeTail\n\t\telse this.tail = nodeTail\n\t\treturn (this.length += len)\n\t}\n\n\tprotected __insert(obj: T, prev?: ListNode<T>): number {\n\t\tconst node = this.__initNode(obj)\n\t\treturn this.__doInsert(node, node, 1, prev)\n\t}\n\n\tprotected __insertAll(objs: T[], prev?: ListNode<T>): number {\n\t\tlet l = objs.length\n\t\tif (l) {\n\t\t\tconst head = this.__initNode(objs[0])\n\t\t\tvar __prev = head,\n\t\t\t\ttail = head,\n\t\t\t\ti = 1\n\t\t\tfor (; i < l; i++) {\n\t\t\t\ttail = this.__initNode(objs[i])\n\t\t\t\ttail[1] = __prev\n\t\t\t\t__prev[2] = tail\n\t\t\t\t__prev = tail\n\t\t\t}\n\t\t\treturn this.__doInsert(head, tail, l, prev)\n\t\t}\n\t\treturn -1\n\t}\n\n\tprotected __remove(node: ListNode<T>): number {\n\t\tthis.scaning ? this.__lazyRemove(node) : this.__doRemove(node)\n\t\treturn --this.length\n\t}\n\n\tprotected __lazyRemove(node: ListNode<T>): void {\n\t\tconst { lazyRemoves } = this\n\t\tnode[0][this.binding] = undefined // unbind this node\n\t\tnode[3] = null\n\t\tif (lazyRemoves) {\n\t\t\tlazyRemoves.push(node)\n\t\t} else {\n\t\t\tthis.lazyRemoves = [node]\n\t\t}\n\t}\n\n\tprotected __doLazyRemove() {\n\t\tconst { lazyRemoves } = this\n\t\tif (lazyRemoves) {\n\t\t\tvar len = lazyRemoves.length\n\t\t\tif (len) {\n\t\t\t\tif (this.length) {\n\t\t\t\t\twhile (len--) this.__doRemove(lazyRemoves[len])\n\t\t\t\t} else {\n\t\t\t\t\tthis.__clean()\n\t\t\t\t}\n\t\t\t\tlazyRemoves.length = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected __doRemove(node: ListNode<T>) {\n\t\tconst prev = node[1],\n\t\t\tnext = node[2]\n\t\tif (prev) {\n\t\t\tprev[2] = next\n\t\t} else {\n\t\t\tthis.head = next\n\t\t}\n\t\tif (next) {\n\t\t\tnext[1] = prev\n\t\t} else {\n\t\t\tthis.tail = prev\n\t\t}\n\t\tnode[1] = node[2] = node[3] = null\n\t}\n\n\tprotected __clean() {\n\t\tlet node,\n\t\t\tnext = this.head\n\t\twhile ((node = next)) {\n\t\t\tnext = node[2]\n\t\t\tnode.length = 1\n\t\t}\n\t\tthis.head = undefined\n\t\tthis.tail = undefined\n\t\tthis.length = 0\n\t}\n}\n","/**\n * Function List\n * @module utility/List\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Mon Dec 10 2018 18:48:02 GMT+0800 (China Standard Time)\n */\n\nimport { List } from './List'\nimport { create } from '../create'\nimport { defPropValue } from '../prop'\n\nconst DEFAULT_FN_BINDING = '__id__'\nconst DEFAULT_SCOPE_BINDING = '__id__'\n\ntype FnNode<T extends Function> = [string, T, any, any]\nexport class FnList<T extends Function> {\n\tstatic readonly fnBinding: string = DEFAULT_FN_BINDING\n\tstatic readonly scopeBinding: string = DEFAULT_SCOPE_BINDING\n\n\treadonly fnBinding: string\n\treadonly scopeBinding: string\n\tprivate readonly list: List<FnNode<T>>\n\tprivate nodeMap: { [key: string]: FnNode<T> }\n\n\tconstructor(fnBinding?: string, scopeBinding?: string) {\n\t\tthis.nodeMap = create(null)\n\t\tthis.list = new List()\n\t\tthis.fnBinding = fnBinding || DEFAULT_FN_BINDING\n\t\tthis.scopeBinding = scopeBinding || DEFAULT_SCOPE_BINDING\n\t}\n\tadd(fn: T, scope?: any, data?: any): number {\n\t\tscope = parseScope(scope)\n\t\tconst { list, nodeMap } = this\n\t\tconst id = nodeId(this, fn, scope)\n\t\tlet node = nodeMap[id]\n\t\tif (!node) {\n\t\t\tnode = [id, fn, scope, data]\n\t\t\tvar ret = list.add(node)\n\t\t\tif (ret) nodeMap[id] = node\n\t\t\treturn ret\n\t\t}\n\t\treturn -1\n\t}\n\tremove(fn: T, scope?: any): number {\n\t\tconst { list, nodeMap } = this\n\t\tconst id = nodeId(this, fn, parseScope(scope))\n\t\tconst node = nodeMap[id]\n\t\tif (node) {\n\t\t\tnodeMap[id] = undefined\n\t\t\treturn list.remove(node)\n\t\t}\n\t\treturn -1\n\t}\n\thas(fn: T, scope?: any): boolean {\n\t\treturn !!this.nodeMap[nodeId(this, fn, parseScope(scope))]\n\t}\n\tsize(): number {\n\t\treturn this.list.size()\n\t}\n\tclean() {\n\t\tthis.nodeMap = create(null)\n\t\tthis.list.clean()\n\t}\n\teach(cb: (fn: T, scope: any, data: any) => boolean | void, scope?: any) {\n\t\tcb = cb.bind(scope)\n\t\tthis.list.each(node => cb(node[1], node[2], node[3]))\n\t}\n\ttoJSON(){}\n}\n\nconst DEFAULT_SCOPE_ID = 1\nlet scopeIdGenerator = 1,\n\tfnIdGenerator = 0\n\nfunction nodeId<T extends Function>(list: FnList<T>, fn: T, scope?: any): string {\n\tconst { fnBinding, scopeBinding } = list\n\n\tlet fnId = fn[fnBinding],\n\t\tscopeId = scope ? scope[scopeBinding] : DEFAULT_SCOPE_ID\n\tif (!fnId) fnId = defPropValue(fn, fnBinding, ++fnIdGenerator, false, false, false)\n\tif (!scopeId) scopeId = defPropValue(scope, scopeBinding, ++scopeIdGenerator, false, false, false)\n\treturn `${fnId}&${scopeId}`\n}\n\nfunction parseScope(scope: any): any {\n\treturn !scope ? undefined : scope\n}\n","/**\n * @module utility/List\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 27 2018 19:06:18 GMT+0800 (China Standard Time)\n * @modified Tue Nov 27 2018 19:07:34 GMT+0800 (China Standard Time)\n */\n\nexport * from './List'\nexport * from './FnList'\n","/**\n * String format\n * @module utility/nextTick\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Mon Dec 11 2017 14:35:32 GMT+0800 (China Standard Time)\n * @modified Mon Dec 10 2018 16:59:56 GMT+0800 (China Standard Time)\n */\nimport { FnList } from './List'\nimport { isFn } from './is'\n\nconst ticks = new FnList()\nlet pending = false\nlet next\n\nfunction executeTick(fn: Function, scope?: any) {\n\tscope ? fn.call(scope) : fn()\n}\n\nfunction flush() {\n\tticks.each(executeTick)\n\tticks.clean()\n\tpending = false\n}\n\nif (isFn(MutationObserver)) {\n\t// chrome18+, safari6+, firefox14+,ie11+,opera15\n\tvar counter = 0,\n\t\tobserver = new MutationObserver(flush),\n\t\ttextNode = document.createTextNode(counter + '')\n\tobserver.observe(textNode, {\n\t\tcharacterData: true\n\t})\n\tnext = function() {\n\t\ttextNode.data = counter + ''\n\t\tcounter = counter ? 0 : 1\n\t}\n} else {\n\tnext = function() {\n\t\tsetTimeout(flush, 0)\n\t}\n}\n\nexport function nextTick(fn: Function, scope?: any) {\n\tticks.add(fn, scope)\n\tif (!pending) {\n\t\tpending = true\n\t\tnext()\n\t}\n}\n\nexport function clearTick(fn: Function, scope?: any) {\n\tticks.remove(fn, scope)\n}\n","import { pad } from '../format'\nimport { escapeStr } from '../string'\n\nconst LINE_REG = /([^\\n]+)?(\\n|$)/g\nexport class Source {\n\treadonly buff: string\n\treadonly len: number\n\tprivate lines: ([number, string])[]\n\tprivate linePos: number\n\tconstructor(buff: string) {\n\t\tthis.buff = buff\n\t\tthis.len = buff.length\n\t\tthis.lines = []\n\t\tthis.linePos = 0\n\t}\n\tposition(offset: number): [number, number, string] {\n\t\tconst { buff, len, lines, linePos } = this\n\t\tlet i = lines.length,\n\t\t\tp: number\n\t\tif (offset < linePos) {\n\t\t\twhile (i--) {\n\t\t\t\tp = offset - lines[i][0]\n\t\t\t\tif (p >= 0) return [i + 1, p, lines[i][1]]\n\t\t\t}\n\t\t} else {\n\t\t\tif (linePos < len) {\n\t\t\t\tvar m\n\t\t\t\tLINE_REG.lastIndex = p = linePos\n\t\t\t\twhile ((m = LINE_REG.exec(buff))) {\n\t\t\t\t\tlines[i++] = [p, m[1] || '']\n\t\t\t\t\tp = LINE_REG.lastIndex\n\t\t\t\t\tif (!p || offset < p) break\n\t\t\t\t}\n\t\t\t\tthis.linePos = p || len\n\t\t\t}\n\t\t\treturn i ? [i, (offset > len ? len : offset) - lines[i - 1][0], lines[i - 1][1]] : [1, 0, '']\n\t\t}\n\t}\n\tsource(escape?: boolean): string {\n\t\tconst { buff } = this\n\t\tlet line = 1,\n\t\t\ttoSourceStr = escape ? escapeSourceStr : sourceStr\n\n\t\treturn buff.replace(LINE_REG, (m, s, t) => pad(String(line++), 3) + ': ' + toSourceStr(m, s, t))\n\t}\n}\nfunction sourceStr(m, s, t) {\n\treturn m || ''\n}\nfunction escapeSourceStr(m, s, t) {\n\treturn s ? escapeStr(s) + t : t\n}\n","/**\n * utilities for ast builder\n *\n * @module utility/AST\n * @author Tao Zeng (tao.zeng.zt@qq.com)\n * @created 2018-11-09 13:22:51\n * @modified 2018-11-09 13:22:51 by Tao Zeng (tao.zeng.zt@qq.com)\n */\nimport { isStr, isArray, isInt } from '../is'\n\n/**\n * each char codes\n */\nexport function eachCharCodes(codes: number | string | any[], ignoreCase: boolean, cb: (code: number) => void) {\n\tif (isStr(codes)) {\n\t\tvar i = (codes as any).length\n\t\twhile (i--) eachCharCode((codes as any).charCodeAt(i), ignoreCase, cb)\n\t} else if (isArray(codes)) {\n\t\tvar i = (codes as any).length\n\t\twhile (i--) eachCharCodes((codes as any)[i], ignoreCase, cb)\n\t} else if (isInt(codes)) {\n\t\teachCharCode(codes as any, ignoreCase, cb)\n\t}\n}\nfunction eachCharCode(code: number, ignoreCase: boolean, cb: (code: number) => void): void {\n\tcb(code)\n\tif (ignoreCase) {\n\t\tif (code <= 90) {\n\t\t\tif (code >= 65) cb(code + 32)\n\t\t} else if (code <= 122) {\n\t\t\tcb(code - 32)\n\t\t}\n\t}\n}\n","import { hasOwnProp } from './prop'\n\nexport function mixin<B>(behaviour: B) {\n\treturn function mixin<M extends B, TFunction extends Function>(\n\t\tClass: TFunction & { new (...args: Array<any>): M }\n\t) {\n\t\tconst proto = Class.prototype\n\t\tfor (var k in behaviour) if (hasOwnProp(behaviour, k)) proto[k] = behaviour[k]\n\t\treturn Class\n\t}\n}\n","/**\n * @module common/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:06:22 GMT+0800 (China Standard Time)\n * @modified Tue Dec 18 2018 17:13:56 GMT+0800 (China Standard Time)\n */\nimport { MatchContext } from './MatchContext'\nimport { eachCharCodes } from './util'\nimport { assert } from '../assert'\nimport { isStr, isBool, isFn } from '../is'\nimport { PROTOTYPE, CONSTRUCTOR } from '../consts'\nimport { mixin } from '../mixin'\n\n@mixin({ $ruleErr: true })\nexport class MatchError {\n\treadonly $ruleErr: boolean\n\treadonly rule: Rule\n\treadonly context: MatchContext\n\treadonly source: MatchError\n\treadonly capturable: boolean\n\treadonly pos: number\n\tmsg: string\n\tconstructor(msg: string, capturable: boolean, source: MatchError, context: MatchContext, rule: Rule) {\n\t\t!isBool(capturable) && (capturable = rule.capturable)\n\t\tthis.capturable = capturable && source ? source.capturable : capturable\n\t\tthis.msg = msg\n\t\tthis.source = source\n\t\tthis.context = context\n\t\tthis.rule = rule\n\t\tthis.pos = context.startPos()\n\t}\n\tposition(): [number, number, string] {\n\t\treturn this.context.source.position(this.pos)\n\t}\n}\n\nexport type onMatchCallback = (data: any, len: number, context: MatchContext, rule: Rule) => MatchError | string | void\nexport type onErrorCallback = (err: MatchError, context: MatchContext, rule: Rule) => MatchError | string | void\n\nfunction defaultErr(err: MatchError) {\n\treturn err\n}\n\nfunction defaultMatch(data: any, len: number, context: MatchContext) {\n\tcontext.add(data)\n}\n\nlet idGen = 0\n/**\n * Abstract Rule\n */\n@mixin({ $rule: true })\nexport class Rule {\n\treadonly $rule: boolean\n\t// rule type (for debug)\n\ttype: string\n\t// rule id\n\treadonly id: number\n\treadonly name: string\n\treadonly capturable: boolean\n\t// rule expression (for debug)\n\tprotected expr: string\n\t// rule EXPECT content (for debug)\n\tprotected EXPECT: string\n\t// matched callback\n\treadonly onMatch: onMatchCallback\n\t// error callback\n\treadonly onErr: onErrorCallback\n\t// index of start codes\n\tprotected startCodeIdx: any[]\n\t// start codes\n\tprotected startCodes: number[]\n\n\t/**\n\t * @param name\t\t\trule name\n\t * @param capturable\terror is capturable\n\t * @param onMatch\t\tcallback on matched, allow modify the match result or return an error\n\t * @param onErr\t\t\tcallback on Error, allow to ignore error or modify error message or return new error\n\t */\n\tconstructor(name: string, capturable: boolean, onMatch: onMatchCallback, onErr: onErrorCallback) {\n\t\tthis.id = idGen++\n\t\tthis.name = name\n\t\tthis.capturable = capturable !== false\n\t\tthis.onMatch = onMatch || defaultMatch\n\t\tthis.onErr = onErr || defaultErr\n\t}\n\n\t/**\n\t * create Error\n\t * @param msg \t\t\terror message\n\t * @param context \t\tmatch context\n\t * @param capturable \tis capturable error\n\t * @param src \t\t\tsource error\n\t */\n\tmkErr(msg: string, context: MatchContext, source?: MatchError, capturable?: boolean): MatchError {\n\t\treturn new MatchError(msg, capturable, source, context, this)\n\t}\n\n\t/**\n\t * match fail\n\t * @param msg \t\t\terror message\n\t * @param context \t\tmatch context\n\t * @param capturable \tis capturable error\n\t * @param src \t\t\tsource error\n\t * @return Error|void: may ignore Error in the error callback\n\t */\n\tprotected error(msg: string, context: MatchContext, src?: MatchError, capturable?: boolean): MatchError {\n\t\tconst err = this.mkErr(msg, context, src, capturable)\n\t\tconst userErr = this.onErr(err, context, this)\n\t\tif (userErr) return isStr(userErr) ? ((err[0] = userErr as string), err) : (userErr as MatchError)\n\t}\n\n\t/**\n\t * match success\n\t * > attach the matched result by match callback\n\t * @param data \t\tmatched data\n\t * @param len  \t\tmatched data length\n\t * @param context \tmatch context\n\t * @return Error|void: may return Error in the match callback\n\t */\n\tprotected matched(data: any, len: number, context: MatchContext): MatchError {\n\t\tconst err = this.onMatch(data, len, context, this)\n\t\tif (err) return (err as any).$ruleErr ? (err as MatchError) : this.mkErr(String(err), context, null, false)\n\t}\n\n\t/**\n\t * match\n\t * @param context match context\n\t */\n\tmatch(context: MatchContext): MatchError {\n\t\treturn assert()\n\t}\n\n\t/**\n\t * get start char codes\n\t */\n\tgetStart(stack?: number[]): number[] {\n\t\treturn this.startCodes\n\t}\n\n\t/**\n\t * prepare test before match\n\t */\n\ttest(context: MatchContext): boolean {\n\t\treturn true //return context.nextCode() !== 0\n\t}\n\n\tprotected startCodeTest(context: MatchContext): boolean {\n\t\tconst code = context.nextCode()\n\t\treturn code !== 0 && !!this.startCodeIdx[code]\n\t}\n\n\tprotected setStartCodes(start: number | string | any[], ignoreCase?: boolean) {\n\t\tconst codes: number[] = [],\n\t\t\tindex: number[] = []\n\t\teachCharCodes(start, ignoreCase, code => {\n\t\t\tif (!index[code]) {\n\t\t\t\tcodes.push(code)\n\t\t\t\tindex[code] = code\n\t\t\t}\n\t\t})\n\t\tthis.startCodes = codes\n\t\tthis.setCodeIdx(index)\n\t}\n\n\tprotected setCodeIdx(index: any[]) {\n\t\tthis.startCodeIdx = index\n\t\tthis.test = index && index.length > 1 ? this.startCodeTest : Rule[PROTOTYPE].test\n\t}\n\n\t// for debug \n\t/**\n\t * make rule expression\n\t * @param expr expression text\n\t */\n\tprotected mkExpr(expr: string): string {\n\t\treturn `<${this.type}: ${expr}>`\n\t}\n\n\t/**\n\t * set rule expression\n\t * \t\t1. make rule expression\n\t * \t\t2. make Expect text\n\t */\n\tprotected setExpr(expr: string) {\n\t\tthis.expr = this.mkExpr(expr)\n\t\tthis.EXPECT = `Expect: ${expr}`\n\t}\n\n\tgetExpr(stack?: number[]): string {\n\t\treturn this.name || this.expr\n\t}\n\n\t/**\n\t * toString by name or expression\n\t */\n\ttoString(): string {\n\t\treturn this.getExpr()\n\t}\n}\n","/**\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 11 2018 15:36:42 GMT+0800 (China Standard Time)\n * @modified Mon Dec 17 2018 17:28:52 GMT+0800 (China Standard Time)\n */\nimport { Source } from './Source'\nimport { char, charCode } from '../string'\nimport { assert } from '../assert'\n/**\n * Match Context of Rule\n */\nexport class MatchContext {\n\t// matched data list\n\tdata: any[]\n\n\t// start offset of original buff\n\treadonly source: Source\n\n\t// start offset of original buff\n\tprivate orgPos: number\n\n\t// template buff\n\tprivate buff: string\n\n\t// current offset of template buff\n\tprivate offset: number\n\n\t// advanced characters\n\tprivate advanced: number\n\n\t// cached character\n\tprivate codeCache: number\n\n\t// parent context\n\treadonly parent: MatchContext\n\n\tconstructor(source: Source, buff: string, offset: number, orgPos: number, parent?: MatchContext, code?: number) {\n\t\tthis.source = source\n\t\tthis.buff = buff\n\t\tthis.offset = offset\n\t\tthis.orgPos = orgPos\n\t\tthis.parent = parent\n\t\tthis.data = []\n\t\tthis.advanced = 0\n\t\tcode ? (this.codeCache = code) : this.flushCache()\n\t}\n\n\tprivate flushCache() {\n\t\tconst { buff, offset } = this\n\t\tthis.codeCache = offset < buff.length ? charCode(buff, offset) : 0\n\t}\n\n\t/**\n\t * create sub Context\n\t */\n\tcreate() {\n\t\treturn new MatchContext(this.source, this.buff, this.offset, this.orgPos + this.advanced, this, this.codeCache)\n\t}\n\n\t/**\n\t * commit context states to parent context\n\t * @param margeData is marge data to parent\n\t */\n\tcommit() {\n\t\tconst { advanced } = this\n\t\tthis.parent.advance(advanced)\n\t\tthis.orgPos += advanced\n\t\tthis.advanced = 0\n\t}\n\n\t/**\n\t *\n\t * @param len \t\treset buff length\n\t * @param dataLen \treset data length\n\t */\n\treset(len?: number, dataLen?: number) {\n\t\tlen || (len = 0)\n\t\tassert.range(len, 0, this.advanced + 1)\n\t\tthis.advance(-(this.advanced - len))\n\t\tthis.resetData(dataLen || 0)\n\t}\n\n\tlen(): number {\n\t\treturn this.advanced\n\t}\n\n\t/**\n\t * advance buffer position\n\t */\n\tadvance(i: number) {\n\t\tthis.offset += i\n\t\tthis.advanced += i\n\t\tif (this.offset < 0) {\n\t\t\tthis.buff = this.source.buff\n\t\t\tthis.offset = this.orgPos + this.advanced\n\t\t}\n\t\tthis.flushCache()\n\t}\n\n\t/**\n\t * get buffer\n\t * @param reset reset buffer string from 0\n\t */\n\tgetBuff(reset?: boolean): string {\n\t\tif (reset) {\n\t\t\tconst { offset } = this\n\t\t\tthis.buff = this.buff.substring(offset)\n\t\t\tthis.offset = 0\n\t\t}\n\t\treturn this.buff\n\t}\n\n\tgetOffset(): number {\n\t\treturn this.offset\n\t}\n\n\tstartPos(): number {\n\t\treturn this.orgPos\n\t}\n\n\tcurrPos(): number {\n\t\treturn this.orgPos + this.advanced\n\t}\n\n\tpos(): [number, number] {\n\t\tconst { orgPos } = this\n\t\treturn [orgPos, orgPos + this.advanced]\n\t}\n\n\t/**\n\t * get next char code\n\t * @return number char code number\n\t */\n\tnextCode() {\n\t\treturn this.codeCache\n\t}\n\n\tnextChar() {\n\t\treturn char(this.codeCache)\n\t}\n\n\teof(): boolean {\n\t\treturn this.codeCache === 0\n\t}\n\n\t// data opeartions \n\t/**\n\t * append data\n\t */\n\tadd(data: any) {\n\t\tthis.data.push(data)\n\t}\n\t/**\n\t * append datas\n\t */\n\taddAll(datas: any[]) {\n\t\tconst { data } = this\n\t\tconst len = data.length\n\t\tlet i = datas.length\n\t\twhile (i--) data[len + i] = datas[i]\n\t}\n\t/**\n\t * reset result data size\n\t */\n\tresetData(len?: number) {\n\t\tconst { data } = this\n\t\tlen = len || 0\n\t\tif (data.length > len) data.length = len\n\t}\n\tdataLen() {\n\t\treturn this.data.length\n\t}\n}\n","/**\n * @module common/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:06:22 GMT+0800 (China Standard Time)\n * @modified Tue Dec 18 2018 17:17:15 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, MatchError, onMatchCallback, onErrorCallback } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { assert } from '../assert'\nimport { idxOfArray } from '../collection'\nimport { pad } from '../format'\nimport { escapeStr } from '../string'\nimport { Source } from './Source'\n\nexport type ruleBuilder = (rule: Rule) => Rule[]\n\n/**\n * complex rule interface\n *\n */\nexport class ComplexRule extends Rule {\n\treadonly split: string\n\tprivate builder: ruleBuilder\n\tprotected EXPECTS: string[]\n\tprotected rules: Rule[]\n\tprotected readonly repeat: [number, number]\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param builder \t\tcallback of build rules\n\t * @param capturable\terror is capturable\n\t * @param onMatch\t\tmatch callback\n\t * @param onErr\t\t\terror callback\n\t */\n\tconstructor(\n\t\tname: string,\n\t\trepeat: [number, number],\n\t\tbuilder: ruleBuilder,\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\t) {\n\t\tsuper(name, capturable, onMatch, onErr)\n\t\tthis.builder = builder\n\n\t\tif (!(repeat[0] >= 0)) repeat[0] = 0\n\t\tif (!(repeat[1] > 0)) repeat[1] = 1e5\n\t\tassert.notGreater(repeat[0], repeat[1])\n\t\tthis.repeat = [repeat[0], repeat[1]]\n\t\tif (repeat[0] !== repeat[1] || repeat[0] !== 1) {\n\t\t\tthis.match = this.repeatMatch\n\t\t\tthis.type = `${this.type}[${repeat[0]}${\n\t\t\t\trepeat[0] === repeat[1] ? '' : ` - ${repeat[1] === 1e5 ? 'MAX' : repeat[1]}`\n\t\t\t}]`\n\t\t}\n\t}\n\tparse(buff: string, errSource?: boolean): any[] {\n\t\tconst ctx = new MatchContext(new Source(buff), buff, 0, 0)\n\t\tlet err = this.match(ctx)\n\t\tif (err) {\n\t\t\tconst msg = []\n\t\t\tvar pos: [number, number, string]\n\t\t\tdo {\n\t\t\t\tpos = err.position()\n\t\t\t\tmsg.unshift(\n\t\t\t\t\t`[${pad(String(pos[0]), 3)}:${pad(String(pos[1]), 2)}] - ${err.rule.toString()}: ${\n\t\t\t\t\t\terr.msg\n\t\t\t\t\t} on \"${escapeStr(pos[2])}\"`\n\t\t\t\t)\n\t\t\t} while ((err = err.source))\n\t\t\tif (errSource !== false) msg.push('[Source]', ctx.source.source())\n\t\t\tthrow new SyntaxError(msg.join('\\n'))\n\t\t}\n\t\treturn ctx.data\n\t}\n\tprotected repeatMatch(context: MatchContext): MatchError {\n\t\treturn assert()\n\t}\n\tinit(): Rule[] {\n\t\tconst rules = this.builder(this)\n\t\tlet i = rules && rules.length\n\n\t\tassert.is(i, `Require Complex Rules`)\n\n\t\tthis.rules = rules\n\t\tthis.builder = null\n\n\t\tconst names = this.rnames(rules)\n\n\t\tthis.setExpr(names.join(this.split))\n\n\t\twhile (i--) names[i] = `Expect[${i}]: ${names[i]}`\n\t\tthis.EXPECTS = names\n\n\t\treturn rules\n\t}\n\n\tprotected setCodeIdx(index: any[]) {\n\t\tif (this.repeat[0]) super.setCodeIdx(index)\n\t}\n\tgetRules(): Rule[] {\n\t\treturn this.rules || this.init()\n\t}\n\n\tgetStart(stack?: number[]): number[] {\n\t\tconst { id, startCodes } = this\n\t\treturn startCodes\n\t\t\t? startCodes\n\t\t\t: (stack && ~idxOfArray(stack, id)) || this.rules\n\t\t\t? []\n\t\t\t: (this.init(), this.startCodes)\n\t}\n\n\tconsume(context: MatchContext): MatchError {\n\t\tconst err = this.matched(context.data, context.len(), context.parent)\n\t\t!err && context.commit()\n\t\treturn err\n\t}\n\n\tprivate rnames(rules: Rule[], stack?: number[]): string[] {\n\t\tlet i = rules.length\n\t\tconst names: string[] = new Array(i),\n\t\t\tid = this.id\n\t\twhile (i--) names[i] = rules[i].getExpr(stack ? stack.concat(id) : [id])\n\t\treturn names\n\t}\n\n\tgetExpr(stack?: number[]): string {\n\t\tconst { id, name } = this\n\t\tlet i: number\n\n\t\treturn name\n\t\t\t? name\n\t\t\t: stack\n\t\t\t? ((i = idxOfArray(stack, id)), ~i)\n\t\t\t\t? `<${this.type} -> $${stack[i]}>`\n\t\t\t\t: this.mkExpr(this.rnames(this.getRules(), stack).join(this.split))\n\t\t\t: this.expr\n\t}\n}\n","/**\n *\n * @module common/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 27 2018 19:05:48 GMT+0800 (China Standard Time)\n * @modified Tue Dec 18 2018 17:23:21 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, onMatchCallback, onErrorCallback, MatchError } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { ComplexRule, ruleBuilder } from './ComplexRule'\nimport { mixin } from '../mixin'\n\n/**\n * AND Complex Rule\n *\n */\n@mixin({ type: 'And', split: ' ' })\nexport class AndRule extends ComplexRule {\n\tinit(): Rule[] {\n\t\tconst rules = super.init()\n\n\t\tthis.setStartCodes(rules[0].getStart([this.id]))\n\t\treturn rules\n\t}\n\tmatch(context: MatchContext): MatchError {\n\t\tconst rules = this.getRules(),\n\t\t\tlen = rules.length,\n\t\t\tctx = context.create()\n\t\tlet err: MatchError,\n\t\t\ti: number = 0\n\t\tfor (; i < len; i++) if ((err = this.testRule(rules[i], i, ctx))) return err\n\t\treturn this.consume(ctx)\n\t}\n\tprotected repeatMatch(context: MatchContext): MatchError {\n\t\tconst rules = this.getRules(),\n\t\t\tlen = rules.length,\n\t\t\t[min, max] = this.repeat,\n\t\t\tctx = context.create()\n\n\t\tlet err: MatchError,\n\t\t\trepeat: number = 0,\n\t\t\ti: number,\n\t\t\tmlen: number,\n\t\t\tdlen: number\n\n\t\tout: for (; repeat < max; repeat++) {\n\t\t\tdlen = ctx.dataLen()\n\t\t\tmlen = ctx.len()\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tif ((err = this.testRule(rules[i], i, ctx))) {\n\t\t\t\t\tif (repeat < min) return err\n\t\t\t\t\tctx.reset(mlen, dlen)\n\t\t\t\t\tbreak out\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.consume(ctx)\n\t}\n\ttestRule(rule: Rule, i: number, ctx: MatchContext): MatchError {\n\t\tlet err\n\t\treturn (!rule.test(ctx) || (err = rule.match(ctx))) && (err = this.error(this.EXPECTS[i], ctx, err))\n\t}\n}\n","/**\n *\n * @module common/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 27 2018 19:05:48 GMT+0800 (China Standard Time)\n * @modified Tue Dec 18 2018 17:23:28 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, onMatchCallback, onErrorCallback, MatchError } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { ComplexRule, ruleBuilder } from './ComplexRule'\nimport { eachCharCodes } from './util'\nimport { mixin } from '../mixin'\n\n/**\n * OR Complex Rule\n */\n@mixin({ type: 'Or', split: ' | ' })\nexport class OrRule extends ComplexRule {\n\tstartCodeIdx: Rule[][]\n\tindex: Rule[][]\n\tinit(): Rule[] {\n\t\tconst rules = super.init(),\n\t\t\tlen = rules.length,\n\t\t\tid = this.id,\n\t\t\tstarts: number[] = [], // all distinct start codes\n\t\t\trStarts: number[][] = [], // start codes per rule\n\t\t\tindex: Rule[][] = [\n\t\t\t\t[] // rules which without start code\n\t\t\t]\n\n\t\tlet i: number, j: number, k: Rule[] & { idx: number }, codes: number[]\n\n\t\t// get start codes of all rules\n\t\tfor (i = 0; i < len; i++) {\n\t\t\trStarts[i] = [] // init rule start codes\n\t\t\teachCharCodes(rules[i].getStart([id]), false, code => {\n\t\t\t\trStarts[i].push(code) // append to rule start codes\n\t\t\t\tif (!index[code]) {\n\t\t\t\t\tindex[code] = [] // init start code index\n\t\t\t\t\tstarts.push(code) // append to all start codes\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\t// fill index\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tcodes = rStarts[i] // append rule to start code index by rule start codes\n\t\t\tif (!codes.length) {\n\t\t\t\t// rule without start code\n\t\t\t\tindex[0].push(rules[i]) // append rule to index[0]\n\t\t\t\tcodes = starts // append rule to start code index by all start codes\n\t\t\t}\n\n\t\t\t// append rule to start code index (by rule start codes or all start codes)\n\t\t\tj = codes.length\n\t\t\twhile (j--) {\n\t\t\t\tk = index[codes[j]] as Rule[] & { idx: number }\n\t\t\t\tif (k.idx !== i) {\n\t\t\t\t\t// deduplication\n\t\t\t\t\tk.push(rules[i]) // append rules[i] to start code index[codes[j]]\n\t\t\t\t\tk.idx = i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// rule have unkown start code when got unkown start code from any rules\n\t\tthis.startCodes = index[0].length ? [] : starts\n\n\t\tthis.index = starts.length && index\n\t\tstarts.length && !index[0].length && this.setCodeIdx(index)\n\t\treturn rules\n\t}\n\tmatch(context: MatchContext): MatchError {\n\t\tconst { index } = this\n\t\tconst rules: Rule[] = index ? index[context.nextCode()] || index[0] : this.getRules(),\n\t\t\tlen = rules.length,\n\t\t\tctx = context.create()\n\t\tlet err: MatchError,\n\t\t\tupErr: MatchError,\n\t\t\ti = 0\n\t\tfor (; i < len; i++) {\n\t\t\terr = rules[i].match(ctx) || this.consume(ctx)\n\t\t\tif (!err) return\n\t\t\tif (!err.capturable) {\n\t\t\t\tupErr = err\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif (!upErr || err.pos >= upErr.pos) upErr = err\n\t\t\tctx.reset()\n\t\t}\n\t\treturn this.error(this.EXPECT, ctx, upErr)\n\t}\n\tprotected repeatMatch(context: MatchContext): MatchError {\n\t\tlet { index } = this\n\t\tconst [min, max] = this.repeat,\n\t\t\tctx = context.create()\n\n\t\tlet rules: Rule[],\n\t\t\tlen: number,\n\t\t\terr: MatchError,\n\t\t\tupErr: MatchError,\n\t\t\trepeat: number = 0,\n\t\t\ti: number,\n\t\t\tmlen: number,\n\t\t\tdlen: number\n\n\t\tif (!index) {\n\t\t\trules = this.getRules()\n\t\t\tindex = this.index\n\t\t\tlen = rules.length\n\t\t}\n\n\t\tout: for (; repeat < max; repeat++) {\n\t\t\tif (index) {\n\t\t\t\trules = index[ctx.nextCode()] || index[0]\n\t\t\t\tlen = rules.length\n\t\t\t}\n\t\t\tif (len) {\n\t\t\t\tdlen = ctx.dataLen()\n\t\t\t\tmlen = ctx.len()\n\t\t\t\tupErr = null\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\terr = rules[i].match(ctx)\n\t\t\t\t\tif (!err) continue out\n\t\t\t\t\tif (!err.capturable) {\n\t\t\t\t\t\tupErr = err\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tif (!upErr || err.pos >= upErr.pos) upErr = err\n\t\t\t\t\tctx.reset(mlen, dlen)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (repeat < min) return this.error(this.EXPECT, ctx, upErr)\n\t\t}\n\t\treturn this.consume(ctx)\n\t}\n}\n","/**\n * @module common/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:06:22 GMT+0800 (China Standard Time)\n * @modified Mon Dec 17 2018 14:33:00 GMT+0800 (China Standard Time)\n */\n\nimport { Rule, MatchError, onMatchCallback, onErrorCallback } from './Rule'\nimport { MatchContext } from './MatchContext'\n\n/**\n * Match Rule Interface\n */\nexport class MatchRule extends Rule {\n\tprotected readonly index: number[]\n\tprotected readonly ignoreCase: boolean\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param start \t\tstart char codes, prepare test by start char codes before match\n\t * @param ignoreCase\tignore case for the start char codes\n\t * @param capturable\terror is capturable\n\t * @param onMatch\t\tmatch callback\n\t * @param onErr\t\t\terror callback\n\t */\n\tconstructor(\n\t\tname: string,\n\t\tstart: number | string | any[],\n\t\tignoreCase: boolean,\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\t) {\n\t\tsuper(name, capturable, onMatch, onErr)\n\t\tthis.ignoreCase = ignoreCase\n\t\tthis.setStartCodes(start, ignoreCase)\n\t}\n\n\t/**\n\t * consume matched result\n\t * @param data \t\tmatched result\n\t * @param len \t\tmatched chars\n\t * @param context \tmatch context\n\t */\n\tcomsume(data: string | string[], len: number, context: MatchContext): MatchError {\n\t\tcontext.advance(len)\n\t\treturn this.matched(data, len, context)\n\t}\n}\n","/**\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 11 2018 15:36:42 GMT+0800 (China Standard Time)\n * @modified Mon Dec 17 2018 14:33:10 GMT+0800 (China Standard Time)\n */\n\nimport { onMatchCallback, onErrorCallback } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { MatchRule } from './MatchRule'\nimport { char } from '../string'\n\n/**\n * match a character in the allowed list\n * > well match any character if the allowed list is empty\n *\n * > must call test() before match\n */\nexport class CharMatchRule extends MatchRule {\n\ttype: string = 'Character'\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param allows \t\tallowed character codes for match\n\t * \t\t\t\t\t\twell match any character if the allowed list is empty\n\t * @param ignoreCase\tignore case for the allowed character codes\n\t * @param capturable\terror is capturable\n\t * @param onMatch\t\tmatch callback\n\t * @param onErr\t\t\terror callback\n\t */\n\tconstructor(\n\t\tname: string,\n\t\tallows: number | string | any[],\n\t\tignoreCase: boolean,\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\t) {\n\t\tsuper(name, allows, ignoreCase, capturable, onMatch, onErr)\n\t\tconst codes = this.startCodes\n\n\t\tlet i = codes.length,\n\t\t\texpr = '*'\n\t\tif (i) {\n\t\t\tconst chars = []\n\t\t\twhile (i--) chars[i] = char(codes[i])\n\t\t\texpr = `\"${chars.join('\" | \"')}\"`\n\t\t}\n\t\tthis.setExpr(expr)\n\t}\n\tmatch(context: MatchContext) {\n\t\treturn this.comsume(context.nextChar(), 1, context)\n\t}\n}\n","/**\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 11 2018 15:36:42 GMT+0800 (China Standard Time)\n * @modified Tue Dec 18 2018 17:10:24 GMT+0800 (China Standard Time)\n */\n\nimport { MatchError, onMatchCallback, onErrorCallback } from './Rule'\nimport { MatchContext } from './MatchContext'\nimport { MatchRule } from './MatchRule'\nimport { regStickySupport } from '../reg'\nimport { isInt } from '../is'\nimport { createFn } from '../fn'\nimport { map, mapArray } from '../collection'\nimport { mixin } from '../mixin'\n\n/**\n * match string by RegExp\n *\n * optimization:\n * - Priority use sticky mode {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky}\n *\n */\n@mixin({ type: 'RegExp' })\nexport class RegMatchRule extends MatchRule {\n\treadonly regexp: RegExp\n\treadonly pick: boolean | number\n\tprivate picker: (m: string[]) => string | string[]\n\tprivate spicker: (buff: string, start: number, end: number) => string\n\t/**\n\t * @param name \t\t\tmatch name\n\t * @param regexp\t\tregular\n\t * @param pick\t\t\tpick regular matching results\n\t * \t\t\t\t\t\t    0: pick results[0] (optimize: test and substring in sticky mode)\n\t * \t\t\t\t\t\t  > 0: pick results[{pick}]\n\t * \t\t\t\t\t\t  < 0: pick first non-blank string from 1 to -{pick} index on results\n\t * \t\t\t\t\t\t true: pick results\n\t * \t\t\t\t\t\tfalse: not pick result, result is null (optimize: just test string in sticky mode)\n\t * @param start\t\t\tstart character codes in the regular, optimize performance by start character codes\n\t * @param capturable\terror is capturable\n\t * @param onMatch\t\tmatch callback\n\t * @param onErr\t\t\terror callback\n\t */\n\tconstructor(\n\t\tname: string,\n\t\tregexp: RegExp,\n\t\tpick: boolean | number,\n\t\tstart: number | string | any[],\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\t) {\n\t\tpick = pick === false || isInt(pick) ? pick : !!pick || 0\n\n\t\tconst sticky = regStickySupport && !pick, // use exec mode when need pick match group data\n\t\t\tpattern = regexp.source,\n\t\t\tignoreCase = regexp.ignoreCase\n\n\t\t// always wrapping in a none capturing group preceded by '^' to make sure\n\t\t// matching can only work on start of input. duplicate/redundant start of\n\t\t// input markers have no meaning (/^^^^A/ === /^A/)\n\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky\n\t\t// When the y flag is used with a pattern, ^ always matches only at the\n\t\t// beginning of the input, or (if multiline is true) at the beginning of a\n\t\t// line.\n\t\tregexp = new RegExp(\n\t\t\tsticky ? pattern : `^(?:${pattern})`,\n\t\t\t(ignoreCase ? 'i' : '') + (regexp.multiline ? 'm' : '') + (sticky ? 'y' : '')\n\t\t)\n\n\t\tsuper(name, start, ignoreCase, capturable, onMatch, onErr)\n\t\tthis.regexp = regexp\n\t\tthis.pick = pick\n\t\tthis.match = sticky ? this.stickyMatch : this.execMatch\n\n\t\tsticky ? (this.spicker = pick === false ? pickNone : pickTestStr) : (this.picker = mkPicker(pick))\n\n\t\tthis.setExpr(pattern)\n\t}\n\tmatch(context: MatchContext) {\n\t\treturn this.comsume(context.nextChar(), 1, context)\n\t}\n\t/**\n\t * match on sticky mode\n\t */\n\tstickyMatch(context: MatchContext): MatchError {\n\t\tconst reg = this.regexp,\n\t\t\tbuff = context.getBuff(),\n\t\t\tstart = context.getOffset()\n\t\treg.lastIndex = start\n\t\treturn reg.test(buff)\n\t\t\t? this.comsume(this.spicker(buff, start, reg.lastIndex), reg.lastIndex - start, context)\n\t\t\t: this.error(this.EXPECT, context)\n\t}\n\t/**\n\t * match on exec mode\n\t */\n\texecMatch(context: MatchContext): MatchError {\n\t\tconst m = this.regexp.exec(context.getBuff(true))\n\t\tif (m) {\n\t\t\treturn this.comsume(this.picker(m), m[0].length, context)\n\t\t}\n\t\treturn this.error(this.EXPECT, context)\n\t}\n}\n\nfunction mkPicker(pick: number | boolean): (m: string[]) => string | string[] {\n\treturn pick === false\n\t\t? pickNone\n\t\t: pick === true\n\t\t? pickAll\n\t\t: pick >= 0\n\t\t? (m: string[]): string => m[pick as number]\n\t\t: createFn(`return ${mapArray(new Array(-pick), (v, i) => `m[${i + 1}]`).join(' || ')}`, ['m'])\n}\n\nfunction pickNone(): string {\n\treturn null\n}\n\nfunction pickAll(m: string[]): string[] {\n\treturn m\n}\n\nfunction pickTestStr(buff: string, start: number, end: number): string {\n\treturn buff.substring(start, end)\n}\n","/**\n * @module utility/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Dec 11 2018 15:36:42 GMT+0800 (China Standard Time)\n * @modified Tue Dec 18 2018 17:07:25 GMT+0800 (China Standard Time)\n */\n\nimport { onMatchCallback, onErrorCallback } from './Rule'\nimport { RegMatchRule } from './RegMatchRule'\nimport { reEscape } from '../reg'\nimport { mixin } from '../mixin'\n\n@mixin({ type: 'String' })\nexport class StringMatchRule extends RegMatchRule {\n\tconstructor(\n\t\tname: string,\n\t\tstr: string,\n\t\tignoreCase: boolean,\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\t) {\n\t\tsuper(name, new RegExp(reEscape(str), ignoreCase ? 'i' : ''), 0, str.charCodeAt(0), capturable, onMatch, onErr)\n\t\tthis.setExpr(str)\n\t}\n}\n","/**\n *\n * @module common/AST\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Tue Nov 06 2018 10:58:52 GMT+0800 (China Standard Time)\n * @modified Tue Dec 18 2018 09:27:40 GMT+0800 (China Standard Time)\n */\n\nimport { ruleBuilder } from './ComplexRule'\nimport { isObj, isReg, isStr, isBool, isNum, isInt, isArray, isArrayLike, isFn } from '../is'\nimport { makeMap, mapArray, SKIP } from '../collection'\nimport { CharMatchRule } from './CharMatchRule'\nimport { StringMatchRule } from './StringMatchRule'\nimport { RegMatchRule } from './RegMatchRule'\nimport { onMatchCallback, onErrorCallback, Rule } from './Rule'\nimport { MatchRule } from './MatchRule'\nimport { AndRule } from './AndRule'\nimport { OrRule } from './OrRule'\nimport { assert } from '../assert'\nimport { MatchContext } from './MatchContext'\n\n//========================================================================================\n/*                                                                                      *\n *                                      match tools                                     *\n *                                                                                      */\n//========================================================================================\n\nexport function discardMatch(data: any, len: number, context: MatchContext) {}\n\nexport function appendMatch(data: any, len: number, context: MatchContext) {\n\tcontext.addAll(data)\n}\nexport function attachMatch(val) {\n\tconst fn = isFn(val) ? val : () => val\n\treturn (data: any, len: number, context: MatchContext) => {\n\t\tcontext.add(fn(data, len, context))\n\t}\n}\n//========================================================================================\n/*                                                                                      *\n *                                  match rule builder                                  *\n *                                                                                      */\n//========================================================================================\n\n// named regexp match api \n// pick, start, cap\n// pick, cap\n// pick, start\n// pick\n// start, cap\n// start\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tpick?: boolean | number,\n\tstartCodes?: number | string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tstartCodes: number | string | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tstartCodes: string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tname: string,\n\tpattern: RegExp,\n\tstartCodes: string | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(name: string, pattern: RegExp, onMatch: onMatchCallback, onErr?: onErrorCallback): MatchRule\n\n// regexp match api \nexport function match(\n\tpattern: RegExp,\n\tpick?: boolean | number,\n\tstartCodes?: number | string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tstartCodes: number | string | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tstartCodes: string | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(\n\tpattern: RegExp,\n\tstartCodes: string | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\nexport function match(pattern: RegExp, onMatch: onMatchCallback, onErr?: onErrorCallback): MatchRule\n\n// named string match api \nexport function match(\n\tname: string,\n\tpattern: number | string | any[],\n\tignoreCase?: boolean,\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(\n\tname: string,\n\tpattern: number | string | any[],\n\tignoreCase: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(\n\tname: string,\n\tpattern: number | string | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\n// string match api \nexport function match(\n\tpattern: number | string | any[],\n\tignoreCase?: boolean,\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(\n\tpattern: number | string | any[],\n\tignoreCase: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): MatchRule\n\nexport function match(pattern: number | string | any[], onMatch: onMatchCallback, onErr?: onErrorCallback): MatchRule\n\nexport function match(desc: MatchRuleDescriptor): MatchRule\n\nexport function match(): MatchRule {\n\treturn mkMatch(arguments)\n}\n\ntype MatchRuleDescriptor = {\n\tname: string\n\tpattern: RegExp | number | string | any[]\n\tpick: boolean | number\n\tstartCodes: number | string | any[]\n\tignoreCase: boolean\n\tcapturable: boolean\n\tonMatch: onMatchCallback\n\tonErr: onErrorCallback\n}\nfunction mkMatch(args: IArguments | any[] | MatchRuleDescriptor, defaultOnMatch?: onMatchCallback): MatchRule {\n\tlet name: string,\n\t\tpattern: number | string | any[],\n\t\tregexp: RegExp,\n\t\tpick: boolean | number = 0,\n\t\tstartCodes: number | string | any[],\n\t\tignoreCase: boolean = false,\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\tif (isObj(args[0])) {\n\t\tconst desc = args[0] as MatchRuleDescriptor,\n\t\t\tp = desc.pattern\n\t\tif (isReg(p)) {\n\t\t\tregexp = p as RegExp\n\t\t\tpick = desc.pick\n\t\t\tstartCodes = desc.startCodes\n\t\t} else if (isMatchPattern(p)) {\n\t\t\tpattern = p as number | string | any[]\n\t\t\tignoreCase = desc.ignoreCase\n\t\t}\n\t\tname = desc.name\n\t\tcapturable = desc.capturable\n\t\tonMatch = desc.onMatch\n\t\tonErr = desc.onErr\n\t} else {\n\t\tvar i = 2\n\n\t\tif (isMatchPattern(args[1])) {\n\t\t\tname = args[0]\n\t\t\tisReg(args[1]) ? (regexp = args[1]) : (pattern = args[1])\n\t\t} else if (isMatchPattern(args[0])) {\n\t\t\ti = 1\n\t\t\tisReg(args[0]) ? (regexp = args[0]) : (pattern = args[0])\n\t\t}\n\n\t\tif (regexp) {\n\t\t\tif (isBool(args[i]) || isInt(args[i])) pick = args[i++]\n\t\t\tif (isStrOrCodes(args[i])) startCodes = args[i++]\n\t\t} else {\n\t\t\tif (isBool(args[i])) ignoreCase = args[i++]\n\t\t}\n\t\tif (isBool(args[i])) capturable = args[i++]\n\t\tonMatch = args[i++]\n\t\tonErr = args[i++]\n\t}\n\tonMatch = onMatch || defaultOnMatch\n\treturn regexp\n\t\t? regMatch(name, regexp, onMatch === discardMatch ? false : pick, startCodes, capturable, onMatch, onErr)\n\t\t: pattern\n\t\t? strMatch(name, pattern, ignoreCase, capturable, onMatch, onErr)\n\t\t: null\n}\n\nfunction isStrOrCodes(pattern): boolean {\n\treturn isStr(pattern) || isNum(pattern) || isArray(pattern)\n}\nfunction isMatchPattern(pattern): boolean {\n\treturn isReg(pattern) || isStrOrCodes(pattern)\n}\n\nfunction strMatch(\n\tname: string,\n\tpattern: string | number | any[],\n\tignoreCase: boolean,\n\tcapturable: boolean,\n\tonMatch: onMatchCallback,\n\tonErr: onErrorCallback\n) {\n\tconst C = isStr(pattern) && (pattern as string).length > 1 ? StringMatchRule : CharMatchRule\n\treturn new C(name, pattern, ignoreCase, capturable, onMatch, onErr)\n}\n\nconst REG_ESPEC_CHARS = makeMap('dDsStrnt0cbBfvwW', 1, '')\n\nfunction regMatch(\n\tname: string,\n\tpattern: RegExp,\n\tpick: boolean | number,\n\tstartCodes: number | string | any[],\n\tcapturable: boolean,\n\tonMatch: onMatchCallback,\n\tonErr: onErrorCallback\n) {\n\tconst source = pattern.source\n\tif (!pick) {\n\t\tvar c: string | 0 = 0\n\t\tif (source.length == 1 && source !== '^' && source !== '$') {\n\t\t\tc = source === '.' ? '' : source\n\t\t} else if (source.length == 2 && source[0] === '\\\\' && REG_ESPEC_CHARS[source[1]]) {\n\t\t\tc = source[1]\n\t\t}\n\t\tif (c != 0) return strMatch(name, c as string, pattern.ignoreCase, capturable, onMatch, onErr)\n\t}\n\treturn new RegMatchRule(name, pattern, pick, startCodes, capturable, onMatch, onErr)\n}\n//========================================================================================\n/*                                                                                      *\n *                                   and rule builder                                   *\n *                                                                                      */\n//========================================================================================\n\nexport function and(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\n\nexport function and(\n\trules: ((rule: Rule) => any[]) | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function and(rules: ((rule: Rule) => any[]) | any[], onMatch: onMatchCallback, onErr?: onErrorCallback): AndRule\nexport function and(desc: ComplexRuleDescriptor): AndRule\n\nexport function and(o): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [1, 1])\n}\n\n// and any \nexport function any(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function any(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\n\nexport function any(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function any(rules: ((rule: Rule) => any[]) | any[], onMatch: onMatchCallback, onErr?: onErrorCallback): AndRule\nexport function any(desc: ComplexRuleDescriptor): AndRule\nexport function any(o): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [0, -1])\n}\n// and many \nexport function many(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function many(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\n\nexport function many(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function many(rules: ((rule: Rule) => any[]) | any[], onMatch: onMatchCallback, onErr?: onErrorCallback): AndRule\nexport function many(desc: ComplexRuleDescriptor): AndRule\nexport function many(o): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [1, -1])\n}\n\n// and option \nexport function option(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function option(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\n\nexport function option(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function option(\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): AndRule\nexport function option(desc: ComplexRuleDescriptor): AndRule\nexport function option(o): AndRule {\n\treturn mkComplexRule(arguments, AndRule, [0, 1])\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                   OR Rule Builders                                   *\n *                                                                                      */\n//========================================================================================\n\nexport function or(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\n\nexport function or(\n\trules: ((rule: Rule) => any[]) | any[],\n\trepeat?: [number, number],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function or(rules: ((rule: Rule) => any[]) | any[], onMatch: onMatchCallback, onErr?: onErrorCallback): OrRule\nexport function or(desc: ComplexRuleDescriptor): OrRule\n\nexport function or(o): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [1, 1])\n}\n\n// or any \nexport function anyOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function anyOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\n\nexport function anyOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function anyOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function anyOne(desc: ComplexRuleDescriptor): OrRule\nexport function anyOne(o): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [0, -1])\n}\n\n// or many \nexport function manyOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function manyOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\n\nexport function manyOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function manyOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function manyOne(desc: ComplexRuleDescriptor): OrRule\nexport function manyOne(o): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [1, -1])\n}\n\n// or option \nexport function optionOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function optionOne(\n\tname: string,\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\n\nexport function optionOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tcapturable?: boolean,\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function optionOne(\n\trules: ((rule: Rule) => any[]) | any[],\n\tonMatch?: onMatchCallback,\n\tonErr?: onErrorCallback\n): OrRule\nexport function optionOne(desc: ComplexRuleDescriptor): OrRule\nexport function optionOne(o): OrRule {\n\treturn mkComplexRule(arguments, OrRule, [0, 1])\n}\n\n//========================================================================================\n/*                                                                                      *\n *                                 complex rule builder                                 *\n *                                                                                      */\n//========================================================================================\n\ntype ComplexRuleDescriptor = {\n\tname: string\n\trules: ((rule: Rule) => any[]) | any[]\n\trepeat: [number, number]\n\tcapturable: boolean\n\tonMatch: onMatchCallback\n\tonErr: onErrorCallback\n}\nfunction mkComplexRule<T extends AndRule | OrRule>(\n\targs: IArguments,\n\tRule: typeof AndRule | typeof OrRule,\n\tdefaultRepeat: [number, number]\n): T {\n\tlet name: string,\n\t\tbuilder: ruleBuilder,\n\t\trules: ((rule: Rule) => any[]) | any[],\n\t\trepeat: [number, number],\n\t\tcapturable: boolean,\n\t\tonMatch: onMatchCallback,\n\t\tonErr: onErrorCallback\n\tif (isObj(args[0])) {\n\t\tconst desc = args[0] as ComplexRuleDescriptor,\n\t\t\tr = desc.rules\n\t\tif (isArray(r) || isFn(r)) rules = r\n\t\trepeat = desc.repeat\n\t\tname = desc.name\n\t\tcapturable = desc.capturable\n\t\tonMatch = desc.onMatch\n\t\tonErr = desc.onErr\n\t} else {\n\t\tvar i = 0\n\t\tif (isStr(args[i])) name = args[i++]\n\t\tif (isArray(args[i]) || isFn(args[i])) rules = args[i++]\n\t\tif (isArray(args[i])) repeat = args[i++]\n\t\tif (isBool(args[i])) capturable = args[i++]\n\t\tonMatch = args[i++]\n\t\tonErr = args[i++]\n\t}\n\tif (!repeat) repeat = defaultRepeat\n\tif (rules) {\n\t\tbuilder = rulesBuilder(rules)\n\t\treturn new Rule(name, repeat, builder, capturable, onMatch, onErr) as T\n\t}\n}\n\nfunction rulesBuilder(rules: ((rule: Rule) => any[]) | any[]): (rule: Rule) => Rule[] {\n\treturn function(_rule) {\n\t\treturn mapArray(isFn(rules) ? (rules as ((rule: Rule) => any[]))(_rule) : rules, (r, i) => {\n\t\t\tif (!r) return SKIP\n\t\t\tlet rule: Rule = r.$rule ? r : isArray(r) ? mkMatch(r) : mkMatch([r], discardMatch)\n\t\t\tassert.is(rule, '{}: Invalid Rule Configuration on index {d}: {:.80=\"...\"j}', _rule, i, r)\n\t\t\treturn rule\n\t\t})\n\t}\n}\n","import { makeMap } from '../collection'\nimport { match, discardMatch, and, anyOne, many, option, or, any } from '.'\nimport { reEscape } from '../reg'\nimport { escapeStr } from '../string'\nimport { MatchContext } from './MatchContext'\nimport { Rule } from './Rule'\n\nconst EXPR_START = '{',\n\tEXPR_END = '}'\n\nconst AutoCloseElems = makeMap('input'),\n\tContentElems = makeMap('textarea')\n\nconst EXPR_START_LEN = EXPR_START.length,\n\tEXPR_END_LEN = EXPR_END.length\n\nconst EXPR_KEY_WORDS = `\"'\\`[{`\n\nand('a', () => [], discardMatch)\n\nconst EXPR_KEYS = match(EXPR_KEY_WORDS.split(''), discardMatch),\n\tEXPR_STR = match(/\"(?:[^\\\\\"\\n]|\\\\.)*\"|'(?:[^\\\\'\\n]|\\\\.)*'|`(?:[^\\\\`]|\\\\.)*`/, `'\"\\``, false, discardMatch),\n\tExprObject = and(\n\t\t'ExprObject',\n\t\t() => [\n\t\t\t'{',\n\t\t\tanyOne(\n\t\t\t\t'ObjBody',\n\t\t\t\t[\n\t\t\t\t\tEXPR_STR,\n\t\t\t\t\tExprObject,\n\t\t\t\t\tExprArray,\n\t\t\t\t\tEXPR_KEYS, // consume start char when EXPR_STR | ExprObject | ExprArray match failed\n\t\t\t\t\tnew RegExp(`[^${reEscape(EXPR_KEY_WORDS + '}')}]+`) // consume chars which before start codes of EXPR_STR | ExprObject | ExprArray and \"}\"\n\t\t\t\t],\n\t\t\t\tdiscardMatch\n\t\t\t),\n\t\t\t'}'\n\t\t],\n\t\tdiscardMatch\n\t),\n\tExprArray = and('ExprArray', () => [\n\t\t'[',\n\t\tanyOne(\n\t\t\t'ArrayBody',\n\t\t\t[EXPR_STR, ExprObject, ExprArray, EXPR_KEYS, new RegExp(`[^${reEscape(EXPR_KEY_WORDS + ']')}]+`)],\n\t\t\tdiscardMatch\n\t\t),\n\t\t']'\n\t]),\n\tExpr = and(\n\t\t'Expr',\n\t\t[\n\t\t\t['ExprStart', EXPR_START, attachOffset],\n\t\t\tanyOne(\n\t\t\t\t'ExprBody',\n\t\t\t\t[\n\t\t\t\t\tEXPR_STR,\n\t\t\t\t\tExprObject,\n\t\t\t\t\tExprArray,\n\t\t\t\t\tmatch((EXPR_KEY_WORDS + EXPR_START[0]).split(''), discardMatch),\n\t\t\t\t\tnew RegExp(`[^${reEscape(EXPR_KEY_WORDS + EXPR_START[0] + EXPR_END[0])}]+`)\n\t\t\t\t],\n\t\t\t\tdiscardMatch\n\t\t\t),\n\t\t\t['ExprEnd', EXPR_END, attachOffset]\n\t\t],\n\t\t(data: any, len: number, ctx: MatchContext) => {\n\t\t\tconst content_start = data[0],\n\t\t\t\texpr_end = data[1]\n\t\t\tctx.add([\n\t\t\t\tctx.source.buff.substring(content_start, expr_end - EXPR_END_LEN),\n\t\t\t\tcontent_start - EXPR_START_LEN,\n\t\t\t\texpr_end\n\t\t\t])\n\t\t}\n\t)\n\nfunction createStringRule(name, mask, mline?) {\n\treturn and(\n\t\tname,\n\t\t[\n\t\t\tmatch(mask, attachOffset),\n\t\t\tanyOne([\n\t\t\t\tExpr,\n\t\t\t\tEXPR_START[0], // consume expr start char when parse expr failed\n\t\t\t\tnew RegExp(`(?:[^\\\\\\\\${mline ? '' : '\\\\n'}${mask}${reEscape(EXPR_START[0])}]|\\\\\\\\.)+`) // string fragment\n\t\t\t]),\n\t\t\tmatch(mask, attachOffset)\n\t\t],\n\t\t(data: any, len: number, ctx: MatchContext) => {\n\t\t\tconst buff = ctx.source.buff\n\t\t\tlet start = data[0],\n\t\t\t\tend = data[2] - 1,\n\t\t\t\texprs = data[1]\n\t\t\tif (exprs.length) {\n\t\t\t\tconst offset = start - 1\n\t\t\t\tvar i = 0,\n\t\t\t\t\tl = exprs.length,\n\t\t\t\t\testart\n\t\t\t\tconst expr = []\n\n\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\testart = exprs[i][1]\n\t\t\t\t\tif (start < estart) expr.push(exprStr(buff, start, estart))\n\t\t\t\t\texpr.push(`(${exprs[i][0]})`)\n\t\t\t\t\tstart = exprs[i][2]\n\t\t\t\t}\n\t\t\t\tif (start < end) expr.push(exprStr(buff, start, end))\n\n\t\t\t\tctx.add(['expr', expr.join(' + '), offset, end + 1])\n\t\t\t} else {\n\t\t\t\tctx.add(['string', buff.substring(start, end)])\n\t\t\t}\n\t\t}\n\t)\n\n\tfunction exprStr(buff, start, end) {\n\t\treturn `\"${escapeStr(buff.substring(start, end))}\"`\n\t}\n}\n\nconst ATTR_NAME = match('AttrName', /([@:$_a-zA-Z][\\w-\\.]*)\\s*/, 1),\n\tAttrValue = or(\n\t\t'AttrValue',\n\t\t[\n\t\t\tcreateStringRule('SQString', \"'\"),\n\t\t\tcreateStringRule('DQString', '\"'),\n\t\t\tcreateStringRule('MString', '`', true),\n\t\t\tand([Expr], attachValue('expr', expr => expr[0][0])),\n\t\t\tmatch('Number', /-?(0|[1-9]\\d*)(\\.\\d+)?([eE][+-]?\\d+)?/, '-0123456789', attachValue('number', num => +num)),\n\t\t\tmatch('NaN', attachStaticValue('number', NaN)),\n\t\t\tmatch('undefined', attachStaticValue('undefined', undefined)),\n\t\t\tmatch('null', attachStaticValue('null', undefined)),\n\t\t\tmatch('true', attachStaticValue('boolean', true)),\n\t\t\tmatch('false', attachStaticValue('boolean', false))\n\t\t],\n\t\tfalse,\n\t\t(data: any, len: number, ctx: MatchContext) => ctx.add(data[0])\n\t),\n\tAttrs = any(\n\t\t'Attrs',\n\t\t[ATTR_NAME, option('AttrValue', [[/=\\s*/, false, '=', discardMatch], AttrValue, /\\s*/])],\n\t\t(data, length, ctx) => {\n\t\t\tconst attrs = {}\n\t\t\tfor (let i = 0, l = data.length; i < l; i += 2) attrs[data[i]] = data[i + 1][0]\n\t\t\tctx.add(attrs)\n\t\t}\n\t)\n\nconst ELEM_NAME_REG = '[_a-zA-Z][\\\\w-]*',\n\tELEM_NAME = match('ElemName', new RegExp(`<(${ELEM_NAME_REG})\\\\s*`), 1, '<'),\n\tNodeCollection = anyOne('NodeCollection', () => [\n\t\tElem,\n\t\tand([Expr], (data: any, len: number, ctx: MatchContext) => {\n\t\t\tctx.add({ type: 'expr', data: data[0][0] })\n\t\t}),\n\t\tmatch('<', (data: any, len: number, ctx: MatchContext, rule: Rule) => {\n\t\t\t//consume one char when Elem match failed\n\t\t\tif (ctx.nextCode() === 47)\n\t\t\t\t// is close element\n\t\t\t\treturn rule.mkErr('expect: /<[^/]/', ctx)\n\t\t\tattachText(data, len, ctx) // not element\n\t\t}),\n\t\tmatch(EXPR_START[0], attachText), // consume one char when Expr match failed\n\t\tmatch(new RegExp(`[^\\\\\\\\<${reEscape(EXPR_START[0])}]+|\\\\\\\\${reEscape(EXPR_START[0])}`), attachText)\n\t]),\n\tElem = and(\n\t\t'Elem',\n\t\t[\n\t\t\tELEM_NAME,\n\t\t\tAttrs,\n\t\t\tor('ElemBody', [\n\t\t\t\tmatch(/\\/>\\s*/, false, '/', discardMatch),\n\t\t\t\tand('childNodes', [\n\t\t\t\t\tmatch(/>/, false, '>', discardMatch),\n\t\t\t\t\tNodeCollection,\n\t\t\t\t\toption([match('ElemClose', new RegExp(`<\\/(${ELEM_NAME_REG})>\\\\s*`), 1, '<')], (data, len, ctx) => {\n\t\t\t\t\t\tconst closeTag = data[0],\n\t\t\t\t\t\t\tpctx = ctx.parent.parent,\n\t\t\t\t\t\t\ttag = pctx.data[0]\n\n\t\t\t\t\t\tif (closeTag) {\n\t\t\t\t\t\t\tif (closeTag !== tag) {\n\t\t\t\t\t\t\t\tif (AutoCloseElems[tag]) {\n\t\t\t\t\t\t\t\t\tctx.reset()\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn `expect: </${tag}>`\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!AutoCloseElems[tag]) {\n\t\t\t\t\t\t\treturn `expect: </${tag}>`\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t])\n\t\t\t])\n\t\t],\n\t\t(data: any, len: number, ctx: MatchContext) => {\n\t\t\tconst tag = data[0],\n\t\t\t\tchildren = data[2][0] && data[2][0][0],\n\t\t\t\telem = { type: 'elem', tag, attrs: data[1], children }\n\n\t\t\tctx.add(elem)\n\n\t\t\tif (children && AutoCloseElems[tag]) {\n\t\t\t\tctx.addAll(children)\n\t\t\t\tchildren.length = 0\n\t\t\t}\n\t\t}\n\t)\n\nfunction attachText(text: string, length: number, ctx: MatchContext) {\n\tconst data = ctx.data,\n\t\tlen = data.length\n\tlet prev\n\tif (len && (prev = data[len - 1]) && prev.type === 'text') {\n\t\tprev.data += text\n\t} else {\n\t\tctx.add({ type: 'text', data: text })\n\t}\n}\n\nexport const ElemContent = and(\n\t'Elem-Content',\n\t[/\\s*/, many([Elem]), match('EOF', /\\s*$/, discardMatch)],\n\t(data: any, len: number, ctx: MatchContext) => {\n\t\tctx.addAll(data[0])\n\t}\n)\n\nElemContent.init()\n\n\nfunction attachValue(type, valHandler) {\n\treturn function(data: any, len: number, ctx: MatchContext) {\n\t\tctx.add([type, valHandler(data)])\n\t}\n}\n\nfunction attachStaticValue(type, val) {\n\treturn attachValue(type, v => v)\n}\n\nfunction attachOffset(data: any, len: number, ctx: MatchContext) {\n\tctx.add(ctx.currPos())\n}\n","/**\n * common utilities\n * @module utility\n * @preferred\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @created Wed Nov 21 2018 10:21:41 GMT+0800 (China Standard Time)\n * @modified Mon Dec 17 2018 14:47:42 GMT+0800 (China Standard Time)\n */\n\nexport * from './fn'\nexport * from './is'\nexport * from './reg'\nexport * from './proto'\nexport * from './prop'\nexport * from './propPath'\nexport * from './string'\nexport * from './format'\nexport * from './create'\nexport * from './assign'\nexport * from './collection'\nexport * from './List'\nexport * from './nextTick'\nexport * from './AST'\nexport * from './AST/test'\n\n","/**\n *\n * @author Tao Zeng <tao.zeng.zt@qq.com>\n * @module main\n * @preferred\n * @created Wed Nov 21 2018 10:21:20 GMT+0800 (China Standard Time)\n * @modified Thu Nov 22 2018 09:32:01 GMT+0800 (China Standard Time)\n */\n\nexport * from './utility'\n"],"names":["CONSTRUCTOR","PROTOTYPE","PROTO","TYPE_BOOL","TYPE_FN","TYPE_NUM","TYPE_STRING","TYPE_UNDEF","GLOBAL","window","global","self","eq","o1","o2","isNull","o","isUndef","undefined","isNil","isBool","mkIsPrimitive","isNum","isStr","isFn","isInt","isPrimitive","type","instOf","obj","Cls","is","Type","C","Object","Array","i","length","isBoolean","mkIs","Boolean","isNumber","Number","isString","String","isDate","Date","isReg","RegExp","isArray","isTypedArray","ArrayBuffer","isView","isArrayLike","NodeList","HTMLCollection","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","len","isObj","blankStrReg","isBlank","test","createFn","body","args","name","Function","join","applyScope","concat","applyBuilder","maxArgs","scope","offset","cases","slice","applyNoScope","applyScopeN","applyNoScopeN","apply","fn","applyN","varGenReg","fnName","replace","_bind","funcProto","bind","arguments","argLen","bindPolyfill","bindArgs","argOffset","params","regStickySupport","sticky","regUnicodeSupport","unicode","REG_ESCAPE","reEscape","str","__hasOwn","hasOwnProperty","__getProto","getPrototypeOf","____setProto","setPrototypeOf","prototypeOfSupport","protoPropSupport","__proto__","protoOf","call","__setProto","proto","setProto","p","hasOwnProp","prop","getOwnProp","defaultVal","__defProp","defineProperty","defPropSupport","val","get","set","value","s","e","desc","Error","defProp","defPropValue","configurable","writable","enumerable","__","doCreate","props","k","create","Control","toString","STOP","eachProps","callback","own","eachObj","eachArray","array","l","doEach","_eachArray","_eachObj","each","SKIP","doMapObj","copy","v","mapObj","doMapArray","j","data","index","mapArray","doMap","eacharray","eachobj","map","parseCallback","doIdxOfObj","idx","r","idxOfObj","doIdxOfArray","idxOfArray","doIdxOf","idxOf","doReduceObj","accumulator","rs","reduceObj","doReduceArray","reduceArray","doReduce","reduce","defaultObjKeyHandler","doObjKeys","handler","keys","defaultObjValueHandler","doObjValues","values","doArr2Obj","arr2obj","makeMap","split","makeArray","pathCache","pathReg","parsePath","path","cacheable","match","cidx","exec","lastIndex","SyntaxError","charAt","formatPath","formatPathHandler","attr","charCode","charCodeAt","char","code","fromCharCode","TRIM_REG","trim","FIRST_LOWER_LETTER_REG","upperFirst","upper","m","toUpperCase","lower","toLowerCase","strval","STR_ESCAPE_MAP","STR_ESCAPE","escapeStr","pad","chr","leftAlign","__pad","cut","suffix","substr","padding","thousandSeparate","mkSeparator","binarySeparate","octalSeparate","hexSeparate","group","valReg","reg","numStr","separatorHandler","d","PLURAL_REG","plural","pluralHandler","ies","es","ys","SINGULAR_REG","singular","singularHandler","FORMAT_XPREFIX","FORMAT_PLUS","FORMAT_ZERO","FORMAT_SPACE","FORMAT_SEPARATOR","FORMAT_LEFT","FLAG_MAPPING","parseFlags","f","flags","paramIdxR","paramPropR","widthR","fillR","cutSuffixR","formatReg","formatters","extendFormatter","fmt","getFormatter","vformat","getParam","start","defaultGetParam","param","paramProp","width","widx","wprop","fill","precision","pidx","pprop","cutSuffix","parseParam","parseWidth","w","isFinite","paramIdx","format","getFormatParam","GET_PARAM_VAR","GET_PROP_VAR","STATE_VAR","createFormatter","getParamCode","getWidthCode","def","formatter","lastIdx","mStart","mEnd","arr","codes","pushStr","substring","append","strFormatter","toStr","numFormatter","parseNum","getPrefix","separator","num","prefix","plen","decimalPrefix","BASE_RADIXS","b","u","x","BASE_PREFIXS","baseFormatter","base","n","__toStr","xprefix","floatFormatter","____toStr","toExponential","toFixed","toPrecision","parseFloat","toJSON","JSON","stringify","c","E","g","G","B","O","X","doAssign","target","overrides","filter","startOffset","endOffset","override","assign","defaultAssignFilter","assignIf","assignIfFilter","formatArgHandlers","parseMessage","msg","msgIdx","fs","assert","catchErr","checkErr","expect","err","message","ERROR","throwMsg","mkMsg","objFormatter","notThrow","extendAssert","condition","dmsg","Err","paramStr","cond","expr","extendAsserts","apis","TypeError","NULL","UNDEFINED","BOOLEAN","NUMBER","INTEGER","STRING","FUNCTION","ARRAY","TYPED_ARRAY","expectMsg","nul","nil","typeExpect","undef","bool","int","primitive","boolean","packTypeExpect","number","string","date","typedArray","arrayLike","nan","isNaN","finite","blank","less","greater","range","to","not","all","prototype","DEFAULT_BINDING","List","binding","scaning","size","has","node","add","__insert","tail","addFirst","insertAfter","__getNode","insertBefore","addAll","objs","__insertAll","addFirstAll","insertAfterAll","insertBeforeAll","prev","__siblingObj","next","first","head","last","cb","__doLazyRemove","toArray","remove","__remove","pop","clean","__lazyRemove","__clean","__initNode","siblingIdx","sibling","__doInsert","nodeHead","nodeTail","__prev","__doRemove","lazyRemoves","push","DEFAULT_FN_BINDING","DEFAULT_SCOPE_BINDING","FnList","fnBinding","scopeBinding","nodeMap","list","parseScope","id","nodeId","ret","DEFAULT_SCOPE_ID","scopeIdGenerator","fnIdGenerator","fnId","scopeId","ticks","pending","executeTick","flush","MutationObserver","counter","observer","textNode","document","createTextNode","observe","characterData","setTimeout","nextTick","clearTick","LINE_REG","Source","buff","lines","linePos","position","source","escape","line","toSourceStr","escapeSourceStr","sourceStr","t","eachCharCodes","ignoreCase","eachCharCode","mixin","behaviour","Class","MatchError","$ruleErr","capturable","context","rule","pos","startPos","defaultErr","defaultMatch","idGen","Rule","$rule","onMatch","onErr","mkErr","error","src","userErr","matched","getStart","startCodes","startCodeTest","nextCode","startCodeIdx","setStartCodes","setCodeIdx","mkExpr","setExpr","EXPECT","getExpr","MatchContext","orgPos","parent","advanced","codeCache","flushCache","commit","advance","reset","dataLen","resetData","getBuff","getOffset","currPos","nextChar","eof","datas","ComplexRule","repeat","builder","_Rule","notGreater","_this","repeatMatch","parse","errSource","ctx","unshift","init","rules","names","rnames","EXPECTS","getRules","stack","consume","AndRule","testRule","min","max","mlen","dlen","out","OrRule","starts","rStarts","upErr","MatchRule","comsume","CharMatchRule","allows","_MatchRule","chars","RegMatchRule","regexp","pick","pattern","multiline","stickyMatch","execMatch","spicker","pickNone","pickTestStr","picker","mkPicker","pickAll","end","StringMatchRule","_RegMatchRule","discardMatch","appendMatch","attachMatch","mkMatch","defaultOnMatch","isMatchPattern","isStrOrCodes","regMatch","strMatch","REG_ESPEC_CHARS","and","mkComplexRule","any","many","option","or","anyOne","manyOne","optionOne","defaultRepeat","rulesBuilder","_rule","EXPR_START","EXPR_END","AutoCloseElems","ContentElems","EXPR_START_LEN","EXPR_END_LEN","EXPR_KEY_WORDS","EXPR_KEYS","EXPR_STR","ExprObject","ExprArray","Expr","attachOffset","content_start","expr_end","createStringRule","mask","mline","exprs","estart","exprStr","ATTR_NAME","AttrValue","attachValue","attachStaticValue","NaN","Attrs","attrs","ELEM_NAME_REG","ELEM_NAME","NodeCollection","Elem","attachText","closeTag","pctx","tag","children","elem","text","ElemContent","valHandler"],"mappings":";;;;;;;;;;;;;;;;;;;;CAAA;;;;;;;AAQA,CAAO,IAAMA,WAAW,GAAG,aAApB;AAEP,CAAO,IAAMC,SAAS,GAAG,WAAlB;AAEP,CAAO,IAAMC,KAAK,GAAG,WAAd;AAEP,CAAO,IAAMC,SAAS,GAAG,SAAlB;AAEP,CAAO,IAAMC,OAAO,GAAG,UAAhB;AAEP,CAAO,IAAMC,QAAQ,GAAG,QAAjB;AAEP,CAAO,IAAMC,WAAW,GAAG,QAApB;AAEP,CAAO,IAAMC,UAAU,GAAG,WAAnB;AAEP,CAAO,IAAMC,MAAW,GACvB,OAAOC,MAAP,KAAkBF,UAAlB,GACGE,MADH,GAEG,OAAOC,MAAP,KAAkBH,UAAlB,GACAG,MADA,GAEA,OAAOC,IAAP,KAAgBJ,UAAhB,GACAI,IADA,GAEA,EAPG;;CCxBP;;;;;;;AAQA,CAEA;;;;;AAIA,CAAO,SAASC,EAAT,CAAYC,EAAZ,EAAqBC,EAArB,EAAuC;UACtCD,EAAE,KAAKC,EAAPD,IAAcA,EAAE,KAAKA,EAAPA,IAAaC,EAAE,KAAKA;;;CAI1C;;;CAGA;;CAEA;;;;AAGA,CAAO,SAASC,MAAT,CAAgBC,CAAhB,EAAiC;UAChCA,CAAC,KAAK;;CAGd;;;;AAGA,CAAO,SAASC,OAAT,CAAiBD,CAAjB,EAAkC;UACjCA,CAAC,KAAKE;;CAGd;;;;AAGA,CAAO,SAASC,KAAT,CAAeH,CAAf,EAAgC;UAC/BA,CAAC,KAAK,IAANA,IAAcA,CAAC,KAAKE;;CAG5B;;;;AAGA,KAAaE,MAA2B,GAAGC,aAAa,CAAClB,SAAD,CAAjD;CAEP;;;;AAGA,KAAamB,KAA0B,GAAGD,aAAa,CAAChB,QAAD,CAAhD;CAEP;;;;AAGA,KAAakB,KAA0B,GAAGF,aAAa,CAACf,WAAD,CAAhD;CAEP;;;;AAGA,KAAakB,IAAyB,GAAGH,aAAa,CAACjB,OAAD,CAA/C;CAEP;;;;AAGA,CAAO,SAASqB,KAAT,CAAeT,CAAf,EAAgC;UAC/BA,CAAC,KAAK,CAANA,KAAYA,CAAC,GAAG,OAAOA,CAAP,KAAaX,QAAb,IAAyBW,CAAC,GAAG,CAAJA,KAAU,CAAtC,GAA0C,KAAvDA;;CAGR;;;;;;;;;;AASA,CAAO,SAASU,WAAT,CAAqBV,CAArB,EAAsC;OACxCA,CAAC,KAAKE,SAANF,IAAmBA,CAAC,KAAK,MAAM;YAC3B;;;WAEA,OAAOA;UACTb;UACAE;UACAC;UACAF;cACG;;;UAEF;;;CAGR,SAASiB,aAAT,CAAuBM,IAAvB,EAA0D;UAClD,UAAYX,CAAZ,EAA6B;YAC5B,OAAOA,CAAP,KAAaW;CADrB;;;CAMD;;;CAGA;;CAEA;;;;;AAGA,CAAO,SAASC,MAAT,CAAgBC,GAAhB,EAA0BC,GAA1B,EAAkD;UACjDD,GAAG,KAAKX,SAARW,IAAqBA,GAAG,KAAK,IAA7BA,IAAqCA,GAAG,YAAYC;;CAG5D;;;;AAGA,CAAO,SAASC,EAAT,CAAYf,CAAZ,EAAoBgB,IAApB,EAA0D;OAC5DhB,CAAC,KAAKE,SAANF,IAAmBA,CAAC,KAAK,MAAM;SAC5BiB,CAAC,GAAGjB,CAAC,CAAChB,WAAD,CAADgB,IAAkBkB;;SACxBF,IAAI,CAAChC,WAAD,CAAJgC,KAAsBG,OAAO;WAC5BC,CAAC,GAAGJ,IAAI,CAACK;;cACND,CAAC,IAAI;aACPH,CAAC,KAAMD,IAAD,CAAqBI,CAArB,GAAyB;kBAC3B;;;CAJV,WAOO;cACCH,CAAC,KAAKD;;;;UAGR;;CAGR;;;;AAGA,KAAaM,SAA8B,GAAGC,IAAI,CAACC,OAAD,CAA3C;CAEP;;;;AAGA,KAAaC,QAA6B,GAAGF,IAAI,CAACG,MAAD,CAA1C;CAEP;;;;AAGA,KAAaC,QAA6B,GAAGJ,IAAI,CAACK,MAAD,CAA1C;CAEP;;;;AAGA,KAAaC,MAA2B,GAAGN,IAAI,CAACO,IAAD,CAAxC;CAEP;;;;AAGA,KAAaC,KAA0B,GAAGR,IAAI,CAACS,MAAD,CAAvC;CAEP;;;;AAGA,KAAaC,OAA4B,GAAGd,KAAK,CAACc,OAANd,IAAiBI,IAAI,CAACJ,KAAD,CAA1D;CAEP;;;;AAGA,KAAae,YAAiC,GAAG1B,IAAI,CAAC2B,WAAD,CAAJ3B,GAAoB2B,WAAW,CAACC,MAAhC5B,GAAyC;UAAM;CAAzF,CAAA;CAEP;;;;;;;;;;;AAUA,CAAO,SAAS6B,WAAT,CAAqBrC,CAArB,EAAsC;OACxCA,GAAG;aACEA,CAAC,CAAChB,WAAD;YACHmC;YACAS;YACApC,MAAM,CAAC8C;YACP9C,MAAM,CAAC+C;YACP/C,MAAM,CAACgD;YACPhD,MAAM,CAACiD;YACPjD,MAAM,CAACkD;YACPlD,MAAM,CAACmD;YACPnD,MAAM,CAACoD;YACPpD,MAAM,CAACqD;YACPrD,MAAM,CAACsD;YACPtD,MAAM,CAACuD;gBACJ;;;SAEHC,GAAG,GAAGhD,CAAC,CAACqB;YACP,OAAO2B,GAAP,KAAe3D,QAAf,KAA4B2D,GAAG,KAAK,CAARA,IAAcA,GAAG,GAAG,CAANA,IAAWA,GAAG,GAAG,CAANA,KAAY,CAAvBA,IAA4BA,GAAG,GAAG,CAANA,IAAWhD,CAAjF;;;UAEDA,CAAC,KAAK;;CAGd;;;;;AAIA,CAAO,SAASiD,KAAT,CAAejD,CAAf,EAAgC;OAClCA,CAAC,KAAKE,SAANF,IAAmBA,CAAC,KAAK,MAAM;YAC3B;;;OAEFiB,CAAC,GAAGjB,CAAC,CAAChB,WAAD;UACJiC,CAAC,KAAKf,SAANe,IAAmBA,CAAC,KAAKC;;;CAGjC,SAASK,IAAT,CAAcP,IAAd,EAAmD;UAC3C,UAAYhB,CAAZ,EAA6B;YAC5BA,CAAC,KAAKE,SAANF,IAAmBA,CAAC,KAAK,IAAzBA,IAAiCA,CAAC,CAAChB,WAAD,CAADgB,KAAmBgB;CAD5D;;;CAKD,IAAMkC,WAAW,GAAG,OAApB;CACA;;;;;;;AAMA,CAAO,SAASC,OAAT,CAAiBnD,CAAjB,EAAkC;OACpCA,GAAG;SACFA,CAAC,CAAChB,WAAD,CAADgB,KAAmB4B,QAAQ;cACvBsB,WAAW,CAACE,IAAZF,CAAiBlD,CAAjBkD;;;YAEDlD,CAAC,CAACqB,MAAFrB,KAAa;;;UAEd;;;CC1OR;;;;;;;AAQA;CAIA;;;CAGA;;CAEA;;;;;;;AAMA,CAAO,SAASqD,QAAT,CAAsCC,IAAtC,EAAoDC,IAApD,EAAqEC,IAArE,EAAuF;UACtFA,IAAI,GACRC,QAAQ,sBAAoBD,cAAQD,IAAI,GAAGA,IAAI,CAACG,IAALH,CAAU,IAAVA,CAAH,GAAqB,aAAOD,UAA5D,CAARG,EADQ,GAERE,UAAU,CAACF,QAAD,EAAWA,QAAX,EAAqBF,IAAI,IAAIA,IAAI,CAAClC,MAAbkC,GAAsBA,IAAI,CAACK,MAALL,CAAYD,IAAZC,CAAtBA,GAA0C,CAACD,IAAD,CAA/D;;;CAId;;;CAGA;;CAEA;;;;CAGA,SAASO,YAAT,CAA0CC,OAA1C,EAA2DC,KAA3D,EAAuEC,MAAvE,EAAuF;CACtFD,EAAAA,KAAK,GAAGA,KAAK,GAAG,OAAH,GAAa,EAA1BA;CACAC,EAAAA,MAAM,GAAGA,MAAM,GAAG,QAAH,GAAc,EAA7BA;OACMT,IAAI,GAAG,IAAIpC,KAAJ,CAAU2C,OAAO,GAAG,CAApB;OACPG,KAAK,GAAG,IAAI9C,KAAJ,CAAU2C,OAAO,GAAG,CAApB;;QACT,IAAI1C,CAAC,GAAG,GAAGA,CAAC,IAAI0C,SAAS1C,CAAC,IAAI;CAClCmC,IAAAA,IAAI,CAACnC,CAAD,CAAJmC,IAAanC,CAAC,IAAI2C,KAAL3C,GAAa,IAAbA,GAAoB,iBAAU4C,MAAM,eAAY5C,CAAC,GAAG,QAAQA,CAAX,GAAe,GAA5B,GAAmCA,QAApFmC;CACAU,IAAAA,KAAK,CAAC7C,CAAD,CAAL6C,aAAmB7C,qBAAe2C,KAAK,IAAI,iBAAWA,QAAQR,IAAI,CAACW,KAALX,CAAW,CAAXA,EAAcnC,CAAdmC,EAAiBG,IAAjBH,CAAsB,EAAtBA,QAA9DU;;;UAEMR,QAAQ,2BAAwBM,KAAK,IAAIA,KAAK,GAAG,kBAAWC,MAAM,IAAI,oCACrEA,MAAM,GAAG,KAAH,GAAW,0BACxBC,KAAK,CAACP,IAANO,CAAW,IAAXA,eAEAD,MAAM,+GAGUD,KAAK,IAAI,kBAAWC,MAAM,GAAG,KAAH,GAAW,iBAPvC,CAARP;;CAWR;;;;;;;;AAMA,KAAaE,UAAuE,GAAGE,YAAY,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAA5F;CAEP;;;;;;AAKA,KAAaM,YAA6D,GAAGN,YAAY,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAlF;CAEP;;;;;;;;;AAQA,KAAaO,WAML,GAAGP,YAAY,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CANhB;CAQP;;;;;;;;AAOA,KAAaQ,aAA2F,GAAGR,YAAY,CACtH,CADsH,EAEtH,CAFsH,EAGtH,CAHsH,CAAhH;CAMP;;;;;;;AAMA,CAAO,SAASS,KAAT,CAAeC,EAAf,EAA6BR,KAA7B,EAAyCR,IAAzC,EAAwE;OAC1EQ,KAAK,KAAK7D,SAAV6D,IAAuBA,KAAK,KAAK,IAAjCA,IAAyCA,KAAK,KAAKvE,QAAQ;YACvD2E,YAAY,CAACI,EAAD,EAAKhB,IAAI,IAAI,EAAb;;;UAEbI,UAAU,CAACY,EAAD,EAAKR,KAAL,EAAYR,IAAI,IAAI,EAApB;;CAGlB;;;;;;;;;AAQA,CAAO,SAASiB,MAAT,CAAgBD,EAAhB,EAA8BR,KAA9B,EAA0CR,IAA1C,EAAoES,MAApE,EAAoFhB,GAApF,EAAsG;OACxGe,KAAK,KAAK7D,SAAV6D,IAAuBA,KAAK,KAAK,IAAjCA,IAAyCA,KAAK,KAAKvE,QAAQ;YACvD6E,aAAa,CAACE,EAAD,EAAKhB,IAAL,EAAWS,MAAX,EAAmBhB,GAAnB;;;UAEdoB,WAAW,CAACG,EAAD,EAAKR,KAAL,EAAYR,IAAZ,EAAkBS,MAAlB,EAA0BhB,GAA1B;;;CAInB;;;CAGA;;CAEA,IAAMyB,SAAS,GAAG,QAAlB;CAEA;;;;AAGA,CAAO,SAASC,MAAT,CAAgBH,EAAhB,EAAsC;OACtCf,IAAY,GAAIe,EAAD,CAAYf;UAC1BA,IAAI,GAAGA,IAAI,CAACmB,OAALnB,CAAaiB,SAAbjB,EAAwB,EAAxBA,CAAH,GAAiC;;;CAI7C;;;CAGA;;CAEA,IAAIoB,KAAJ;;CACA,IAAMC,SAAS,GAAGpB,QAAQ,CAACxE,SAAD,CAA1B;;CACA,IAAI4F,SAAS,CAACC,IAAd,EAAoB;CACnBF,EAAAA,KAAK,GAAG,UAAkCL,EAAlC,EAAyCR,KAAzC,EAAwD;SACzDR,IAAI,GAAGwB;SACZC,MAAM,GAAGzB,IAAI,CAAClC;;SACXlB,KAAK,CAAC4D,KAAD,GAAS;cACViB,MAAM,GAAG,CAATA,GAAaC,YAAY,CAACV,EAAD,EAAKR,KAAL,EAAYR,IAAZ,EAAkB,CAAlB,CAAzByB,GAAgDT;;;YAEjDH,WAAW,CAACG,EAAE,CAACO,IAAJ,EAAUP,EAAV,EAAchB,IAAd,EAAoB,CAApB,EAAuByB,MAAM,GAAG,CAAhC;CANnB,GAAAJ;CADD,CAAA,MASO;CACNC,EAAAA,SAAS,CAACC,IAAVD,GAAiB,UAAcd,KAAd,EAAqB;YAC9BkB,YAAY,CAAC,IAAD,EAAOlB,KAAP,EAAcgB,SAAd,EAAyB,CAAzB;CADpB,GAAAF;;CAGAD,EAAAA,KAAK,GAAG,UAAkCL,EAAlC,EAAyCR,KAAzC,EAAwD;YACxDkB,YAAY,CAACV,EAAD,EAAKR,KAAL,EAAYgB,SAAZ,EAAuB,CAAvB;CADpB,GAAAH;;CAKD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,KAAaE,IAAkE,GAAGF,KAA3E;CAEP;;;;;;;;;;CASA,SAASK,YAAT,CAA0CV,EAA1C,EAAiDR,KAAjD,EAA6DmB,QAA7D,EAA2FC,SAA3F,EAAiH;OAC1GH,MAAM,GAAGE,QAAQ,CAAC7D,MAAT6D,GAAkBC;;OAC7BpB,KAAK,KAAK7D,WAAW;CACxB6D,IAAAA,KAAK,GAAG,IAARA;;;OAEGiB,MAAM,GAAG,GAAG;;YAER,YAAqB;WACrBzB,IAAI,GAAGwB;WACT3D,CAAC,GAAGmC,IAAI,CAAClC;;WACTD,GAAG;aACAgE,MAAM,GAAG,IAAIjE,KAAJ,CAAU6D,MAAM,GAAG5D,CAAnB;;gBACRA,CAAC,IAAI;CACXgE,UAAAA,MAAM,CAACJ,MAAM,GAAG5D,CAAV,CAANgE,GAAqB7B,IAAI,CAACnC,CAAD,CAAzBgE;;;CAEDhE,QAAAA,CAAC,GAAG4D,MAAJ5D;;gBACOA,CAAC,IAAI;CACXgE,UAAAA,MAAM,CAAChE,CAAD,CAANgE,GAAYF,QAAQ,CAAC9D,CAAC,GAAG+D,SAAL,CAApBC;;;gBAEMd,KAAK,CAACC,EAAD,EAAKR,KAAK,KAAK,IAAVA,GAAiB,IAAjBA,GAAwBA,KAA7B,EAAoCqB,MAApC,EATN;;;cAWAZ,MAAM,CAACD,EAAD,EAAKR,KAAK,KAAK,IAAVA,GAAiB,IAAjBA,GAAwBA,KAA7B,EAAoCmB,QAApC,EAA8CC,SAA9C,EAAyDH,MAAzD,EAdc;CAA5B;;;OAiBGjB,KAAK,KAAK,MAAM;YACZQ;;;OAEJR,KAAK,KAAKvE,QAAQ;;YAEd,YAAqB;cACpB2E,YAAY,CAACI,EAAD,EAAKQ,SAAL;CADpB;;;UAIM,YAAqB;YACpBpB,UAAU,CAACY,EAAD,EAAKR,KAAL,EAAYgB,SAAZ;CADlB;;;CCpPD;;;;;;;AAQA,CAEA;;;;AAGA,KAAaM,gBAAgB,GAAGjF,MAAM,CAAC,OAAOkF,MAAR,CAA/B;CAEP;;;;AAGA,KAAaC,iBAAiB,GAAGnF,MAAM,CAAC,OAAOoF,OAAR,CAAhC;CAEP,IAAMC,UAAU,GAAG,wBAAnB;CAEA;;;;AAGA,CAAO,SAASC,QAAT,CAAkBC,GAAlB,EAAuC;UACtCA,GAAG,CAAChB,OAAJgB,CAAYF,UAAZE,EAAwB,MAAxBA;;;CC1BR;;;;;;;AAOA,CAEA,IAAMC,QAAQ,GAAG1E,MAAM,CAACjC,SAAD,CAANiC,CAAkB2E,cAAnC;CACA,IAAMC,UAAU,GAAG5E,MAAM,CAAC6E,cAA1B;CAAA,IACCC,YAAY,GAAG9E,MAAM,CAAC+E,cADvB;CAGA;;;;AAGA,KAAaC,kBAAkB,GAAG,CAAC,CAACF,YAA7B;AAEP,KAAaG,gBAAgB,GAAG;CAAEC,EAAAA,SAAS,EAAE;CAAb,aAA6BjF,KAAtD;CAEP;;;;AAGA,KAAakF,OAAwB,GAAGL,YAAY,GACjDF,UADiD,GAEjDA,UAAU,GACV,UAAwBjF,GAAxB,EAA6B;UACtBA,GAAG,CAAC3B,KAAD,CAAH2B,IAAciF,UAAU,CAACjF,GAAD;CAFrB,CAAA,GAIV,UAAwBA,GAAxB,EAA6B;UACtB,CAAC+E,QAAQ,CAACU,IAATV,CAAc/E,GAAd+E,EAAmB1G,KAAnB0G,IAA4B/E,GAAG,CAAC3B,KAAD,CAA/B0G,GAAyC/E,GAAG,CAAC7B,WAAD,CAAH6B,CAAiB5B,SAAjB4B,CAA1C,KAA0E;CAP7E,CAAA;AAUP,KAAa0F,UAA4C,GACxDP,YAAY,IACZ,UAAwBnF,GAAxB,EAA6B2F,KAA7B,EAAoC;CACnC3F,EAAAA,GAAG,CAAC3B,KAAD,CAAH2B,GAAa2F,KAAb3F;UACOA;CAJF,CAAA;CAOP;;;;AAGA,KAAa4F,QAA0C,GACtDT,YAAY,KACXG,gBAAgB,GACdI,UADc,GAEd,UAAwB1F,GAAxB,EAA6B2F,KAA7B,EAAoC;QAC/B,IAAIE,KAAKF,OAAO;SAChBZ,QAAQ,CAACU,IAATV,CAAcY,KAAdZ,EAAqBc,CAArBd,GAAyB;CAC5B/E,MAAAA,GAAG,CAAC6F,CAAD,CAAH7F,GAAS2F,KAAK,CAACE,CAAD,CAAd7F;;;;UAGK0F,UAAU,CAAC1F,GAAD,EAAM2F,KAAN;CATR,CAAA,CADN;;CC3CP;;;;;;;AAOA,CAGA,IAAMZ,UAAQ,GAAG1E,MAAM,CAACjC,SAAD,CAANiC,CAAkB2E,cAAnC;CAEA;;;;AAGA,KAAac,UAA+C,GAAGR,gBAAgB,GAC5E,UAAoBtF,GAApB,EAA8B+F,IAA9B,EAAqD;UAC9ChB,UAAQ,CAACU,IAATV,CAAc/E,GAAd+E,EAAmBgB,IAAnBhB;CAFqE,CAAA,GAI5E,UAAoB/E,GAApB,EAA8B+F,IAA9B,EAAqD;UAC9CA,IAAI,KAAK1H,KAAT0H,IAAkBhB,UAAQ,CAACU,IAATV,CAAc/E,GAAd+E,EAAmBgB,IAAnBhB;CALrB,CAAA;CAQP;;;;;;AAKA,CAAO,SAASiB,UAAT,CAAoBhG,GAApB,EAA8B+F,IAA9B,EAA4CE,UAA5C,EAAmE;UAClEH,UAAU,CAAC9F,GAAD,EAAM+F,IAAN,CAAVD,GAAwB9F,GAAG,CAAC+F,IAAD,CAA3BD,GAAoCG;;CAG5C,IAAIC,SAAS,GAAG7F,MAAM,CAAC8F,cAAvB;CACA;;;;AAGA,KAAaC,cAAuB,GACnCF,SAAS,IACR,YAAW;OACP;SACCG;SACHrG,GAAQ,GAAG;;CACZkG,IAAAA,SAAS,CAAClG,GAAD,EAAM,GAAN,EAAW;CACnBsG,MAAAA,GADmB,iBACb;gBACED;CAFW,OAAA;CAInBE,MAAAA,GAJmB,eAIfC,OAAO;CACVH,QAAAA,GAAG,GAAGG,KAANH;;CALkB,KAAX,CAATH;;CAQAlG,IAAAA,GAAG,CAACyG,CAAJzG,GAAQ,CAARA;YACOA,GAAG,CAACyG,CAAJzG,KAAUqG;CAZlB,IAaE,OAAOK,CAAP,EAAU;CAdb,CAAC,EAFK;;CAmBP,IAAI,CAACN,cAAL,EAAqB;CACpBF,EAAAA,SAAS,GAAG,UACXlG,GADW,EAEX+F,IAFW,EAGXY,IAHW,EAIL;SACFA,IAAI,CAACL,GAALK,IAAYA,IAAI,CAACJ,KAAK;aACnB,IAAIK,KAAJ,CAAU,6CAAV;;;CAEP5G,IAAAA,GAAG,CAAC+F,IAAD,CAAH/F,GAAY2G,IAAI,CAACH,KAAjBxG;YACOA;CATR,GAAAkG;;CAaD;;;;;AAGA,KAAaW,OAAO,GAAGX,SAAhB;CAEP;;;;AAGA,KAAaY,YAOP,GAAGV,cAAc,GACpB,UAAsBpG,GAAtB,EAA2B+F,IAA3B,EAAiCS,KAAjC,EAAwCO,YAAxC,EAAsDC,QAAtD,EAAgEC,UAAhE,EAA4E;CAC5Ef,EAAAA,SAAS,CAAClG,GAAD,EAAM+F,IAAN,EAAY;CACpBS,IAAAA,KAAK,EAALA,KADoB;CAEpBS,IAAAA,UAAU,EAAEA,UAAU,KAAK,KAFP;CAGpBF,IAAAA,YAAY,EAAEA,YAAY,KAAK,KAHX;CAIpBC,IAAAA,QAAQ,EAAEA,QAAQ,KAAK;CAJH,GAAZ,CAATd;;UAMOM;CARa,CAAA,GAUpB,UAAsBxG,GAAtB,EAA2B+F,IAA3B,EAAiCS,KAAjC,EAAwC;CACxCxG,EAAAA,GAAG,CAAC+F,IAAD,CAAH/F,GAAYwG,KAAZxG;UACOwG;CAnBH,CAAA;;CC7EP;;;;;;;AAQA;CAIA,SAASU,EAAT,GAAc;CAEd;;;;;CAGA,SAASC,QAAT,CAAkBhI,CAAlB,EAAoCiI,KAApC,EAA2F;CAC1FF,EAAAA,EAAE,CAAC9I,SAAD,CAAF8I,GAAgB/H,CAAhB+H;OACMlH,GAAG,GAAG,IAAIkH,EAAJ;CACZA,EAAAA,EAAE,CAAC9I,SAAD,CAAF8I,GAAgB,IAAhBA;;OACIE,OAAO;cAELC,KAAKD,OAAO;WACZtB,UAAU,CAACsB,KAAD,EAAQC,CAAR,GAAY;CACzBR,QAAAA,OAAO,CAAC7G,GAAD,EAAMqH,CAAN,EAASD,KAAK,CAACC,CAAD,CAAd,CAAPR;;;;;UAII7G;;CAGR;;;;;AAGA,KAAasH,MAAM,GAAGjH,MAAM,CAACiH,MAAPjH,KACpBA,MAAM,CAAC6E,cAAP7E,GACE8G,QADF9G,GAEE,UAAgBlB,CAAhB,EAAkCiI,KAAlC,EAAyF;OACnFpH,GAAG,GAAGmH,QAAQ,CAAChI,CAAD,EAAIiI,KAAJ;;CACpB1B,EAAAA,UAAU,CAAC1F,GAAD,EAAMb,CAAN,CAAVuG;;UACO1F;CANW,CAAAK,CAAf;;CCnCP;;;;;;AAMA,KAAakH,OAAb;CAAA;CAAA;oBAEaZ,MAAc;UACpBA,OAAOA;;;;;UAEba,+BAAW;YACH,KAAKb;CANd;;;EAAA;;CCNA;;;;;;AAMA,CAMA;;;;;AAIA,KAAac,IAAI,GAAG,IAAIF,OAAJ,CAAY,MAAZ,CAAb;;CAEP;;;CAGA;;CAEA;;;;;AAiBA,CAAO,SAASG,SAAT,CAAmB1H,GAAnB,EAAgC2H,QAAhC,EAA4DzE,KAA5D,EAAyE0E,GAAzE,EAAwG;OAC1GrI,MAAM,CAAC2D,KAAD,GAAS;CAClB0E,IAAAA,GAAG,GAAG1E,KAAN0E;CADD,SAEO;CACND,IAAAA,QAAQ,GAAG1D,IAAI,CAAC0D,QAAD,EAAWzE,KAAX,CAAfyE;;;OAGGC,GAAG,KAAK,OAAO;cACbP,KAAKrH;WAAS2H,QAAQ,CAACN,CAAD,EAAIrH,GAAJ,CAAR2H,KAAqBF,MAAM,OAAOJ,CAAP;;CAD/C,SAEO;UACDA,KAAKrH;WAAS8F,UAAU,CAAC9F,GAAD,EAAMqH,CAAN,CAAVvB,IAAsB6B,QAAQ,CAACN,CAAD,EAAIrH,GAAJ,CAAR2H,KAAqBF,MAAM,OAAOJ,CAAP;;;;UAE9D;;;CAIR;;;CAGA;;CAEA;;;;;AAiBA,CAAO,SAASQ,OAAT,CAAiB7H,GAAjB,EAA8B2H,QAA9B,EAAyDzE,KAAzD,EAAsE0E,GAAtE,EAAqG;AAC9F1D;OACT3E,MAAM,CAAC2D,KAAD,GAAS;CAClB0E,IAAAA,GAAG,GAAG1E,KAAN0E;CADD,SAEO;CACND,IAAAA,QAAQ,GAAG1D,IAAI,CAAC0D,QAAD,EAAWzE,KAAX,CAAfyE;;;OAGGC,GAAG,KAAK,OAAO;cACbP,KAAKrH;WAAS2H,QAAQ,CAAC3H,GAAG,CAACqH,CAAD,CAAJ,EAASA,CAAT,EAAYrH,GAAZ,CAAR2H,KAA6BF,MAAM,OAAOJ,CAAP;;CADvD,SAEO;UACDA,KAAKrH;WAAS8F,UAAU,CAAC9F,GAAD,EAAMqH,CAAN,CAAVvB,IAAsB6B,QAAQ,CAAC3H,GAAG,CAACqH,CAAD,CAAJ,EAASA,CAAT,EAAYrH,GAAZ,CAAR2H,KAA6BF,MAAM,OAAOJ,CAAP;;;;UAEtE;;;CAIR;;;CAGA;;CAEA;;;;;CAMA;;;;;;;;;AAQA,CAAO,SAASS,SAAT,CAAmBC,KAAnB,EAAkCJ,QAAlC,EAA+DzE,KAA/D,EAA4F;CAClGyE,EAAAA,QAAQ,GAAG1D,IAAI,CAAC0D,QAAD,EAAWzE,KAAX,CAAfyE;;QACK,IAAIpH,CAAC,GAAG,CAAR,EAAWyH,CAAC,GAAGD,KAAK,CAACvH,QAAQD,CAAC,GAAGyH,GAAGzH,CAAC,IAAI;SACzCoH,QAAQ,CAACI,KAAK,CAACxH,CAAD,CAAN,EAAWA,CAAX,EAAcwH,KAAd,CAARJ,KAAiCF,MAAM,OAAOlH,CAAP;;;UAErC;;AAGR;CAgBA;;;CAGA;;AAuCA,CAAO,SAAS0H,MAAT,CACNC,UADM,EAENC,QAFM,EAGNnI,GAHM,EAIN2H,QAJM,EAKNzE,KALM,EAMN0E,GANM,EAOoB;OACtBpG,WAAW,CAACxB,GAAD,GAAO,OAAOkI,UAAU,CAAClI,GAAD,EAAM2H,QAAN,EAAgBzE,KAAhB,CAAjB;UACfiF,QAAQ,CAACnI,GAAD,EAAM2H,QAAN,EAAgBzE,KAAhB,EAAuB0E,GAAvB;;CAGhB;;;;;;;;;;AAwBA,CAAO,SAASQ,IAAT,CAAcpI,GAAd,EAAwB2H,QAAxB,EAAuCzE,KAAvC,EAAoD0E,GAApD,EAA4F;UAC3FK,MAAM,CAACH,SAAD,EAAYD,OAAZ,EAAqB7H,GAArB,EAA0B2H,QAA1B,EAAoCzE,KAApC,EAA2C0E,GAA3C;;;CCzNd;;;;;;AAOA,CAOA;;;;;AAIA,KAAaS,IAAI,GAAG,IAAId,OAAJ,CAAY,MAAZ,CAAb;;CAGP;;;CAGA;;CAEA;;;;;;;;;AAuBA,CAAO,SAASe,QAAT,CACNF,OADM,EAENpI,GAFM,EAGN2H,QAHM,EAINzE,KAJM,EAKN0E,GALM,EAMiB;OACnBrI,MAAM,CAAC2D,KAAD,GAAS;CAClB0E,IAAAA,GAAG,GAAG1E,KAAN0E;CADD,SAEO;CACND,IAAAA,QAAQ,GAAG1D,IAAI,CAAC0D,QAAD,EAAWzE,KAAX,CAAfyE;;;OAEKY,IAA0B,GAAGjB,MAAM,CAAC,IAAD;CACzCc,EAAAA,OAAI,CACHpI,GADG,EAEH,UAACwG,KAAD,EAAQT,IAAR,EAAc/F,GAAd,EAAsB;SACfwI,CAAC,GAAGb,QAAQ,CAACnB,KAAD,EAAQT,IAAR,EAAc/F,GAAd;SACdwI,CAAC,KAAKf,MAAM,OAAOA,IAAP;SACZe,CAAC,KAAKH,MAAME,IAAI,CAACxC,IAAD,CAAJwC,GAAaC,CAAbD;CALd,GAAA,EAOH,IAPG,EAQHX,GARG,CAAJQ;UAUOG;;CAGR;;;;;;;;;;AAWA,CAAO,SAASE,MAAT,CAAmBzI,GAAnB,EAAgC2H,QAAhC,EAA6DzE,KAA7D,EAA0E0E,GAA1E,EAA+G;UAC9GU,QAAQ,CAACT,OAAD,EAAU7H,GAAV,EAAe2H,QAAf,EAAyBzE,KAAzB,EAAgC0E,GAAhC;;;CAIhB;;;CAGA;;CAEA;;;;;;;;;AAUA,CAAO,SAASc,UAAT,CAAuBN,OAAvB,EAA+CL,KAA/C,EAA8DJ,QAA9D,EAA6FzE,KAA7F,EAA+G;CACrHyE,EAAAA,QAAQ,GAAG1D,IAAI,CAAC0D,QAAD,EAAWzE,KAAX,CAAfyE;OACMY,IAAS,GAAG;OACdI,CAAC,GAAG;CACRP,EAAAA,OAAI,CAACL,KAAD,EAAQ,UAACa,IAAD,EAAOC,KAAP,EAAcd,KAAd,EAAwB;SAC7BS,CAAC,GAAGb,QAAQ,CAACiB,IAAD,EAAOC,KAAP,EAAcd,KAAd;SACdS,CAAC,KAAKf,MAAM,OAAOA,IAAP;SACZe,CAAC,KAAKH,MAAME,IAAI,CAACI,CAAC,EAAF,CAAJJ,GAAYC,CAAZD;CAHb,GAAA,CAAJH;UAKOG;;CAGR;;;;;;;;;;AASA,CAAO,SAASO,QAAT,CAAqBf,KAArB,EAAoCJ,QAApC,EAAmEzE,KAAnE,EAAqF;UACpFwF,UAAU,CAACZ,SAAD,EAAYC,KAAZ,EAAmBJ,QAAnB,EAA6BzE,KAA7B;;AAGlB;CAcA;;;CAGA;;AAuCA,CAAO,SAAS6F,KAAT,CACNC,SADM,EAENC,OAFM,EAGNjJ,GAHM,EAIN2H,QAJM,EAKNzE,KALM,EAMN0E,GANM,EAOyB;OAC3BpG,WAAW,CAACxB,GAAD,GAAO,OAAO0I,UAAU,CAACM,SAAD,EAAYhJ,GAAZ,EAAiB2H,QAAjB,EAA2BzE,KAA3B,CAAjB;UACfoF,QAAQ,CAACW,OAAD,EAAUjJ,GAAV,EAAe2H,QAAf,EAAyBzE,KAAzB,EAAgC0E,GAAhC;;CAGhB;;;;;;;;;;;AAwBA,CAAO,SAASsB,GAAT,CAAgBlJ,GAAhB,EAAsC2H,QAAtC,EAAqDzE,KAArD,EAAkE0E,GAAlE,EAA6G;UAC5GmB,KAAK,CAACjB,SAAD,EAAYD,OAAZ,EAAqB7H,GAArB,EAA0B2H,QAA1B,EAAoCzE,KAApC,EAA2C0E,GAA3C;;;CChOb;;;;;;AAQA;CAKA,SAASuB,aAAT,CAAuB3C,KAAvB,EAAmCtD,KAAnC,EAA+C;OAC1CvD,IAAI,CAAC6G,KAAD,GAAS,OAAOvC,IAAI,CAACuC,KAAD,EAAQtD,KAAR,CAAX;UACV,UAAwB0F,IAAxB,EAAwC;YACvC7J,EAAE,CAAC6J,IAAD,EAAOpC,KAAP;CADV;;;CAMD;;;CAGA;;CAEA;;;;;;;;;;;;;AAuBA,CAAO,SAAS4C,UAAT,CACNhB,OADM,EAENpI,GAFM,EAGNwG,KAHM,EAINtD,KAJM,EAKN0E,GALM,EAMQ;OACVrI,MAAM,CAAC2D,KAAD,GAAS;CAClB0E,IAAAA,GAAG,GAAG1E,KAAN0E;CACA1E,IAAAA,KAAK,GAAG,IAARA;;;OAEKyE,QAA0B,GAAGwB,aAAa,CAAC3C,KAAD,EAAQtD,KAAR;OAC5CmG,GAAgB,GAAG,CAAC;CACxBjB,EAAAA,OAAI,CACHpI,GADG,EAEH,UAAC4I,IAAD,EAAO7C,IAAP,EAAa/F,GAAb,EAAqB;SACdsJ,CAAC,GAAG3B,QAAQ,CAACiB,IAAD,EAAO7C,IAAP,EAAa/F,GAAb;;SACdsJ,CAAC,KAAK,MAAM;CACfD,MAAAA,GAAG,GAAGtD,IAANsD;cACO5B;CAFR,WAGO,IAAI6B,CAAC,KAAK7B,IAAV,EAAgB,OAAO6B,CAAP;CAPrB,GAAA,EASH,IATG,EAUH1B,GAVG,CAAJQ;UAYOiB;;CAGR;;;;;;;;;;AAYA,CAAO,SAASE,QAAT,CAAkBvJ,GAAlB,EAA+BwG,KAA/B,EAA8DtD,KAA9D,EAA2E0E,GAA3E,EAAuG;UACtGwB,UAAU,CAACvB,OAAD,EAAU7H,GAAV,EAAewG,KAAf,EAAsBtD,KAAtB,EAA6B0E,GAA7B;;;CAIlB;;;CAGA;;CAEA;;;;;;;;;;;;AAeA,CAAO,SAAS4B,YAAT,CACNpB,OADM,EAENL,KAFM,EAGNvB,KAHM,EAINtD,KAJM,EAKG;OACHyE,QAA4B,GAAGwB,aAAa,CAAC3C,KAAD,EAAQtD,KAAR;OAC9CmG,GAAG,GAAG,CAAC;CACXjB,EAAAA,OAAI,CAACL,KAAD,EAAQ,UAACa,IAAD,EAAOC,KAAP,EAAcd,KAAd,EAAwB;SAC7BuB,CAAC,GAAG3B,QAAQ,CAACiB,IAAD,EAAOC,KAAP,EAAcd,KAAd;;SACduB,CAAC,KAAK,MAAM;CACfD,MAAAA,GAAG,GAAGR,KAANQ;cACO5B;CAFR,WAGO,IAAI6B,CAAC,KAAK7B,IAAV,EAAgB,OAAO6B,CAAP;CALpB,GAAA,CAAJlB;UAOOiB;;CAGR;;;;;;;;;AAUA,CAAO,SAASI,UAAT,CAAoB1B,KAApB,EAAmCvB,KAAnC,EAAoEtD,KAApE,EAAyF;UACxFsG,YAAY,CAAC1B,SAAD,EAAYC,KAAZ,EAAmBvB,KAAnB,EAA0BtD,KAA1B;;AAGpB;CAeA;;;CAGA;CACA;;AAsDA,CAAO,SAASwG,OAAT,CACNV,SADM,EAENC,OAFM,EAGNjJ,GAHM,EAINwG,KAJM,EAKNtD,KALM,EAMN0E,GANM,EAOY;OACdpG,WAAW,CAACxB,GAAD,GAAO,OAAOwJ,YAAY,CAACR,SAAD,EAAYhJ,GAAZ,EAAiBwG,KAAjB,EAAwBtD,KAAxB,CAAnB;UACfkG,UAAU,CAACH,OAAD,EAAUjJ,GAAV,EAAewG,KAAf,EAAsBtD,KAAtB,EAA6B0E,GAA7B;;CAGlB;;;;;;;;;;AA0BA,CAAO,SAAS+B,KAAT,CAAe3J,GAAf,EAAqCwG,KAArC,EAAiDtD,KAAjD,EAA8D0E,GAA9D,EAA8F;UAC7F8B,OAAO,CAAC5B,SAAD,EAAYD,OAAZ,EAAqB7H,GAArB,EAA0BwG,KAA1B,EAAiCtD,KAAjC,EAAwC0E,GAAxC;;;CClQf;;;;;;AAOA;CAMA;;;CAGA;;CAEA;;;;;AAqBA,CAAO,SAASgC,WAAT,CACNxB,OADM,EAENpI,GAFM,EAGN6J,WAHM,EAINlC,QAJM,EAKNzE,KALM,EAMN0E,GANM,EAOF;OACArI,MAAM,CAAC2D,KAAD,GAAS;CAClB0E,IAAAA,GAAG,GAAG1E,KAAN0E;CADD,SAEO;CACND,IAAAA,QAAQ,GAAG1D,IAAI,CAAC0D,QAAD,EAAWzE,KAAX,CAAfyE;;;CAEDS,EAAAA,OAAI,CACHpI,GADG,EAEH,UAACwG,KAAD,EAAQT,IAAR,EAAc/F,GAAd,EAAsB;SACf8J,EAAE,GAAGnC,QAAQ,CAACkC,WAAD,EAAcrD,KAAd,EAAqBT,IAArB,EAA2B/F,GAA3B;SACf8J,EAAE,KAAKrC,MAAM,OAAOA,IAAP;CACjBoC,IAAAA,WAAW,GAAGC,EAAdD;CALE,GAAA,EAOH,IAPG,EAQHjC,GARG,CAAJQ;UAUOyB;;CAGR;;;;;;;;;;AAWA,CAAO,SAASE,SAAT,CACN/J,GADM,EAEN6J,WAFM,EAGNlC,QAHM,EAINzE,KAJM,EAKN0E,GALM,EAMF;UACGgC,WAAW,CAAC/B,OAAD,EAAU7H,GAAV,EAAe6J,WAAf,EAA4BlC,QAA5B,EAAsCzE,KAAtC,EAA6C0E,GAA7C;;;CAGnB;;;CAGA;;CAEA;;;;;AAMA,CAAO,SAASoC,aAAT,CACN5B,OADM,EAENL,KAFM,EAGN8B,WAHM,EAINlC,QAJM,EAKNzE,KALM,EAMF;CACJyE,EAAAA,QAAQ,GAAG1D,IAAI,CAAC0D,QAAD,EAAWzE,KAAX,CAAfyE;CACAS,EAAAA,OAAI,CAACL,KAAD,EAAQ,UAACa,IAAD,EAAOC,KAAP,EAAcd,KAAd,EAAwB;SAC7B+B,EAAE,GAAGnC,QAAQ,CAACkC,WAAD,EAAcjB,IAAd,EAAoBC,KAApB,EAA2Bd,KAA3B;SACf+B,EAAE,KAAKrC,MAAM,OAAOA,IAAP;CACjBoC,IAAAA,WAAW,GAAGC,EAAdD;CAHG,GAAA,CAAJzB;UAKOyB;;CAGR;;;;;;;;;AAQA,CAAO,SAASI,WAAT,CAAwBlC,KAAxB,EAAuC8B,WAAvC,EAAuDlC,QAAvD,EAAyFzE,KAAzF,EAAyG;UACxG8G,aAAa,CAAClC,SAAD,EAAYC,KAAZ,EAAmB8B,WAAnB,EAAgClC,QAAhC,EAA0CzE,KAA1C;;AAGrB;CAaA;;;CAGA;;AA4CA,CAAO,SAASgH,QAAT,CACNlB,SADM,EAENC,OAFM,EAGNjJ,GAHM,EAIN6J,WAJM,EAKNlC,QALM,EAMNzE,KANM,EAON0E,GAPM,EAQF;OACApG,WAAW,CAACxB,GAAD,GACd,OAAOgK,aAAa,CAAChB,SAAD,EAAYhJ,GAAZ,EAA2B6J,WAA3B,EAAwClC,QAAxC,EAA4EzE,KAA5E,CAApB;UACM0G,WAAW,CAACX,OAAD,EAAUjJ,GAAV,EAAyB6J,WAAzB,EAAsClC,QAAtC,EAAwEzE,KAAxE,EAA+E0E,GAA/E;;CAGnB;;;;;;;;;;AAyBA,CAAO,SAASuC,MAAT,CACNnK,GADM,EAEN6J,WAFM,EAGNlC,QAHM,EAINzE,KAJM,EAKN0E,GALM,EAMF;UACGsC,QAAQ,CAACpC,SAAD,EAAYD,OAAZ,EAAqB7H,GAArB,EAA0B6J,WAA1B,EAAuClC,QAAvC,EAAiDzE,KAAjD,EAAwD0E,GAAxD;;;CCvOhB;;;;;;AAOA;CAMA;;;CAGA;;CAIA,SAASwC,oBAAT,CAA8BrE,IAA9B,EAA8D;UACtDA;;;AAkBR,CAAO,SAASsE,SAAT,CAAsBjC,OAAtB,EAA8CpI,GAA9C,EAAgE;OAChE8J,EAAO,GAAG;OACfpH,IAAI,GAAGwB;OACJoG,OAAyB,GAAGF;OAC/B7J,CAAC,GAAG;OACJoI,CAAC,GAAG;;OACDhJ,IAAI,CAAC+C,IAAI,CAACnC,CAAD,CAAL,GAAW;CAClB+J,IAAAA,OAAO,GAAG5H,IAAI,CAACnC,CAAC,EAAF,CAAd+J;SACI,CAAC/K,MAAM,CAACmD,IAAI,CAACnC,CAAD,CAAL,GAAW+J,OAAO,GAAGrG,IAAI,CAACqG,OAAD,EAAU5H,IAAI,CAACnC,CAAC,EAAF,CAAd,CAAd+J;;;CAEvBlC,EAAAA,OAAI,CACHpI,GADG,EAEH,UAAC+F,IAAD,EAAO/F,GAAP,EAAe;SACRqG,GAAG,GAAGiE,OAAO,CAACvE,IAAD,EAAO/F,GAAP;SACfqG,GAAG,KAAKoB,MAAM,OAAOA,IAAP;SACdpB,GAAG,KAAKgC,MAAMyB,EAAE,CAACnB,CAAC,EAAF,CAAFmB,GAAUzD,GAAVyD;CALhB,GAAA,EAOH,IAPG,EAQHpH,IAAI,CAACnC,CAAD,CARD,CAAJ6H;UAUO0B;;CAGR;;;;;;;AASA,CAAO,SAASS,IAAT,CAAiBvK,GAAjB,EAA8B2H,QAA9B,EAAqEzE,KAArE,EAAkF0E,GAAlF,EAAsG;UACrGyC,SAAS,CAAC3C,SAAD,EAAY1H,GAAZ,EAAiB2H,QAAjB,EAA2BzE,KAA3B,EAAkC0E,GAAlC;;;CAIjB;;;CAGA;;CAIA,SAAS4C,sBAAT,CAAgChE,KAAhC,EAA4E;UACpEA;;;AAkBR,CAAO,SAASiE,WAAT,CAAwBrC,OAAxB,EAA8CpI,GAA9C,EAAgE;OAChE8J,EAAO,GAAG;OACfpH,IAAI,GAAGwB;OACJoG,OAA2B,GAAGE;OACjCjK,CAAC,GAAG;OACJoI,CAAC,GAAG;;OACDhJ,IAAI,CAAC+C,IAAI,CAACnC,CAAD,CAAL,GAAW;CAClB+J,IAAAA,OAAO,GAAG5H,IAAI,CAACnC,CAAC,EAAF,CAAd+J;SACI,CAAC/K,MAAM,CAACmD,IAAI,CAACnC,CAAD,CAAL,GAAW+J,OAAO,GAAGrG,IAAI,CAACqG,OAAD,EAAU5H,IAAI,CAACnC,CAAC,EAAF,CAAd,CAAd+J;;;CAEvBlC,EAAAA,OAAI,CACHpI,GADG,EAEH,UAAS4I,IAAT,EAAe7C,IAAf,EAAqB/F,GAArB,EAA0B;SACnBqG,GAAG,GAAGiE,OAAO,CAAC1B,IAAD,EAAO7C,IAAP,EAAa/F,GAAb;SACfqG,GAAG,KAAKoB,MAAM,OAAOA,IAAP;SACdpB,GAAG,KAAKgC,MAAMyB,EAAE,CAACnB,CAAC,EAAF,CAAFmB,GAAUzD,GAAVyD;CALhB,GAAA,EAOH,IAPG,EAQHpH,IAAI,CAACnC,CAAD,CARD,CAAJ6H;UAUO0B;;CAGR;;;;;;;AASA,CAAO,SAASY,MAAT,CAAmB1K,GAAnB,EAAgC2H,QAAhC,EAAyEzE,KAAzE,EAAsF0E,GAAtF,EAA0G;UACzG6C,WAAW,CAAC5C,OAAD,EAAU7H,GAAV,EAAe2H,QAAf,EAAyBzE,KAAzB,EAAgC0E,GAAhC;;;CCvInB;;;;;;AAQA,CAMA;;;;AAKA,CAAO,SAAS+C,SAAT,CAAmBvC,OAAnB,EAA2CL,KAA3C,EAA0DJ,QAA1D,EAAqFzE,KAArF,EAA0G;OAC1GlD,GAAG,GAAGsH,MAAM,CAAC,IAAD;CAClBK,EAAAA,QAAQ,GAAG1D,IAAI,CAAC0D,QAAD,EAAWzE,KAAX,CAAfyE;CACAS,EAAAA,OAAI,CAACL,KAAD,EAAQ,UAACa,IAAD,EAAOC,KAAP,EAAcd,KAAd,EAAwB;SAC7BuB,CAA0B,GAAG3B,QAAQ,CAACiB,IAAD,EAAOC,KAAP,EAAcd,KAAd;;SACvC3G,OAAO,CAACkI,CAAD,GAAK;CACftJ,MAAAA,GAAG,CAACsJ,CAAC,CAAC,CAAD,CAAF,CAAHtJ,GAAYsJ,CAAC,CAAC,CAAD,CAAbtJ;CADD,WAEO;cACCsJ;;CALL,GAAA,CAAJlB;UAQOpI;;CAGR;;;;AAGA,CAAO,SAAS4K,OAAT,CAAiB7C,KAAjB,EAAgCJ,QAAhC,EAA2DzE,KAA3D,EAAgF;UAC/EyH,SAAS,CAAC7C,SAAD,EAAYC,KAAZ,EAAmBJ,QAAnB,EAA6BzE,KAA7B;;CAGjB;;;;;;;AAQA,CAAO,SAAS2H,OAAT,CAAiB9C,KAAjB,EAAgC1B,GAAhC,EAA2CyE,KAA3C,EAAmE;OACrEpL,KAAK,CAACqI,KAAD,GAASA,KAAK,GAAIA,KAAD,CAAkB+C,KAAjB/C,CAAuBrI,KAAK,CAACoL,KAAD,CAALpL,GAAeoL,KAAfpL,GAAuB,GAA9CqI,CAATA;UACX6C,OAAO,CAAC7C,KAAD,EAAQpI,IAAI,CAAC0G,GAAD,CAAJ1G,GAAY0G,GAAZ1G,GAAkB,UAAAiJ,IAAA;YAAQ,CAACA,IAAD,EAAOvC,GAAP;CAAlC,GAAA;;;CClDf;;;;;;AAOA,CAMO,SAAS0E,SAAT,CAAsB5I,GAAtB,EAAmCwF,QAAnC,EAAwE;OACxEI,KAAK,GAAG,IAAIzH,KAAJ,CAAU6B,GAAV;OACV5B,CAAC,GAAG4B;;UACD5B,CAAC;CAAIwH,IAAAA,KAAK,CAACxH,CAAD,CAALwH,GAAWJ,QAAQ,CAACpH,CAAD,CAAnBwH;;;UACLA;;;CCjBR;;;;;;AAOA,CAIA,IAAMiD,SAAsC,GAAG1D,MAAM,CAAC,IAAD,CAArD;;CAGA,IAAM2D,OAAO,GAAG,yFAAhB;AAGA,CAAO,SAASC,SAAT,CAAmBC,IAAnB,EAAyBC,SAAzB,EAAoC;OACtChK,OAAO,CAAC+J,IAAD,GAAQ,OAAOA,IAAP;OAEfpD,KAAK,GAAGiD,SAAS,CAACG,IAAD;;OACjB,CAACpD,OAAO;CACXA,IAAAA,KAAK,GAAG,EAARA;SACIsD;SACHhC,GAAG,GAAG;SACNiC;SACA/K,CAAC,GAAG;;YACG8K,KAAK,GAAGJ,OAAO,CAACM,IAARN,CAAaE,IAAbF,GAAqB;CACpCK,MAAAA,IAAI,GAAGL,OAAO,CAACO,SAAfF;;WACIA,IAAI,KAAKjC,GAAG,GAAGgC,KAAK,CAAC,CAAD,CAALA,CAAS7K,QAAQ;eAC7B,IAAIiL,WAAJ,sBAAkCN,iCAA2BA,IAAI,CAACO,MAALP,CAAY9B,GAAZ8B,qBAA+B9B,GAA5F;;;CAEPtB,MAAAA,KAAK,CAACxH,CAAC,EAAF,CAALwH,GAAasD,KAAK,CAAC,CAAD,CAALA,IAAYA,KAAK,CAAC,CAAD,CAAjBA,IAAwBA,KAAK,CAAC,CAAD,CAA7BA,IAAoCA,KAAK,CAAC,CAAD,CAAtDtD;CACAsB,MAAAA,GAAG,GAAGiC,IAANjC;;;SAEG+B,SAAS,KAAK,OAAO,OAAOrD,KAAP;CACzBiD,IAAAA,SAAS,CAACG,IAAD,CAATH,GAAkBjD,KAAlBiD;;;UAEMjD,KAAK,CAAC1E,KAAN0E;;AAGR,CAAO,SAAS4D,UAAT,CAAoBR,IAApB,EAAqD;UACpD/J,OAAO,CAAC+J,IAAD,CAAP/J,GAAgB0H,QAAQ,CAACqC,IAAD,EAAOS,iBAAP,CAAR9C,CAAkCjG,IAAlCiG,CAAuC,EAAvCA,CAAhB1H,GAA8D+J;;;CAGtE,SAASS,iBAAT,CAA2B7F,IAA3B,EAAiD;kBACpChF,MAAM,CAACgF,IAAD,CAANhF,CAAa+C,OAAb/C,CAAqB,GAArBA,EAA0B,KAA1BA;;;AAGb,CAAO,SAASuF,GAAT,CAAatG,GAAb,EAAkBmL,IAAlB,EAAwB;CAC9BA,EAAAA,IAAI,GAAGD,SAAS,CAACC,IAAD,CAAhBA;OACMnD,CAAC,GAAGmD,IAAI,CAAC3K,MAAL2K,GAAc;OACpBnD,CAAC,KAAK,CAAC,GAAG,OAAOhI,GAAP;OACVO,CAAC,GAAG;;UACDA,CAAC,GAAGyH,GAAGzH,CAAC,IAAI;CAClBP,IAAAA,GAAG,GAAGA,GAAG,CAACmL,IAAI,CAAC5K,CAAD,CAAL,CAATP;SACIA,GAAG,KAAK,IAARA,IAAgBA,GAAG,KAAKX,WAAW,OAAOA,SAAP;;;UAEjCW,GAAG,GAAGA,GAAG,CAACmL,IAAI,CAAC5K,CAAD,CAAL,CAAN,GAAkBlB;;AAG7B,CAAO,SAASkH,GAAT,CAAavG,GAAb,EAAkBmL,IAAlB,EAAwB3E,KAAxB,EAA+B;CACrC2E,EAAAA,IAAI,GAAGD,SAAS,CAACC,IAAD,CAAhBA;OACMnD,CAAC,GAAGmD,IAAI,CAAC3K,MAAL2K,GAAc;OACpBnD,CAAC,KAAK,CAAC,GAAG;OACV6D;OACHrD;OACAjI,CAAC,GAAG;;UACEA,CAAC,GAAGyH,GAAGzH,CAAC,IAAI;CAClBsL,IAAAA,IAAI,GAAGV,IAAI,CAAC5K,CAAD,CAAXsL;CACArD,IAAAA,CAAC,GAAGxI,GAAG,CAAC6L,IAAD,CAAPrD;SACI,CAACA,GAAGxI,GAAG,CAAC6L,IAAD,CAAH7L,GAAYwI,CAAC,GAAG,EAAhBxI;CACRA,IAAAA,GAAG,GAAGwI,CAANxI;;;CAED6L,EAAAA,IAAI,GAAGV,IAAI,CAAC5K,CAAD,CAAXsL;CACA7L,EAAAA,GAAG,CAAC6L,IAAD,CAAH7L,GAAYwG,KAAZxG;;;CC3ED;;;;;;;AAQA;CAKA;;;CAGA;;CAEA;;;;;AAIA,CAAO,SAAS8L,QAAT,CAAkBhH,GAAlB,EAA+B+D,KAA/B,EAAuD;UACtD/D,GAAG,CAACiH,UAAJjH,CAAe+D,KAAK,IAAI,CAAxB/D;;CAGR;;;;;AAIA,CAAO,SAASkH,IAAT,CAAcC,IAAd,EAAoC;UACnClL,MAAM,CAACmL,YAAPnL,CAAoBkL,IAApBlL;;;CAIR;;;CAGA;;CAEA,IAAMoL,QAAQ,GAAG,gBAAjB;CAEA;;;;AAGA,CAAO,SAASC,IAAT,CAActH,GAAd,EAAmC;UAClCA,GAAG,CAAChB,OAAJgB,CAAYqH,QAAZrH,EAAsB,EAAtBA;;;CAIR;;;CAGA;;CAEA,IAAMuH,sBAAsB,GAAG,QAA/B;CAEA;;;;AAGA,CAAO,SAASC,UAAT,CAAoBxH,GAApB,EAAyC;UACxCA,GAAG,CAAChB,OAAJgB,CAAYuH,sBAAZvH,EAAoCyH,KAApCzH;;AAGR,CAAO,SAASyH,KAAT,CAAeC,CAAf,EAAkC;UACjCA,CAAC,CAACC,WAAFD;;AAGR,CAAO,SAASE,KAAT,CAAeF,CAAf,EAAkC;UACjCA,CAAC,CAACG,WAAFH;;;CAIR;;;CAGA;;CAEA;;;;;;;;;AAQA,CAAO,SAASI,MAAT,CAAgB5M,GAAhB,EAAkC;UACjCV,KAAK,CAACU,GAAD,CAALV,GAAa,EAAbA,GAAkByB,MAAM,CAACf,GAAD;;;CAIhC;;;CAGA;;CAEA,IAAM6M,cAAc,GAAG;SACf,KADe;SAEf,KAFe;SAGf,KAHe;QAIhB,KAJgB;QAKhB;CALgB,CAAvB;CAAA,IAOCC,UAAU,GAAG,aAPd;AASA,CAAO,SAASC,SAAT,CAAmBjI,GAAnB,EAAwC;UACvCA,GAAG,CAAChB,OAAJgB,CAAYgI,UAAZhI,EAAwB,UAAAA,GAAA;YAAO+H,cAAc,CAAC/H,GAAD;CAA7C,GAAAA;;;CC1GR;;;;;;AAOA;CAOA;;;CAGA;;AAEA,CAAO,SAASkI,GAAT,CAAalI,GAAb,EAA0B3C,GAA1B,EAAuC8K,GAAvC,EAAqDC,SAArD,EAA2F;UAC1F/K,GAAG,GAAG2C,GAAG,CAACtE,MAAV2B,GAAmBgL,KAAK,CAACrI,GAAD,EAAM3C,GAAN,EAAW8K,GAAX,EAAgBC,SAAhB,CAAxB/K,GAAqD2C;;AAG7D,CAAO,SAASsI,GAAT,CAAatI,GAAb,EAA0B3C,GAA1B,EAAuCkL,MAAvC,EAAgE;UAC/DlL,GAAG,GAAG2C,GAAG,CAACtE,MAAV2B,IAAqBkL,MAAM,GAAGA,MAAM,IAAI,EAAnBA,EAAwBvI,GAAG,CAACwI,MAAJxI,CAAW,CAAXA,EAAc3C,GAAG,GAAGkL,MAAM,CAAC7M,MAA3BsE,IAAqCuI,MAAlFlL,IAA4F2C;;;CAGpG,SAASqI,KAAT,CAAerI,GAAf,EAA4B3C,GAA5B,EAAyC8K,GAAzC,EAAsDC,SAAtD,EAA2F;OACpFK,OAAO,GAAG,IAAIjN,KAAJ,CAAU6B,GAAG,GAAG2C,GAAG,CAACtE,MAAV2B,GAAmB,CAA7B,EAAgCU,IAAhC,CAAqCoK,GAAG,IAAI,GAA5C;UACTC,SAAS,GAAGpI,GAAG,GAAGyI,OAAT,GAAmBA,OAAO,GAAGzI;;;CAI9C;;;CAGA;;;AAEA,KAAa0I,gBAAgB,GAAGC,WAAW,CAAC,CAAD,CAApC;CAAA,IACNC,cAAc,GAAGD,WAAW,CAAC,CAAD,EAAI,IAAJ,CADtB;CAAA,IAENE,aAAa,GAAGF,WAAW,CAAC,CAAD,EAAI,KAAJ,CAFrB;CAAA,IAGNG,WAAW,GAAGH,WAAW,CAAC,CAAD,EAAI,WAAJ,CAHnB;;CAKP,SAASA,WAAT,CAAqBI,KAArB,EAAoCC,MAApC,EAAiF;CAChFA,EAAAA,MAAM,GAAGA,MAAM,IAAI,KAAnBA;OACMC,GAAG,GAAG,IAAI5M,MAAJ,iCACmB2M,qBAAgBA,gBAAWD,oBAAeC,oBAAeA,cAD5E,EAEX,GAFW;UAIL,UAAAE,MAAA;YAAUA,MAAM,CAAClK,OAAPkK,CAAeD,GAAfC,EAAoBC,gBAApBD;CAAjB;;;CAED,SAASC,gBAAT,CAA0BzB,CAA1B,EAA6B0B,CAA7B,EAAgC;UACxBA,CAAC,GAAGA,CAAC,GAAG,GAAP,GAAa1B;;;CAItB;;;CAGA;;;CAEA,IAAM2B,UAAU,GAAG,2DAAnB;AACA,CAAO,SAASC,MAAT,CAAgBtJ,GAAhB,EAAqC;UACpCA,GAAG,CAAChB,OAAJgB,CAAYqJ,UAAZrJ,EAAwBuJ,aAAxBvJ;;;CAER,SAASuJ,aAAT,CAAuB7B,CAAvB,EAA0BhE,CAA1B,EAA6B8F,GAA7B,EAAkCC,EAAlC,EAAsCC,EAAtC,EAA0C/H,CAA1C,EAA6C;UACrC+B,CAAC,IAAI8F,GAAG,GAAGA,GAAG,GAAG,KAAT,GAAiBC,EAAE,GAAGA,EAAE,GAAG,IAAR,GAAe,CAACC,EAAE,IAAI/H,CAAP,IAAY,GAArD;;;CAGT,IAAMgI,YAAY,GAAG,iEAArB;AACA,CAAO,SAASC,QAAT,CAAkB5J,GAAlB,EAAuC;UACtCA,GAAG,CAAChB,OAAJgB,CAAY2J,YAAZ3J,EAA0B6J,eAA1B7J;;;CAER,SAAS6J,eAAT,CAAyBnC,CAAzB,EAA4BhE,CAA5B,EAA+B8F,GAA/B,EAAoCC,EAApC,EAAwCC,EAAxC,EAA4C/H,CAA5C,EAA+C;UACvC+B,CAAC,IAAI8F,GAAG,GAAGA,GAAG,GAAG,GAAT,GAAeC,EAAE,IAAIC,EAAND,IAAY9H,CAAlC;;;CAIT;;;CAGA;;;AAIA,KAAamI,cAA2B,GAAG,GAApC;AACP,KAAaC,WAAwB,GAAG,GAAjC;AACP,KAAaC,WAAwB,GAAG,GAAjC;AACP,KAAaC,YAAyB,GAAG,GAAlC;AACP,KAAaC,gBAA6B,GAAG,IAAtC;AACP,KAAaC,WAAwB,GAAG,IAAjC;CAEP,IAAMC,YAAY,GAAG;QACfN,cADe;QAEfC,WAFe;QAGfC,WAHe;QAIfC,YAJe;QAKfC,gBALe;QAMfC;CANe,CAArB;;CAQA,SAASE,UAAT,CAAoBC,CAApB,EAA4C;OACvCC,KAAkB,GAAG;;OACrBD,GAAG;SACF7O,CAAC,GAAG6O,CAAC,CAAC5O;;YACHD,CAAC;CAAI8O,MAAAA,KAAK,IAAIH,YAAY,CAACE,CAAC,CAAC1D,MAAF0D,CAAS7O,CAAT6O,CAAD,CAArBC;;;;UAENA;;;CAIR;;;CAGA;CAEA;CACA;;;CACA,IAAMC,SAAS,iBAAf;CAAA,IACCC,UAAU,6LADX;CAAA,IAECC,MAAM,wBAAsBF,YAAYC,gBAFzC;CAAA,IAGCE,KAAK,aAHN;CAAA,IAICC,UAAU,oCAJX;CAAA,IAKCC,SAAS,GAAG,IAAIxO,MAAJ,gBACEmO,kBAAaC,uCAAkCC,SAASC,sBAAiBD,SAASE,kDADpF,EAEX,GAFW,CALb;;CAWA;;;CAGA;;CAWA,IAAME,UAEL,GAAGtI,MAAM,CAAC,IAAD,CAFV;AAIA,CAAO,SAASuI,eAAT,CAAyB7P,GAAzB,EAAiE;OACnE8P,KAAKnN;;QACJA,QAAQ3C,KAAK;CACjB8P,IAAAA,GAAG,GAAG9P,GAAG,CAAC2C,IAAD,CAATmN;CACAnQ,IAAAA,IAAI,CAACmQ,GAAD,CAAJnQ,KAAciQ,UAAU,CAACjN,IAAD,CAAViN,GAAmBE,GAAjCnQ;;;AAIF,CAAO,SAASoQ,YAAT,CAAsBpN,IAAtB,EAAoD;OACpDyM,CAAC,GAAGQ,UAAU,CAACjN,IAAI,IAAI,GAAT;OAChByM,GAAG,OAAOA,CAAP;SACD,IAAIxI,KAAJ,yBAAgCjE,IAAhC;;;CAIP;;;CAGA;;CAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiNA,CAAO,SAASqN,OAAT,CAAoBF,GAApB,EAAiCpN,IAAjC,EAA0CS,MAA1C,EAA2D8M,QAA3D,EAA6G;CACnH9M,EAAAA,MAAM,GAAGA,MAAM,IAAI,CAAnBA;OACM+M,KAAK,GAAG/M;CACd8M,EAAAA,QAAQ,GAAGA,QAAQ,IAAIE,eAAvBF;UACOH,GAAG,CAAChM,OAAJgM,CAAYH,SAAZG,EAAuB,UAC7BrJ,CAD6B,EAE7B+F,CAF6B,EAG7B4D,KAH6B,EAI7BC,SAJ6B,EAK7BhB,KAL6B,EAM7BiB,KAN6B,EAO7BC,IAP6B,EAQ7BC,KAR6B,EAS7BC,IAT6B,EAU7BC,SAV6B,EAW7BC,IAX6B,EAY7BC,KAZ6B,EAa7BC,SAb6B,EAc7B/Q,IAd6B,EAe5B;SACG,CAAC0M,GAAG,OAAO/F,CAAC,CAACiF,MAAFjF,CAAS,CAATA,CAAP;YACDsJ,YAAY,CAACjQ,IAAD,CAAZiQ,CACNe,UAAU,CAACV,KAAK,IAAI,GAAV,EAAeC,SAAf,CADJN,EAENZ,UAAU,CAACE,KAAD,CAFJU,EAGNgB,UAAU,CAACT,KAAD,EAAQC,IAAR,EAAcC,KAAd,CAAVO,IAAkC,CAH5BhB,EAINU,IAJMV,EAKNgB,UAAU,CAACL,SAAD,EAAYC,IAAZ,EAAkBC,KAAlB,CALJb,EAMNc,SANMd;CAjBD,GAAAD;;YA2BEiB,WAAcT,OAAejH,KAAatD,MAAsB;SACpEuK,OAAO,OAAQA,KAAD,IAAkB,CAAzB;;SACPjH,KAAK;WACF2H,CAAC,GAAGF,UAAU,CAACzH,GAAD,EAAMtD,IAAN,CAAV+K,IAAyB;WAC/BG,QAAQ,CAACD,CAAD,GAAK,OAAOA,CAAP;;;;YAIVF,WAAcI,UAAkBnL,MAAmB;SACvDqK,KAAK,GAAGH,QAAQ,CACnBvN,IADmB,EAEnBwO,QAAQ,KAAK,GAAbA,GACG/N,MAAM,EADT+N,GAEGA,QAAQ,KAAK,GAAbA,GACA/N,MAAM,KAAK+M,KAAX/M,GACCA,MADDA,GAECA,MAAM,GAAG,CAHV+N,GAICA,QAAD,IAAqB,CARL;YAUbnL,IAAI,GAAGO,GAAG,CAAC8J,KAAD,EAAQrK,IAAR,CAAN,GAAsBqK;;;;CAInC,SAASD,eAAT,CAAyBzN,IAAzB,EAAoC2G,GAApC,EAAiD;UACzC3G,IAAI,CAAC2G,GAAD;;;CAIZ;;;CAGA;;CAEA;;;;;;;AAMA,CAAO,SAAS8H,MAAT,CAAgBrB,GAAhB,EAAqC;UACpCE,OAAO,CAACF,GAAD,EAAM5L,SAAN,EAAiB,CAAjB,EAAoBkN,cAApB;;;CAGf,SAASA,cAAT,CAAwB1O,IAAxB,EAA0C2G,GAA1C,EAAuD;UAC/C3G,IAAI,CAAC2G,GAAG,GAAG,CAAP;;;CAIZ;;;CAGA;;;CAEA,IAAMgI,aAAa,GAAG,MAAtB;CAAA,IACCC,YAAY,GAAG,KADhB;CAAA,IAECC,SAAS,GAAG,OAFb;;CAGA,SAASC,eAAT,CAAyBhF,CAAzB,EAAsCyD,QAAtC,EAAyF;UACjFzN,QAAQ,4BACW+O,gCACdE,YAAY,CAACjF,CAAC,CAAC,CAAD,CAADA,IAAQ,GAAT,EAAcA,CAAC,CAAC,CAAD,CAAf,cACtB2C,UAAU,CAAC3C,CAAC,CAAC,CAAD,CAAF,cACXkF,YAAY,CAAClF,CAAC,CAAC,CAAD,CAAF,EAAOA,CAAC,CAAC,CAAD,CAAR,EAAaA,CAAC,CAAC,CAAD,CAAd,EAAmB,GAAnB,eACXA,CAAC,CAAC,CAAD,CAADA,GAAOO,SAAS,CAACP,CAAC,CAAC,CAAD,CAAF,CAAhBA,GAAyB,iBAC1BkF,YAAY,CAAClF,CAAC,CAAC,CAAD,CAAF,EAAOA,CAAC,CAAC,EAAD,CAAR,EAAcA,CAAC,CAAC,EAAD,CAAf,EAAqB,QAArB,eACXA,CAAC,CAAC,EAAD,CAADA,GAAQO,SAAS,CAACP,CAAC,CAAC,EAAD,CAAF,CAAjBA,GAA2B,eAPd,EASd,CAAC,KAAD,EAAQ8E,YAAR,EAAsBD,aAAtB,CATc,CAAR7O,CAULuN,YAAY,CAACvD,CAAC,CAAC,EAAD,CAAF,CAVPhK,EAUgB8D,GAVhB9D,EAUqByN,QAVrBzN;;;CAaR,SAASkP,YAAT,CAAsBpB,KAAtB,EAAqCjH,GAArC,EAAkDtD,IAAlD,EAAgE4L,GAAhE,EAAqF;UAC7ErB,KAAK,GAAGA,KAAH,GAAWjH,GAAG,GAAGoI,YAAY,CAACpI,GAAD,EAAMtD,IAAN,CAAf,GAA6B4L;;;CAGxD,SAASF,YAAT,CAAsBpI,GAAtB,EAAmCtD,IAAnC,EAAyD;OACpDkG,IAAI,GAAMoF,aAAN,YAAMA,IACbhI,GAAG,KAAK,GAARA,GACMkI,SADN,UAAAlI,GAEGA,GAAG,KAAK,GAARA,GACGkI,SADH,aACGA,GAAoBA,SAApBA,WAAAA,GAAsCA,SAAtCA,WAAAA,GAAwDA,SAAxDA,YADHlI,GAEAA,GALUgI;;OAOVtL,MAAM;SACHoF,IAAI,GAAGD,SAAS,CAACnF,IAAD;SAClBxF,CAAC,GAAG4K,IAAI,CAAC3K;;YACND,CAAC;CAAI4K,MAAAA,IAAI,CAAC5K,CAAD,CAAJ4K,UAAc4B,SAAS,CAAC5B,IAAI,CAAC5K,CAAD,CAAL,QAAvB4K;;;YACFmG,YAAV,MAAUA,GAAgBrF,IAAhBqF,QAAAA,GAA0BnG,IAAI,CAACtI,IAALsI,CAAU,IAAVA,CAA1BmG;;;UAEJrF;;CAER;;;;;;;;AAMA,CAAO,SAAS2F,SAAT,CACN9B,GADM,EAEN3M,MAFM,EAGN8M,QAHM,EAIuB;OACzBzD;OACHqF,OAAO,GAAG;OACVC;OACAC;OACAC,GAAG,GAAG;OACNC,KAAK,GAAG;OACR1R,CAAC,GAAG;CACL4C,EAAAA,MAAM,GAAGA,MAAM,IAAI,CAAnBA;;UACQqJ,CAAC,GAAGmD,SAAS,CAACpE,IAAVoE,CAAeG,GAAfH,GAAsB;CACjCoC,IAAAA,IAAI,GAAGpC,SAAS,CAACnE,SAAjBuG;CACAD,IAAAA,MAAM,GAAGC,IAAI,GAAGvF,CAAC,CAAC,CAAD,CAADA,CAAKhM,MAArBsR;CACAD,IAAAA,OAAO,GAAGC,MAAVD,IAAoBK,OAAO,CAACpC,GAAG,CAACqC,SAAJrC,CAAc+B,OAAd/B,EAAuBgC,MAAvBhC,CAAD,EAAiC,CAAjC,CAA3B+B;;SACIrF,CAAC,CAAC,CAAD,GAAK;CACTyF,MAAAA,KAAK,CAAC1R,CAAD,CAAL0R,YAAkB1R,sBAAiBgR,eAAnCU;CACAD,MAAAA,GAAG,CAACzR,CAAC,EAAF,CAAHyR,GAAWR,eAAe,CAAChF,CAAD,EAAIyD,QAAQ,IAAIE,eAAhB,CAA1B6B;CAFD,WAGO;CACNE,MAAAA,OAAO,CAAC1F,CAAC,CAAC,CAAD,CAADA,CAAKd,MAALc,CAAY,CAAZA,CAAD,EAAiBjM,CAAjB,CAAP2R;;;CAEDL,IAAAA,OAAO,GAAGE,IAAVF;;;CAEDA,EAAAA,OAAO,GAAG/B,GAAG,CAACtP,MAAdqR,IAAwBK,OAAO,CAACpC,GAAG,CAACqC,SAAJrC,CAAc+B,OAAd/B,CAAD,EAAyBvP,CAAzB,CAA/BsR;UACOrP,QAAQ,4BAA0B+O,qBAAgBpO,gBAAWA,wBAAmB8O,KAAK,CAACpP,IAANoP,CAAW,KAAXA,OAAxE,EAA8F,CAC5G,KAD4G,CAA9F,CAARzP,CAEJwP,GAFIxP;;YAIE0P,QAAQpN,KAAKsN,QAAQ;SACzBA,MAAM,IAAIJ,GAAG,CAACzR,CAAC,GAAG,CAAL,CAAHyR,CAAW3G,OAAO;CAC/B2G,MAAAA,GAAG,CAACzR,CAAC,GAAG,CAAL,CAAHyR,IAAclN,GAAdkN;CADD,WAEO;CACNC,MAAAA,KAAK,CAAC1R,CAAD,CAAL0R,YAAkB1R,OAAlB0R;CACAD,MAAAA,GAAG,CAACzR,CAAC,EAAF,CAAHyR,GAAWlN,GAAXkN;;;;CAIH;;;;;;;;;;;;;;;;;;;;;CAqBA;;CACA;;;CAGA;;CAEA,SAASK,YAAT,CAAsBC,KAAtB,EAAuF;UAC/E,UAASjM,GAAT,EAAcgJ,KAAd,EAAqBiB,KAArB,EAA4BG,IAA5B,EAAkCC,SAAlC,EAA6CG,SAA7C,EAAwD;SACxD/L,GAAG,GAAGwN,KAAK,CAACjM,GAAD,EAAMgJ,KAAN;YACViB,KAAK,GAAGxL,GAAG,CAACtE,MAAZ8P,GAAqBnD,KAAK,CAACrI,GAAD,EAAMwL,KAAN,EAAaG,IAAb,EAAmBpB,KAAK,GAAGJ,WAA3B,CAA1BqB,GAAoElD,GAAG,CAACtI,GAAD,EAAM4L,SAAN,EAAiBG,SAAjB;CAF/E;;;CAMD,SAAS0B,YAAT,CACCC,QADD,EAECC,SAFD,EAGCH,KAHD,EAICI,SAJD,EAKkB;UACV,UAASrM,GAAT,EAAcgJ,KAAd,EAAqBiB,KAArB,EAA4BG,IAA5B,EAAkCC,SAAlC,EAA6C;SAC7CiC,GAAG,GAAGH,QAAQ,CAACnM,GAAD;SAChB,CAAC4K,QAAQ,CAAC0B,GAAD,GAAO,OAAO5R,MAAM,CAAC4R,GAAD,CAAb;SAEdC,MAAM,GAAGH,SAAS,CAACE,GAAD,EAAMtD,KAAN;SACvBwD,IAAI,GAAGD,MAAM,CAACpS;SACXsE,GAAG,GAAGwN,KAAK,CAACK,GAAG,GAAG,CAANA,GAAU,CAACA,GAAXA,GAAiBA,GAAlB,EAAuBtD,KAAvB,EAA8BqB,SAA9B;YAERrB,KAAK,GAAGP,WAARO,IACFvK,GAAG,GAAG8N,MAAM,GAAG5F,GAAG,CAAClI,GAAD,EAAMwL,KAAK,GAAGuC,IAAd,EAAoB,GAApB,CAAlB/N,EAA6CuK,KAAK,GAAGL,gBAARK,GAA2BqD,SAAS,CAAC5N,GAAD,CAApCuK,GAA4CvK,GADvFuK,KAEHA,KAAK,GAAGL,gBAARK,KAA6BvK,GAAG,GAAG4N,SAAS,CAAC5N,GAAD,CAA5CuK,GAAoDrC,GAAG,CAAC4F,MAAM,GAAG9N,GAAV,EAAewL,KAAf,EAAsBG,IAAtB,EAA4BpB,KAAK,GAAGJ,WAApC,CAFpDI;CARR;;;CAcD,SAASyD,aAAT,CAAuBH,GAAvB,EAAoCtD,KAApC,EAAgE;UACxDsD,GAAG,GAAG,CAANA,GAAU,GAAVA,GAAgBtD,KAAK,GAAGR,WAARQ,GAAsB,GAAtBA,GAA4BA,KAAK,GAAGN,YAARM,GAAuB,GAAvBA,GAA6B;;;;CAIjF,IAAM0D,WAAW,GAAG;CACnBC,EAAAA,CAAC,EAAE,CAAC,CAAD,EAAItF,cAAJ,CADgB;CAEnBvO,EAAAA,CAAC,EAAE,CAAC,CAAD,EAAIwO,aAAJ,CAFgB;CAGnBsF,EAAAA,CAAC,EAAE,CAAC,EAAD,EAAKzF,gBAAL,CAHgB;CAInB0F,EAAAA,CAAC,EAAE,CAAC,EAAD,EAAKtF,WAAL;CAJgB,CAApB;CAMA,IAAMuF,YAAY,GAAG,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,CAArB;;CACA,SAASC,aAAT,CAAuBtT,IAAvB,EAAqD;OAC9CuT,IAAI,GAAGN,WAAW,CAACjT,IAAI,CAAC6M,WAAL7M,EAAD;OACvBwT,CAAC,GAAGD,IAAI,CAAC,CAAD;OACRE,OAAO,GAAG,UAAAZ,GAAA;YAAOA,GAAG,CAACnL,QAAJmL,CAAaW,CAAbX;CAFlB;OAGCL,KAAK,GAAGxS,IAAI,KAAK,GAATA,GAAe,UAAA6S,GAAA;YAAOpG,KAAK,CAACgH,OAAO,CAACZ,GAAD,CAAR;CAA3B,GAAA7S,GAA4CyT;;OACjDC,OAAO,GAAGF,CAAC,KAAK,EAANA,GAAW,EAAXA,GAAgBH,YAAY,CAACG,CAAC,IAAI,CAAN;CAC1CxH,EAAAA,QAAQ,CAAChM,IAAD,CAARgM,GAAiB,EAAjBA,KAAwB0H,OAAO,GAAGjH,KAAK,CAACiH,OAAD,CAAvC1H;UACOyG,YAAY,CAAC,UAAA/J,CAAA;YAAKA,CAAC,KAAK;CAAZ,GAAA,EAAe,UAACmK,GAAD,EAAMtD,KAAN;YAAiBA,KAAK,GAAGT,cAARS,GAAyBmE,OAAzBnE,GAAmC;CAAnE,GAAA,EAAwEiD,KAAxE,EAA+Ee,IAAI,CAAC,CAAD,CAAnF;;;;CAIpB,SAASI,cAAT,CAAwB3T,IAAxB,EAAsD;OAC/C4T,SAAS,GAAGnH,KAAK,CAACzM,IAAD,CAALyM,KAAgB,GAAhBA,GAAsBoH,aAAtBpH,GAAsCzM,IAAI,KAAK,GAATA,GAAe8T,OAAf9T,GAAyB+T;OAChFN,OAAO,GAAG,UAACZ,GAAD,EAAMtD,KAAN,EAAaqB,SAAb;YAA2BgD,SAAS,CAACf,GAAD,EAAMjC,SAAN,CAATgD,IAA6B3S,MAAM,CAAC4R,GAAD;CADzE;OAECL,KAAK,GAAGxG,QAAQ,CAAChM,IAAD,CAARgM,GAAiB,EAAjBA,GAAsByH,OAAtBzH,GAAgC,UAAC6G,GAAD,EAAMtD,KAAN,EAAaqB,SAAb;YAA2BnE,KAAK,CAACgH,OAAO,CAACZ,GAAD,EAAMtD,KAAN,EAAaqB,SAAb,CAAR;CAFzE;;UAGO6B,YAAY,CAACuB,UAAD,EAAahB,aAAb,EAA4BR,KAA5B,EAAmC9E,gBAAnC;;;CAGpB,SAASmG,aAAT,CAAuBhB,GAAvB,EAAoCjC,SAApC,EAA+D;UACvDiC,GAAG,CAACgB,aAAJhB,CAAkBjC,SAAlBiC;;;CAER,SAASkB,WAAT,CAAqBlB,GAArB,EAAkCjC,SAAlC,EAA6D;UACrDA,SAAS,IAAIiC,GAAG,CAACkB,WAAJlB,CAAgBjC,SAAhBiC;;;CAErB,SAASiB,OAAT,CAAiBjB,GAAjB,EAA8BjC,SAA9B,EAAyD;UACjDA,SAAS,IAAI,CAAbA,IAAkBiC,GAAG,CAACiB,OAAJjB,CAAYjC,SAAZiC;;;;CAI1B9C,eAAe,CAAC;CACfpJ,EAAAA,CAAC,EAAE4L,YAAY,CAACC,KAAD,CADA;CAEf3J,EAAAA,CAAC,EAAE0J,YAAY,CAAC,UAAA7J,CAAA;YACfA,CAAC,KAAKnJ,SAANmJ,IAAmB7I,IAAI,CAAC6I,CAAD,CAAvBA,IAA+BA,CAAC,CAACuL,MAAFvL,IAAYA,CAAC,CAACuL,MAAFvL,OAAenJ,SAA1DmJ,GAAuE8J,KAAK,CAAC9J,CAAD,CAA5EA,GAAkFwL,IAAI,CAACC,SAALD,CAAexL,CAAfwL;CADpE,GAAA,CAFA;CAKfE,EAAAA,CALe,aAKb7N,KAAU;SACLsM,GAAG,GAAGtM,GAAG,IAAI;YACZsM,GAAG,GAAG,CAANA,GAAU5R,MAAM,CAACmL,YAAPnL,CAAoB4R,GAApB5R,CAAV4R,GAAqC;CAP9B,GAAA;CASfzE,EAAAA,CAAC,EAAEqE,YAAY,CAAC,UAAAlM,GAAA;YAAOA,GAAG,IAAI;CAAf,GAAA,EAAkByM,aAAlB,EAAiCR,KAAjC,EAAwC9E,gBAAxC,CATA;CAUf9G,EAAAA,CAAC,EAAE+M,cAAc,CAAC,GAAD,CAVF;CAWfU,EAAAA,CAAC,EAAEV,cAAc,CAAC,GAAD,CAXF;CAYfrE,EAAAA,CAAC,EAAEqE,cAAc,CAAC,GAAD,CAZF;CAafW,EAAAA,CAAC,EAAEX,cAAc,CAAC,GAAD,CAbF;CAcfY,EAAAA,CAAC,EAAEZ,cAAc,CAAC,GAAD,CAdF;CAefT,EAAAA,CAAC,EAAEI,aAAa,CAAC,GAAD,CAfD;CAgBfkB,EAAAA,CAAC,EAAElB,aAAa,CAAC,GAAD,CAhBD;CAiBfjU,EAAAA,CAAC,EAAEiU,aAAa,CAAC,GAAD,CAjBD;CAkBfmB,EAAAA,CAAC,EAAEnB,aAAa,CAAC,GAAD,CAlBD;CAmBfH,EAAAA,CAAC,EAAEG,aAAa,CAAC,GAAD,CAnBD;CAoBfF,EAAAA,CAAC,EAAEE,aAAa,CAAC,GAAD,CApBD;CAqBfoB,EAAAA,CAAC,EAAEpB,aAAa,CAAC,GAAD;CArBD,CAAD,CAAfvD;;CAwBA,SAASyC,KAAT,CAAe9J,CAAf,EAA+B;UACvBzH,MAAM,CAACyH,CAAD;;;CCrpBd;;;;;;;AAOA,CAEA;;;;;;;CAQA;;;;;;;;;AAQA,CAAO,SAASiM,QAAT,CACNC,MADM,EAENC,SAFM,EAGNC,MAHM,EAINC,WAJM,EAKNC,SALM,EAMA;OACF,CAACJ,QAAQ;CACZA,IAAAA,MAAM,GAAG,EAATA;;;OAEK1M,CAAC,GAAG8M,SAAS,IAAIH,SAAS,CAACnU,MAAVmU,GAAmB;OACtCpU,CAAC,GAAGsU,WAAW,IAAI;OACtBE;OACAhP;;UACMxF,CAAC,GAAGyH,GAAGzH,CAAC,IAAI;SACbwU,QAAQ,GAAGJ,SAAS,CAACpU,CAAD,GAAM;YACzBwF,QAAQgP,UAAU;aAClBH,MAAM,CAAC7O,IAAD,EAAO2O,MAAP,EAAeK,QAAf,GAA0B;CACnCL,UAAAA,MAAM,CAAC3O,IAAD,CAAN2O,GAAeK,QAAQ,CAAChP,IAAD,CAAvB2O;;;;;;UAKGA;;CAGR;;;;;AAKA,CAAO,SAASM,MAAT,CAAgBN,MAAhB,EAAkC;UACjCD,QAAQ,CAACC,MAAD,EAASxQ,SAAT,EAAoB+Q,mBAApB,EAAyC,CAAzC;;CAGhB;;;;AAIA,CAAO,SAASC,QAAT,CAAkBR,MAAlB,EAAoC;UACnCD,QAAQ,CAACC,MAAD,EAASxQ,SAAT,EAAoBiR,cAApB,EAAoC,CAApC;;CAGhB;;;;;;AAKA,CAAO,SAASF,mBAAT,CAA6BlP,IAA7B,EAA2C2O,MAA3C,EAAwDK,QAAxD,EAAgF;UAC/EjP,UAAU,CAACiP,QAAD,EAAWhP,IAAX;;CAGlB;;;;;;;AAMA,CAAO,SAASoP,cAAT,CAAwBpP,IAAxB,EAAsC2O,MAAtC,EAAmDK,QAAnD,EAA2E;UAC1EjP,UAAU,CAACiP,QAAD,EAAWhP,IAAX,CAAVD,IAA8B,EAAEC,IAAI,IAAI2O,MAAV;;;CCpFtC;;;;;;AAOA,CA6BA,IAAM9E,YAAU,GAAG,EAAnB;CAAA,IACCwF,iBAAwE,GAAG,EAD5E;;CAEA,SAASC,YAAT,CAAsBC,GAAtB,EAAmC5S,IAAnC,EAA6D6S,MAA7D,EAAqF;OAC9EC,EAAE,GACP5F,YAAU,CAAC2F,MAAD,CAAV3F,KACEwF,iBAAiB,CAACG,MAAD,CAAjBH,GAA4B,UAAC1S,IAAD,EAAOS,MAAP,EAAkB;YACxCT,IAAI,CAAC,CAAD,CAAJA,CAAQS,MAAM,IAAIoS,MAAVpS,GAAmBA,MAAM,GAAG,CAA5BA,GAAgCA,MAAxCT;CADP,GAAC0S,EAGDxF,YAAU,CAAC2F,MAAD,CAAV3F,GAAqBtI,MAAM,CAAC,IAAD,CAJ5BsI;UAKM,CAAC4F,EAAE,CAACF,GAAD,CAAFE,KAAYA,EAAE,CAACF,GAAD,CAAFE,GAAU5D,SAAS,CAAC0D,GAAD,EAAMC,MAAN,EAAcH,iBAAiB,CAACG,MAAD,CAA/B,CAA/BC,CAAD,EAA2E9S,IAA3E;;;AAgER,CAAO,IAAM+S,MAAM,GAAW,UAAgBH,GAAhB,EAAqC;SAC5D,IAAI1O,KAAJ,CAAUyO,YAAY,CAACC,GAAG,IAAI,OAAR,EAAiBpR,SAAjB,EAA4B,CAA5B,CAAtB;CADA,CAAA;;CAIP,SAASwR,QAAT,CAAkBhS,EAAlB,EAA6B;OACxB;CACHA,IAAAA,EAAE;CADH,IAEE,OAAOgD,CAAP,EAAU;YACJA;;;;CAIT,SAASiP,QAAT,CAAkBC,MAAlB,EAA0CC,GAA1C,EAA+D;OAC1DP,GAAG,GAAG5V,KAAK,CAACkW,MAAD,CAALlW,GAAiBkW,MAAjBlW,GAAsCkW,MAAD,CAAkBE;UAC1DR,GAAG,KAAKO,GAAG,CAACC;;;CAEpB,IAAMC,KAAK,GAAG,IAAInP,KAAJ,EAAd;CACA,IAAMoP,QAAQ,GAAGC,KAAK,CAACC,YAAY,CAAC,CAAD,CAAb,EAAkB,OAAlB,CAAtB;;CACAT,MAAM,QAAA,CAANA,GAAe,UAAS/R,EAAT,EAAwBkS,MAAxB,EAAgDN,GAAhD,EAAsE;OAC9EO,GAAG,GAAGH,QAAQ,CAAChS,EAAD;;OAChB,CAACmS,GAAD,IAASD,MAAM,IAAI,CAACD,QAAQ,CAACC,MAAD,EAASC,GAAT,GAAgB;CAC/C3R,IAAAA,SAAS,CAAC,CAAD,CAATA,GAAe2R,GAAf3R;MACC0R,WAAW1R,SAAS,CAAC,CAAD,CAATA,GAAe6R;WACrB,IAAInP,KAAJ,CAAUyO,YAAY,CAACC,GAAG,IAAIU,QAAQ,CAAC,CAAD,CAAhB,EAAqB9R,SAArB,EAAgC,CAAhC,CAAtB;;;UAEAuR;CAPR,CAAAA;;CAUAA,MAAM,CAACU,QAAPV,GAAkB,UAAS/R,EAAT,EAAwBkS,MAAxB,EAAgDN,GAAhD,EAAsE;OACjFO,GAAG,GAAGH,QAAQ,CAAChS,EAAD;;OAChBmS,GAAG,KAAK,CAACD,MAAD,IAAW,CAACD,QAAQ,CAACC,MAAD,EAASC,GAAT,CAAzB,GAAyC;CAC/C3R,IAAAA,SAAS,CAAC,CAAD,CAATA,GAAe2R,GAAf3R;MACC0R,WAAW1R,SAAS,CAAC,CAAD,CAATA,GAAe6R;WACrB,IAAInP,KAAJ,CAAUyO,YAAY,CAACC,GAAG,IAAIU,QAAQ,CAAC,CAAD,CAAhB,EAAqB9R,SAArB,EAAgC,CAAhC,CAAtB;;;UAEAuR;CAPR,CAAAA;;CAUA,SAASW,YAAT,CACCzT,IADD,EAEC0T,SAFD,EAGC3T,IAHD,EAIC4T,IAJD,EAKCC,GALD,EAMK;OACEhS,MAAgB,GAAG7E,KAAK,CAACgD,IAAD,CAALhD,GACpBgD,IAAD,CAAiBoI,KAAhBpI,CAAsB,IAAtBA,CADoBhD,GAErBD,KAAK,CAACiD,IAAD,CAALjD,GACAsL,SAAS,CAACrI,IAAD,EAAiB,UAAAnC,CAAA;qBAAWA,CAAC,GAAG;CAAhC,GAAA,CADTd,GAECiD;OACJ8T,QAAQ,GAAGjS,MAAM,CAAC1B,IAAP0B,CAAY,IAAZA;OACXkS,IAAI,GAAGrV,OAAO,CAACiV,SAAD,CAAPjV,GAAqBiV,SAAS,CAAC,CAAD,CAA9BjV,GAAoCiV;OAC3CK,IAAI,GAAG,CAACtV,OAAO,CAACiV,SAAD,CAAPjV,GAAqBiV,SAAS,CAAC,CAAD,CAA9BjV,GAAoC,EAArC,KAA4C1B,KAAK,CAAC+W,IAAD,CAAL/W,SAAkB+W,UAAlB/W,aAAoC8W,cAAhF;UAEAf,MAAM,CAAC9S,IAAD,CAAN8S,GAAejT,QAAQ,4BACL8J,UAAU,CAAC3J,IAAD,UAAU6T,+BACxCE,kEAC4CnS,MAAM,CAAC/D,mCAH1B,EAM9B,CAAC,KAAD,EAAQ,UAAR,EAAoB,MAApB,EAA4B,MAA5B,EAAoC,QAApC,CAN8B,CAARgC,CAOrB+T,GAAG,IAAI3P,KAPcpE,EAOP6S,YAPO7S,EAOO8T,IAPP9T,EAOaiU,IAPbjU,EAOmBiT,MAPnBjT;;;;CAkBxB,SAASmU,aAAT,CAAuBC,IAAvB,EAAkE;CACjE/O,EAAAA,OAAO,CAAC+O,IAAD,EAAO,UAACjQ,IAAD,EAAsBhE,IAAtB,EAA+B;SACtC0T,SAAS,GAAG1P,IAAI,CAAC,CAAD;SACrBjE,IAAI,GAAGiE,IAAI,CAAC,CAAD;SACX2O,GAAG,GAAG3O,IAAI,CAAC,CAAD;SACV4P,GAAG,GAAG5P,IAAI,CAAC,CAAD,CAAJA,IAAWkQ;CAElBvB,IAAAA,GAAG,CAAC,CAAD,CAAHA,IAAUc,YAAY,CAACzT,IAAD,EAAO,CAAC0T,SAAD,EAAY,GAAZ,CAAP,EAAyB3T,IAAzB,EAA+B4S,GAAG,CAAC,CAAD,CAAlC,EAAuCiB,GAAvC,CAAtBjB;CACAA,IAAAA,GAAG,CAAC,CAAD,CAAHA,IAAUc,YAAY,CAAC,QAAQ9J,UAAU,CAAC3J,IAAD,CAAnB,EAA2B0T,SAA3B,EAAsC3T,IAAtC,EAA4C4S,GAAG,CAAC,CAAD,CAA/C,EAAoDiB,GAApD,CAAtBjB;CAPM,GAAA,CAAPzN;;;CAWD,IAAMiP,IAAI,GAAG,MAAb;CACA,IAAMC,SAAS,GAAG,WAAlB;CACA,IAAMC,OAAO,GAAG,SAAhB;CACA,IAAMC,MAAM,GAAG,QAAf;CACA,IAAMC,OAAO,GAAG,SAAhB;CACA,IAAMC,MAAM,GAAG,QAAf;CACA,IAAMC,QAAQ,GAAG,UAAjB;CACA,IAAMC,KAAK,GAAG,OAAd;CACA,IAAMC,WAAW,GAAG,YAApB;CAEAlB,YAAY,CAAC,IAAD,EAAO,IAAP,EAAa,GAAb,EAAkBmB,SAAS,CAAC,OAAD,CAA3B,CAAZnB;CACAA,YAAY,CAAC,KAAD,EAAQ,GAAR,EAAa,GAAb,EAAkBmB,SAAS,CAAC,WAAD,CAA3B,CAAZnB;CACAO,aAAa,CAAC;CACb5X,EAAAA,EAAE,EAAE,CAACA,EAAD,EAAK,CAAL,EAAQkX,KAAK,CAACC,YAAY,CAAC,CAAD,CAAb,CAAb,CADS;CAEbsB,EAAAA,GAAG,EAAE,CAACtY,MAAD,EAAS,CAAT,EAAY+W,KAAK,CAACa,IAAD,CAAjB,CAFQ;CAGbW,EAAAA,GAAG,EAAE,CAACnY,KAAD,EAAQ,CAAR,EAAW2W,KAAK,CAACyB,UAAU,CAACZ,IAAD,EAAOC,SAAP,CAAX,CAAhB,CAHQ;CAIbY,EAAAA,KAAK,EAAE,CAACvY,OAAD,EAAU,CAAV,EAAa6W,KAAK,CAACc,SAAD,CAAlB,CAJM;CAKba,EAAAA,IAAI,EAAE,CAACrY,MAAD,EAAS,CAAT,EAAY0W,KAAK,CAACe,OAAD,CAAjB,CALO;CAMbrE,EAAAA,GAAG,EAAE,CAAClT,KAAD,EAAQ,CAAR,EAAWwW,KAAK,CAACgB,MAAD,CAAhB,CANQ;CAObY,EAAAA,GAAG,EAAE,CAACjY,KAAD,EAAQ,CAAR,EAAWqW,KAAK,CAACiB,OAAD,CAAhB,CAPQ;CAQbpS,EAAAA,GAAG,EAAE,CAACpF,KAAD,EAAQ,CAAR,EAAWuW,KAAK,CAACkB,MAAD,CAAhB,CARQ;CASbzT,EAAAA,EAAE,EAAE,CAAC/D,IAAD,EAAO,CAAP,EAAUsW,KAAK,CAACmB,QAAD,CAAf,CATS;CAUbU,EAAAA,SAAS,EAAE,CACVjY,WADU,EAEV,CAFU,EAGVoW,KAAK,qBAAmByB,UAAU,CAACZ,IAAD,EAAOC,SAAP,EAAkBC,OAAlB,EAA2BC,MAA3B,EAAmCC,OAAnC,EAA4CC,MAA5C,EAAoDC,QAApD,OAA7B,CAHK,CAVE;CAebW,EAAAA,OAAO,EAAE,CAACtX,SAAD,EAAY,CAAZ,EAAewV,KAAK,CAAC+B,cAAc,CAAChB,OAAD,CAAf,CAApB,CAfI;CAgBbiB,EAAAA,MAAM,EAAE,CAACrX,QAAD,EAAW,CAAX,EAAcqV,KAAK,CAAC+B,cAAc,CAACf,MAAD,CAAf,CAAnB,CAhBK;CAiBbiB,EAAAA,MAAM,EAAE,CAACpX,QAAD,EAAW,CAAX,EAAcmV,KAAK,CAAC+B,cAAc,CAACb,MAAD,CAAf,CAAnB,CAjBK;CAkBbgB,EAAAA,IAAI,EAAE,CAACnX,MAAD,EAAS,CAAT,EAAYiV,KAAK,CAAC,MAAD,CAAjB,CAlBO;CAmBblI,EAAAA,GAAG,EAAE,CAAC7M,KAAD,EAAQ,CAAR,EAAW+U,KAAK,CAAC,QAAD,CAAhB,CAnBQ;CAoBblO,EAAAA,KAAK,EAAE,CAAC3G,OAAD,EAAU,CAAV,EAAa6U,KAAK,CAACoB,KAAD,CAAlB,CApBM;CAqBbe,EAAAA,UAAU,EAAE,CAAC/W,YAAD,EAAe,CAAf,EAAkB4U,KAAK,CAAC,YAAD,CAAvB,CArBC;CAsBboC,EAAAA,SAAS,EAAE,CACV7W,WADU,EAEV,CAFU,EAGVyU,KAAK,CAACyB,UAAU,CAACL,KAAD,EAAQW,cAAc,CAACb,MAAD,CAAtB,EAAgC,WAAhC,EAA6CG,WAA7C,EAA0D,UAA1D,EAAsE,gBAAtE,CAAX,CAHK,CAtBE;CA2BbtX,EAAAA,GAAG,EAAE,CAACoC,KAAD,EAAQ,CAAR,EAAW6T,KAAK,CAAC,QAAD,CAAhB,CA3BQ;CA4BbqC,EAAAA,GAAG,EAAE,CAACC,KAAD,EAAQ,CAAR,EAAWtC,KAAK,CAAC,KAAD,CAAhB,CA5BQ;CA6BbuC,EAAAA,MAAM,EAAE,CAACvH,QAAD,EAAW,CAAX,EAAcgF,KAAK,CAAC,QAAD,CAAnB,CA7BK;CA8BbwC,EAAAA,KAAK,EAAE,CAACnW,OAAD,EAAU,CAAV,EAAa2T,KAAK,CAAC,OAAD,CAAlB,CA9BM;CA+BbyC,EAAAA,IAAI,EAAE,CAAC,KAAD,EAAQ,KAAR,EAAezC,KAAK,CAACC,YAAY,CAAC,CAAD,CAAb,EAAkB,WAAlB,CAApB,CA/BO;CAgCbyC,EAAAA,OAAO,EAAE,CAAC,KAAD,EAAQ,KAAR,EAAe1C,KAAK,CAACC,YAAY,CAAC,CAAD,CAAb,EAAkB,cAAlB,CAApB,CAhCI;CAiCb7K,EAAAA,KAAK,EAAE,CAAC,eAAD,EAAkB,SAAlB,EAA6B4K,KAAK,CAACC,YAAY,CAAC,CAAD,CAAb,EAAkB,OAAlB,CAAlC,CAjCM;CAkCb0C,EAAAA,KAAK,EAAE,CAAC,WAAD,EAAc,OAAd,EAAuB3C,KAAK,cAAA,CAA5B;CAlCM,CAAD,CAAbU;;CAqCA,SAASV,KAAT,CAAeL,MAAf,EAA+BiD,EAA/B,EAA8D;UACtD,CAACtB,SAAS,CAAC3B,MAAD,EAAS,KAAT,EAAgBiD,EAAhB,CAAV,EAA+BtB,SAAS,CAAC3B,MAAD,EAAS,IAAT,EAAeiD,EAAf,CAAxC;;;CAER,SAAStB,SAAT,CAAmB3B,MAAnB,EAAmCkD,GAAnC,EAAkDD,EAAlD,EAAuE;wBACnD3C,YAAY,CAAC,CAAD,WAAO4C,GAAG,GAAG,MAAH,GAAY,OAAKD,EAAE,IAAI,cAAQjD;;;CAGzE,SAASM,YAAT,CAAsB7M,GAAtB,EAA2B;gBACfA;;;CAGZ,SAAS2O,cAAT,CAAwB3E,IAAxB,EAAsC0F,GAAtC,EAA6D;UACrDA,GAAG,GAAGrB,UAAU,CAACrE,IAAD,EAAO/G,UAAU,CAAC+G,IAAD,CAAjB,CAAb,GAAwC/G,UAAU,CAAC+G,IAAD;;;CAG7D,SAASqE,UAAT,GAA8B;UACtBpX,KAAK,CAAC0Y,SAAN1Y,CAAgBuC,IAAhBvC,CAAqBmF,IAArBnF,CAA0B4D,SAA1B5D,EAAqC,KAArCA;;;CClQR;;;;;;;AAQA,CAIA,IAAM2Y,eAAe,GAAG,UAAxB;;AAUA,KAAaC,IAAb;CAAA;CAAA;iBASaC,SAAkB;UAHpB3Y,SAAiB;UACjB4Y,UAAmB;UAGvBD,UAAUA,OAAO,IAAIF;;;;;UAE3BI,uBAAe;YACP,KAAK7Y;CAbd;;UAeC8Y,mBAAItZ,KAAiB;SACduZ,IAAiB,GAAGvZ,GAAG,CAAC,KAAKmZ,OAAN;YACtBI,IAAI,GAAGA,IAAI,CAAC,CAAD,CAAJA,KAAYvZ,GAAZuZ,IAAmBA,IAAI,CAAC,CAAD,CAAJA,KAAY,IAAlC,GAAyC;CAjBtD;;UAmBCC,mBAAIxZ,KAAgB;YACZ,KAAKyZ,QAAL,CAAczZ,GAAd,EAAmB,KAAK0Z,IAAxB;CApBT;;UAsBCC,6BAAS3Z,KAAgB;YACjB,KAAKyZ,QAAL,CAAczZ,GAAd;CAvBT;;UAyBC4Z,mCAAY5Z,KAAQ0U,QAAoB;YAChC,KAAK+E,QAAL,CAAczZ,GAAd,EAAmB0U,MAAM,IAAI,KAAKmF,SAAL,CAAenF,MAAf,CAA7B;CA1BT;;UA4BCoF,qCAAa9Z,KAAQ0U,QAAoB;YACjC,KAAK+E,QAAL,CAAczZ,GAAd,EAAmB0U,MAAM,IAAI,KAAKmF,SAAL,CAAenF,MAAf,EAAuB,CAAvB,CAA7B;CA7BT;;UA+BCqF,yBAAOC,MAAmB;YAClB,KAAKC,WAAL,CAAiBD,IAAjB,EAAuB,KAAKN,IAA5B;CAhCT;;UAkCCQ,mCAAYF,MAAmB;YACvB,KAAKC,WAAL,CAAiBD,IAAjB;CAnCT;;UAqCCG,yCAAeH,MAAWtF,QAAoB;YACtC,KAAKuF,WAAL,CAAiBD,IAAjB,EAAuBtF,MAAM,IAAI,KAAKmF,SAAL,CAAenF,MAAf,CAAjC;CAtCT;;UAwCC0F,2CAAgBJ,MAAWtF,QAAoB;YACvC,KAAKuF,WAAL,CAAiBD,IAAjB,EAAuBtF,MAAM,IAAI,KAAKmF,SAAL,CAAenF,MAAf,EAAuB,CAAvB,CAAjC;CAzCT;;UA2CC2F,qBAAKra,KAAW;YACR,KAAKsa,YAAL,CAAkBta,GAAlB,EAAuB,CAAvB;CA5CT;;UA8CCua,qBAAKva,KAAW;YACR,KAAKsa,YAAL,CAAkBta,GAAlB,EAAuB,CAAvB;CA/CT;;UAiDCwa,yBAAW;SACJjB,IAAiB,GAAG,KAAKkB;YACxBlB,IAAI,IAAIA,IAAI,CAAC,CAAD;CAnDrB;;UAqDCmB,uBAAU;SACHnB,IAAiB,GAAG,KAAKG;YACxBH,IAAI,IAAIA,IAAI,CAAC,CAAD;CAvDrB;;UAyDCnR,qBAAKuS,IAAgCzX,OAAa;SAC7C,KAAK1C,QAAQ;CAChBiV,MAAAA,MAAM,CAACqD,GAAPrD,CAAW,KAAK2D,OAAhB3D,EAAyB,kCAAzBA;YACK2D,UAAU;CACfuB,MAAAA,EAAE,GAAG1W,IAAI,CAAC0W,EAAD,EAAKzX,KAAL,CAATyX;WACIpB,IAAI,GAAG,KAAKkB;;cACTlB,MAAM;aACRA,IAAI,CAAC,CAAD,CAAJA,KAAY,IAAZA,IAAoBoB,EAAE,CAACpB,IAAI,CAAC,CAAD,CAAL,CAAFoB,KAAgB,OAAO;CAC/CpB,QAAAA,IAAI,GAAGA,IAAI,CAAC,CAAD,CAAXA;;;YAEIqB;;YACAxB,UAAU;;CApElB;;UAuECyB,6BAAe;SACR9S,KAAU,GAAG,IAAIzH,KAAJ,CAAU,KAAKE,MAAf;SACf+Y,IAAI,GAAG,KAAKkB;SACfla,CAAC,GAAG;;YACEgZ,MAAM;WACRA,IAAI,CAAC,CAAD,CAAJA,KAAY,MAAMxR,KAAK,CAACxH,CAAC,EAAF,CAALwH,GAAawR,IAAI,CAAC,CAAD,CAAjBxR;CACtBwR,MAAAA,IAAI,GAAGA,IAAI,CAAC,CAAD,CAAXA;;;YAEMxR;CA/ET;;UAiFC+S,yBAAO9a,KAAgB;YACf,KAAK+a,QAAL,CAAc,KAAKlB,SAAL,CAAe7Z,GAAf,CAAd;CAlFT;;UAoFCgb,qBAAK;;UAGLC,yBAAQ;SACH,KAAKza,QAAQ;WACZ,KAAK4Y,SAAS;aACbG,IAAI,GAAG,KAAKkB;;gBACTlB,MAAM;CACZA,UAAAA,IAAI,CAAC,CAAD,CAAJA,KAAY,IAAZA,IAAoB,KAAK2B,YAAL,CAAkB3B,IAAlB,CAApBA;CACAA,UAAAA,IAAI,GAAGA,IAAI,CAAC,CAAD,CAAXA;;;cAEI/Y,SAAS;CANf,aAOO;cACD2a;;;CAjGT;;UAqGCpH,2BAAQ;;UAEEqH,iCAAWpb,KAAqB;SACjCmZ,OADiC,GACrB,KAAZA;SACJI,IAAiB,GAAGvZ,GAAG,CAACmZ,OAAD;;SACvBI,IAAI,IAAIA,IAAI,CAAC,CAAD,CAAJA,KAAYvZ,KAAK;WACxBuZ,IAAI,CAAC,CAAD,CAAJA,KAAY,MAAM;cAChBwB,SAASxB;;gBACP,KAAK6B,UAAL,CAAgBpb,GAAhB;CAFR,aAGO,IAAIuZ,IAAI,CAAC,CAAD,CAAR,EAAa;CACnB9D,QAAAA,MAAM,CAAC,8BAAD,CAANA;;CALF,WAOO;CACN8D,MAAAA,IAAI,GAAG,CAACvZ,GAAD,CAAPuZ;CACAzS,MAAAA,YAAY,CAAC9G,GAAD,EAAMmZ,OAAN,EAAeI,IAAf,EAAqB,KAArB,CAAZzS;;;CAEDyS,IAAAA,IAAI,CAAC,CAAD,CAAJA,GAAU,IAAVA;YACOA;CAtHT;;UAyHWM,+BAAU7Z,KAAqB;SAClCuZ,IAAiB,GAAGvZ,GAAG,CAAC,KAAKmZ,OAAN;CAC7B1D,IAAAA,MAAM,CAACvV,EAAPuV,CAAU8D,IAAI,IAAIA,IAAI,CAAC,CAAD,CAAJA,KAAY,IAA9B9D,EAAoC,4BAApCA;YACO8D;CA5HT;;UA+HWe,qCAAata,KAAQqb,YAAuB;SAC/C9B,IAAiB,GAAG,KAAKM,SAAL,CAAe7Z,GAAf;;SACtBsb,OAAoB,GAAG/B,IAAI,CAAC8B,UAAD;;SAC3BC,SAAS;cACL,CAACA,OAAO,CAAC,CAAD,GAAK;CACnBA,QAAAA,OAAO,GAAGA,OAAO,CAACD,UAAD,CAAjBC;aACI,CAACA,SAAS;;;cAERA,OAAO,CAAC,CAAD;;CAvIjB;;UA2ISC,iCAAWC,UAAuBC,UAAuBtZ,KAAakY,MAA4B;SACrGE;CACJiB,IAAAA,QAAQ,CAAC,CAAD,CAARA,GAAcnB,IAAdmB;;SACInB,MAAM;CACToB,MAAAA,QAAQ,CAAC,CAAD,CAARA,GAAclB,IAAI,GAAGF,IAAI,CAAC,CAAD,CAAzBoB;CACApB,MAAAA,IAAI,CAAC,CAAD,CAAJA,GAAUmB,QAAVnB;CAFD,WAGO;CACNoB,MAAAA,QAAQ,CAAC,CAAD,CAARA,GAAclB,IAAI,GAAG,KAAKE,IAA1BgB;YACKhB,OAAOe;;;SAETjB,MAAMA,IAAI,CAAC,CAAD,CAAJA,GAAUkB,QAAVlB,MACL,KAAKb,IAAL,GAAY+B,QAAZ;YACG,KAAKjb,MAAL,IAAe2B;CAvJzB;;UA0JWsX,6BAASzZ,KAAQqa,MAA4B;SAChDd,IAAI,GAAG,KAAK6B,UAAL,CAAgBpb,GAAhB;;YACN,KAAKub,UAAL,CAAgBhC,IAAhB,EAAsBA,IAAtB,EAA4B,CAA5B,EAA+Bc,IAA/B;CA5JT;;UA+JWJ,mCAAYD,MAAWK,MAA4B;SACxDrS,CAAC,GAAGgS,IAAI,CAACxZ;;SACTwH,GAAG;WACAyS,IAAI,GAAG,KAAKW,UAAL,CAAgBpB,IAAI,CAAC,CAAD,CAApB;;WACT0B,MAAM,GAAGjB;WACZf,IAAI,GAAGe;WACPla,CAAC,GAAG;;cACEA,CAAC,GAAGyH,GAAGzH,CAAC,IAAI;CAClBmZ,QAAAA,IAAI,GAAG,KAAK0B,UAAL,CAAgBpB,IAAI,CAACzZ,CAAD,CAApB,CAAPmZ;CACAA,QAAAA,IAAI,CAAC,CAAD,CAAJA,GAAUgC,MAAVhC;CACAgC,QAAAA,MAAM,CAAC,CAAD,CAANA,GAAYhC,IAAZgC;CACAA,QAAAA,MAAM,GAAGhC,IAATgC;;;cAEM,KAAKH,UAAL,CAAgBd,IAAhB,EAAsBf,IAAtB,EAA4B1R,CAA5B,EAA+BqS,IAA/B;;;YAED,CAAC;CA9KV;;UAiLWU,6BAASxB,MAA2B;UACxCH,UAAU,KAAK8B,YAAL,CAAkB3B,IAAlB,IAA0B,KAAKoC,UAAL,CAAgBpC,IAAhB;YAClC,EAAE,KAAK/Y;CAnLhB;;UAsLW0a,qCAAa3B,MAAyB;SACvCqC,WADuC,GACvB,KAAhBA;CACRrC,IAAAA,IAAI,CAAC,CAAD,CAAJA,CAAQ,KAAKJ,OAAbI,IAAwBla,SAAxBka,CAF+C;;CAG/CA,IAAAA,IAAI,CAAC,CAAD,CAAJA,GAAU,IAAVA;;SACIqC,aAAa;CAChBA,MAAAA,WAAW,CAACC,IAAZD,CAAiBrC,IAAjBqC;CADD,WAEO;YACDA,cAAc,CAACrC,IAAD;;CA7LtB;;UAiMWqB,2CAAiB;SAClBgB,WADkB,GACF,KAAhBA;;SACJA,aAAa;WACZzZ,GAAG,GAAGyZ,WAAW,CAACpb;;WAClB2B,KAAK;aACJ,KAAK3B,QAAQ;kBACT2B,GAAG;kBAASwZ,WAAWC,WAAW,CAACzZ,GAAD;;CAD1C,eAEO;gBACDgZ;;;CAENS,QAAAA,WAAW,CAACpb,MAAZob,GAAqB,CAArBA;;;CA3MJ;;UAgNWD,iCAAWpC,MAAmB;SACjCc,IAAI,GAAGd,IAAI,CAAC,CAAD;SAChBgB,IAAI,GAAGhB,IAAI,CAAC,CAAD;;SACRc,MAAM;CACTA,MAAAA,IAAI,CAAC,CAAD,CAAJA,GAAUE,IAAVF;CADD,WAEO;YACDI,OAAOF;;;SAETA,MAAM;CACTA,MAAAA,IAAI,CAAC,CAAD,CAAJA,GAAUF,IAAVE;CADD,WAEO;YACDb,OAAOW;;;CAEbd,IAAAA,IAAI,CAAC,CAAD,CAAJA,GAAUA,IAAI,CAAC,CAAD,CAAJA,GAAUA,IAAI,CAAC,CAAD,CAAJA,GAAU,IAA9BA;CA7NF;;UAgOW4B,6BAAU;SACf5B;SACHgB,IAAI,GAAG,KAAKE;;YACLlB,IAAI,GAAGgB,MAAO;CACrBA,MAAAA,IAAI,GAAGhB,IAAI,CAAC,CAAD,CAAXgB;CACAhB,MAAAA,IAAI,CAAC/Y,MAAL+Y,GAAc,CAAdA;;;UAEIkB,OAAOpb;UACPqa,OAAOra;UACPmB,SAAS;CAzOhB;;;EAAA;CAAa0Y,KACIC,OADJD,GACsBD,eADtBC;;CCtBb;;;;;;;AAQA,CAIA,IAAM4C,kBAAkB,GAAG,QAA3B;CACA,IAAMC,qBAAqB,GAAG,QAA9B;AAGA,KAAaC,MAAb;CAAA;CAAA;mBASaC,WAAoBC,cAAuB;UACjDC,UAAU7U,MAAM,CAAC,IAAD;UAChB8U,OAAO,IAAIlD,IAAJ;UACP+C,YAAYA,SAAS,IAAIH;UACzBI,eAAeA,YAAY,IAAIH;;;;;UAErCvC,mBAAI9V,IAAOR,OAAa0F,MAAoB;CAC3C1F,IAAAA,KAAK,GAAGmZ,UAAU,CAACnZ,KAAD,CAAlBA;SACQkZ,IAFmC,GAEjB,KAAlBA;SAAMD,OAF6B,GAEjB,KAAZA;SACRG,EAAE,GAAGC,MAAM,CAAC,IAAD,EAAO7Y,EAAP,EAAWR,KAAX;SACbqW,IAAI,GAAG4C,OAAO,CAACG,EAAD;;SACd,CAAC/C,MAAM;CACVA,MAAAA,IAAI,GAAG,CAAC+C,EAAD,EAAK5Y,EAAL,EAASR,KAAT,EAAgB0F,IAAhB,CAAP2Q;WACIiD,GAAG,GAAGJ,IAAI,CAAC5C,GAAL4C,CAAS7C,IAAT6C;WACNI,KAAKL,OAAO,CAACG,EAAD,CAAPH,GAAc5C,IAAd4C;cACFK;;;YAED,CAAC;CA1BV;;UA4BC1B,yBAAOpX,IAAOR,OAAqB;SAC1BkZ,IAD0B,GACR,KAAlBA;SAAMD,OADoB,GACR,KAAZA;SACRG,EAAE,GAAGC,MAAM,CAAC,IAAD,EAAO7Y,EAAP,EAAW2Y,UAAU,CAACnZ,KAAD,CAArB;SACXqW,IAAI,GAAG4C,OAAO,CAACG,EAAD;;SAChB/C,MAAM;CACT4C,MAAAA,OAAO,CAACG,EAAD,CAAPH,GAAc9c,SAAd8c;cACOC,IAAI,CAACtB,MAALsB,CAAY7C,IAAZ6C;;;YAED,CAAC;CApCV;;UAsCC9C,mBAAI5V,IAAOR,OAAsB;YACzB,CAAC,CAAC,KAAKiZ,OAAL,CAAaI,MAAM,CAAC,IAAD,EAAO7Y,EAAP,EAAW2Y,UAAU,CAACnZ,KAAD,CAArB,CAAnB;CAvCX;;UAyCCmW,uBAAe;YACP,KAAK+C,IAAL,CAAU/C,IAAV;CA1CT;;UA4CC4B,yBAAQ;UACFkB,UAAU7U,MAAM,CAAC,IAAD;UAChB8U,KAAKnB;CA9CZ;;UAgDC7S,qBAAKuS,IAAsDzX,OAAa;CACvEyX,IAAAA,EAAE,GAAGA,EAAE,CAAC1W,IAAH0W,CAAQzX,KAARyX,CAALA;UACKyB,KAAKhU,KAAK,UAAAmR,IAAA;cAAQoB,EAAE,CAACpB,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,EAAmBA,IAAI,CAAC,CAAD,CAAvB;CAAzB;CAlDF;;UAoDCxF,2BAAQ;;;EApDT;CAAaiI,OACIC,SADJD,GACwBF,kBADxBE;CAAAA,OAEIE,YAFJF,GAE2BD,qBAF3BC;CAuDb,IAAMS,gBAAgB,GAAG,CAAzB;CACA,IAAIC,gBAAgB,GAAG,CAAvB;CAAA,IACCC,aAAa,GAAG,CADjB;;CAGA,SAASJ,MAAT,CAAoCH,IAApC,EAAqD1Y,EAArD,EAA4DR,KAA5D,EAAiF;OACxE+Y,SADwE,GAC5CG,IAD4C,CACxEH;OAAWC,YAD6D,GAC5CE,IAD4C,CAC7DF;OAEfU,IAAI,GAAGlZ,EAAE,CAACuY,SAAD;OACZY,OAAO,GAAG3Z,KAAK,GAAGA,KAAK,CAACgZ,YAAD,CAAR,GAAyBO;OACrC,CAACG,MAAMA,IAAI,GAAG9V,YAAY,CAACpD,EAAD,EAAKuY,SAAL,EAAgB,EAAEU,aAAlB,EAAiC,KAAjC,EAAwC,KAAxC,EAA+C,KAA/C,CAAnBC;OACP,CAACC,SAASA,OAAO,GAAG/V,YAAY,CAAC5D,KAAD,EAAQgZ,YAAR,EAAsB,EAAEQ,gBAAxB,EAA0C,KAA1C,EAAiD,KAAjD,EAAwD,KAAxD,CAAtBG;UACJD,IAAV,MAAUA,GAAQC;;;CAGnB,SAASR,UAAT,CAAoBnZ,KAApB,EAAqC;UAC7B,CAACA,KAAD,GAAS7D,SAAT,GAAqB6D;;;CCtF7B;;;;;;;CCAA;;;;;;;AAOA,CAGA,IAAM4Z,KAAK,GAAG,IAAId,MAAJ,EAAd;CACA,IAAIe,OAAO,GAAG,KAAd;CACA,IAAIxC,IAAJ;;CAEA,SAASyC,WAAT,CAAqBtZ,EAArB,EAAmCR,KAAnC,EAAgD;CAC/CA,EAAAA,KAAK,GAAGQ,EAAE,CAAC+B,IAAH/B,CAAQR,KAARQ,CAAH,GAAoBA,EAAE,EAA3BR;;;CAGD,SAAS+Z,KAAT,GAAiB;CAChBH,EAAAA,KAAK,CAAC1U,IAAN0U,CAAWE,WAAXF;CACAA,EAAAA,KAAK,CAAC7B,KAAN6B;CACAC,EAAAA,OAAO,GAAG,KAAVA;;;CAGD,IAAIpd,IAAI,CAACud,gBAAD,CAAR,EAA4B;;OAEvBC,OAAO,GAAG;OACbC,QAAQ,GAAG,IAAIF,gBAAJ,CAAqBD,KAArB;OACXI,QAAQ,GAAGC,QAAQ,CAACC,cAATD,CAAwBH,OAAO,GAAG,EAAlCG;CACZF,EAAAA,QAAQ,CAACI,OAATJ,CAAiBC,QAAjBD,EAA2B;CAC1BK,IAAAA,aAAa,EAAE;CADW,GAA3BL;;CAGA7C,EAAAA,IAAI,GAAG,YAAW;CACjB8C,IAAAA,QAAQ,CAACzU,IAATyU,GAAgBF,OAAO,GAAG,EAA1BE;CACAF,IAAAA,OAAO,GAAGA,OAAO,GAAG,CAAH,GAAO,CAAxBA;CAFD,GAAA5C;CARD,CAAA,MAYO;CACNA,EAAAA,IAAI,GAAG,YAAW;CACjBmD,IAAAA,UAAU,CAACT,KAAD,EAAQ,CAAR,CAAVS;CADD,GAAAnD;;;AAKD,CAAO,SAASoD,QAAT,CAAkBja,EAAlB,EAAgCR,KAAhC,EAA6C;CACnD4Z,EAAAA,KAAK,CAACtD,GAANsD,CAAUpZ,EAAVoZ,EAAc5Z,KAAd4Z;;OACI,CAACC,SAAS;CACbA,IAAAA,OAAO,GAAG,IAAVA;CACAxC,IAAAA,IAAI;;;AAIN,CAAO,SAASqD,SAAT,CAAmBla,EAAnB,EAAiCR,KAAjC,EAA8C;CACpD4Z,EAAAA,KAAK,CAAChC,MAANgC,CAAapZ,EAAboZ,EAAiB5Z,KAAjB4Z;;;CChDD,IAAMe,QAAQ,GAAG,kBAAjB;AACA,KAAaC,MAAb;CAAA;CAAA;mBAKaC,MAAc;UACpBA,OAAOA;UACP5b,MAAM4b,IAAI,CAACvd;UACXwd,QAAQ;UACRC,UAAU;;;;;UAEhBC,6BAAS/a,QAA0C;SAC1C4a,IAD0C,GACZ,KAA9BA;SAAM5b,GADoC,GACZ,KAAxBA;SAAK6b,KAD+B,GACZ,KAAnBA;SAAOC,OADwB,GACZ,KAAZA;SACtB1d,CAAC,GAAGyd,KAAK,CAACxd;SACbqF;;SACG1C,MAAM,GAAG8a,SAAS;cACd1d,CAAC,IAAI;CACXsF,QAAAA,CAAC,GAAG1C,MAAM,GAAG6a,KAAK,CAACzd,CAAD,CAALyd,CAAS,CAATA,CAAbnY;aACIA,CAAC,IAAI,GAAG,OAAO,CAACtF,CAAC,GAAG,CAAL,EAAQsF,CAAR,EAAWmY,KAAK,CAACzd,CAAD,CAALyd,CAAS,CAATA,CAAX,CAAP;;CAHd,WAKO;WACFC,OAAO,GAAG9b,KAAK;aACdqK;CACJqR,QAAAA,QAAQ,CAACrS,SAATqS,GAAqBhY,CAAC,GAAGoY,OAAzBJ;;gBACQrR,CAAC,GAAGqR,QAAQ,CAACtS,IAATsS,CAAcE,IAAdF,GAAsB;CACjCG,UAAAA,KAAK,CAACzd,CAAC,EAAF,CAALyd,GAAa,CAACnY,CAAD,EAAI2G,CAAC,CAAC,CAAD,CAADA,IAAQ,EAAZ,CAAbwR;CACAnY,UAAAA,CAAC,GAAGgY,QAAQ,CAACrS,SAAb3F;eACI,CAACA,CAAD,IAAM1C,MAAM,GAAG0C,GAAG;;;cAElBoY,UAAUpY,CAAC,IAAI1D;;;cAEd5B,CAAC,GAAG,CAACA,CAAD,EAAI,CAAC4C,MAAM,GAAGhB,GAATgB,GAAehB,GAAfgB,GAAqBA,MAAtB,IAAgC6a,KAAK,CAACzd,CAAC,GAAG,CAAL,CAALyd,CAAa,CAAbA,CAApC,EAAqDA,KAAK,CAACzd,CAAC,GAAG,CAAL,CAALyd,CAAa,CAAbA,CAArD,CAAH,GAA2E,CAAC,CAAD,EAAI,CAAJ,EAAO,EAAP;;CA/BtF;;UAkCCG,yBAAOC,QAA0B;SACxBL,IADwB,GACf,KAATA;SACJM,IAAI,GAAG;SACVC,WAAW,GAAGF,MAAM,GAAGG,eAAH,GAAqBC;YAEnCT,IAAI,CAACja,OAALia,CAAaF,QAAbE,EAAuB,UAACvR,CAAD,EAAI/F,CAAJ,EAAOgY,CAAP;cAAazR,GAAG,CAACjM,MAAM,CAACsd,IAAI,EAAL,CAAP,EAAiB,CAAjB,CAAHrR,GAAyB,IAAzBA,GAAgCsR,WAAW,CAAC9R,CAAD,EAAI/F,CAAJ,EAAOgY,CAAP;CAA/E,KAAAV;CAvCT;;;EAAA;;CA0CA,SAASS,SAAT,CAAmBhS,CAAnB,EAA4B;UACpBA,CAAC,IAAI;;;CAEb,SAAS+R,eAAT,CAAyB/R,CAAzB,EAA4B/F,CAA5B,EAA+BgY,CAA/B,EAAkC;UAC1BhY,CAAC,GAAGsG,SAAS,CAACtG,CAAD,CAATsG,GAAe0R,CAAlB,GAAsBA;;;CClD/B;;;;;;;;AAQA,CAEA;;;;AAGA,CAAO,SAASC,aAAT,CAAuBzM,KAAvB,EAAuD0M,UAAvD,EAA4EhE,EAA5E,EAAwG;OAC1Gjb,KAAK,CAACuS,KAAD,GAAS;SACb1R,CAAC,GAAI0R,KAAD,CAAezR;;YAChBD,CAAC;CAAIqe,MAAAA,YAAY,CAAE3M,KAAD,CAAelG,UAAdkG,CAAyB1R,CAAzB0R,CAAF,EAA+B0M,UAA/B,EAA2ChE,EAA3C,CAAZiE;;CAFb,SAGO,IAAIxd,OAAO,CAAC6Q,KAAD,CAAX,EAAoB;SACtB1R,CAAC,GAAI0R,KAAD,CAAezR;;YAChBD,CAAC;CAAIme,MAAAA,aAAa,CAAEzM,KAAD,CAAe1R,CAAf,CAAD,EAAoBoe,UAApB,EAAgChE,EAAhC,CAAb+D;;CAFN,GAAA,MAGA,IAAI9e,KAAK,CAACqS,KAAD,CAAT,EAAkB;CACxB2M,IAAAA,YAAY,CAAC3M,KAAD,EAAe0M,UAAf,EAA2BhE,EAA3B,CAAZiE;;;;CAGF,SAASA,YAAT,CAAsB3S,IAAtB,EAAoC0S,UAApC,EAAyDhE,EAAzD,EAA2F;CAC1FA,EAAAA,EAAE,CAAC1O,IAAD,CAAF0O;;OACIgE,YAAY;SACX1S,IAAI,IAAI,IAAI;WACXA,IAAI,IAAI,IAAI0O,EAAE,CAAC1O,IAAI,GAAG,EAAR,CAAF0O;CADjB,WAEO,IAAI1O,IAAI,IAAI,GAAZ,EAAiB;CACvB0O,MAAAA,EAAE,CAAC1O,IAAI,GAAG,EAAR,CAAF0O;;;;;CC5BI,SAASkE,KAAT,CAAkBC,SAAlB,EAAgC;UAC/B,UACNC,KADM,EAEL;SACKpZ,KAAK,GAAGoZ,KAAK,CAAC/F;;UACf,IAAI3R,KAAKyX;WAAehZ,UAAU,CAACgZ,SAAD,EAAYzX,CAAZ,GAAgB1B,KAAK,CAAC0B,CAAD,CAAL1B,GAAWmZ,SAAS,CAACzX,CAAD,CAApB1B;;;YAChDoZ;CALR;;;;ACHD,KAcaC,UAAb,WADCH,KAAK,CAAC;CAAEI,EAAAA,QAAQ,EAAE;CAAZ,CAAD;CACN;CAAA;uBAQa3J,KAAa4J,YAAqBf,QAAoBgB,SAAuBC,MAAY;MACnG7f,MAAM,CAAC2f,UAAD,MAAiBA,UAAU,GAAGE,IAAI,CAACF;UACrCA,aAAaA,UAAU,IAAIf,MAAde,GAAuBf,MAAM,CAACe,UAA9BA,GAA2CA;UACxD5J,MAAMA;UACN6I,SAASA;UACTgB,UAAUA;UACVC,OAAOA;UACPC,MAAMF,OAAO,CAACG,QAARH;;;;;UAEZjB,+BAAqC;YAC7B,KAAKiB,OAAL,CAAahB,MAAb,CAAoBD,QAApB,CAA6B,KAAKmB,GAAlC;CAlBT;;;EAAA,aAAA;;CAyBA,SAASE,UAAT,CAAoB1J,GAApB,EAAqC;UAC7BA;;;CAGR,SAAS2J,YAAT,CAAsB5W,IAAtB,EAAiCzG,GAAjC,EAA8Cgd,OAA9C,EAAqE;CACpEA,EAAAA,OAAO,CAAC3F,GAAR2F,CAAYvW,IAAZuW;;;CAGD,IAAIM,KAAK,GAAG,CAAZ;CACA;;;;AAIA,KAAaC,IAAb,YADCb,KAAK,CAAC;CAAEc,EAAAA,KAAK,EAAE;CAAT,CAAD;CACN;CAAA;;;;;;;;;;;;;;;;iBA2Bahd,MAAcuc,YAAqBU,SAA0BC,OAAwB;UAC3FvD,KAAKmD,KAAK;UACV9c,OAAOA;UACPuc,aAAaA,UAAU,KAAK;UAC5BU,UAAUA,OAAO,IAAIJ;UACrBK,QAAQA,KAAK,IAAIN;;;;;;;;;;;;;WAUvBO,uBAAMxK,KAAa6J,SAAuBhB,QAAqBe,YAAkC;YACzF,IAAIF,UAAJ,CAAe1J,GAAf,EAAoB4J,UAApB,EAAgCf,MAAhC,EAAwCgB,OAAxC,EAAiD,IAAjD;CA3CT;;;;;;;;;;;WAsDWY,uBAAMzK,KAAa6J,SAAuBa,KAAkBd,YAAkC;SACjGrJ,GAAG,GAAG,KAAKiK,KAAL,CAAWxK,GAAX,EAAgB6J,OAAhB,EAAyBa,GAAzB,EAA8Bd,UAA9B;SACNe,OAAO,GAAG,KAAKJ,KAAL,CAAWhK,GAAX,EAAgBsJ,OAAhB,EAAyB,IAAzB;SACZc,SAAS,OAAOvgB,KAAK,CAACugB,OAAD,CAALvgB,IAAmBmW,GAAG,CAAC,CAAD,CAAHA,GAASoK,OAATpK,EAA6BA,GAAhDnW,IAAwDugB,OAA/D;CAzDf;;;;;;;;;;;WAoEWC,2BAAQtX,MAAWzG,KAAagd,SAAmC;SACtEtJ,GAAG,GAAG,KAAK+J,OAAL,CAAahX,IAAb,EAAmBzG,GAAnB,EAAwBgd,OAAxB,EAAiC,IAAjC;SACRtJ,KAAK,OAAQA,GAAD,CAAaoJ,QAAZpJ,GAAwBA,GAAxBA,GAA6C,KAAKiK,KAAL,CAAW/e,MAAM,CAAC8U,GAAD,CAAjB,EAAwBsJ,OAAxB,EAAiC,IAAjC,EAAuC,KAAvC,CAArD;CAtEX;;;;;;;WA6EC9T,yBAAyC;YACjCoK,MAAM;CA9Ef;;;;;;WAoFC0K,+BAAqC;YAC7B,KAAKC;CArFd;;;;;;WA2FC7d,uBAAqC;YAC7B,KAD6B;CA3FtC;;WA+FW8d,uCAAclB,SAAgC;SACjDlT,IAAI,GAAGkT,OAAO,CAACmB,QAARnB;YACNlT,IAAI,KAAK,CAATA,IAAc,CAAC,CAAC,KAAKsU,YAAL,CAAkBtU,IAAlB;CAjGzB;;WAoGWuU,uCAActQ,OAAgCyO,YAAsB;SACvE1M,KAAe,GAAG;SACvBpJ,KAAe,GAAG;CACnB6V,IAAAA,aAAa,CAACxO,KAAD,EAAQyO,UAAR,EAAoB,UAAA1S,IAAA,EAAQ;WACpC,CAACpD,KAAK,CAACoD,IAAD,GAAQ;CACjBgG,QAAAA,KAAK,CAAC4J,IAAN5J,CAAWhG,IAAXgG;CACApJ,QAAAA,KAAK,CAACoD,IAAD,CAALpD,GAAcoD,IAAdpD;;CAHW,KAAA,CAAb6V;UAMK0B,aAAanO;UACbwO,WAAW5X;CA9GlB;;WAiHW4X,iCAAW5X,OAAc;UAC7B0X,eAAe1X;UACftG,OAAOsG,KAAK,IAAIA,KAAK,CAACrI,MAANqI,GAAe,CAAxBA,GAA4B,KAAKwX,aAAjCxX,GAAiD6W,IAAI,CAACthB,SAAD,CAAJshB,CAAgBnd;CAnH/E;;;;;;;;WA2HWme,yBAAOhK,MAAsB;kBAC3B,KAAK5W,cAAS4W;CA5H3B;;;;;;;;WAoIWiK,2BAAQjK,MAAc;UAC1BA,OAAO,KAAKgK,MAAL,CAAYhK,IAAZ;UACPkK,sBAAoBlK;CAtI3B;;WAyICmK,6BAAkC;YAC1B,KAAKle,IAAL,IAAa,KAAK+T;CA1I3B;;;;;;WAgJClP,+BAAmB;YACX,KAAKqZ,OAAL;CAjJT;;;EAAA,cAAA;;CCpDA;;;;;;AAOA,CAEA;;;;AAGA,KAAaC,YAAb;CAAA;CAAA;;;;;;;;;yBAyBa3C,QAAgBJ,MAAc5a,QAAgB4d,QAAgBC,QAAuB/U,MAAe;UAC1GkS,SAASA;UACTJ,OAAOA;UACP5a,SAASA;UACT4d,SAASA;UACTC,SAASA;UACTpY,OAAO;UACPqY,WAAW;CAChBhV,IAAAA,IAAI,GAAI,KAAKiV,SAAL,GAAiBjV,IAArB,GAA6B,KAAKkV,UAAL,EAAjClV;;;;;UAGOkV,mCAAa;SACZpD,IADY,GACK,KAAjBA;SAAM5a,MADM,GACK,KAAXA;UACT+d,YAAY/d,MAAM,GAAG4a,IAAI,CAACvd,MAAd2C,GAAuB2I,QAAQ,CAACiS,IAAD,EAAO5a,MAAP,CAA/BA,GAAgD;CAtCnE;;;;;;UA4CCmE,2BAAS;YACD,IAAIwZ,YAAJ,CAAiB,KAAK3C,MAAtB,EAA8B,KAAKJ,IAAnC,EAAyC,KAAK5a,MAA9C,EAAsD,KAAK4d,MAAL,GAAc,KAAKE,QAAzE,EAAmF,IAAnF,EAAyF,KAAKC,SAA9F;CA7CT;;;;;;;UAoDCE,2BAAS;SACAH,QADA,GACa,KAAbA;UACHD,OAAOK,QAAQJ;UACfF,UAAUE;UACVA,WAAW;CAxDlB;;;;;;;;UAgECK,uBAAMnf,KAAcof,SAAkB;CACrCpf,IAAAA,GAAG,KAAKA,GAAG,GAAG,CAAX,CAAHA;CACAsT,IAAAA,MAAM,CAACmD,KAAPnD,CAAatT,GAAbsT,EAAkB,CAAlBA,EAAqB,KAAKwL,QAAL,GAAgB,CAArCxL;UACK4L,QAAQ,EAAE,KAAKJ,QAAL,GAAgB9e,GAAlB;UACRqf,UAAUD,OAAO,IAAI;CApE5B;;UAuECpf,qBAAc;YACN,KAAK8e;CAxEd;;;;;;UA8ECI,2BAAQ9gB,GAAW;UACb4C,UAAU5C;UACV0gB,YAAY1gB;;SACb,KAAK4C,MAAL,GAAc,GAAG;YACf4a,OAAO,KAAKI,MAAL,CAAYJ;YACnB5a,SAAS,KAAK4d,MAAL,GAAc,KAAKE;;;UAE7BE;CArFP;;;;;;;UA4FCM,2BAAQH,OAAyB;SAC5BA,OAAO;WACFne,MADE,GACS,KAAXA;YACH4a,OAAO,KAAKA,IAAL,CAAU5L,SAAV,CAAoBhP,MAApB;YACPA,SAAS;;;YAER,KAAK4a;CAlGd;;UAqGC2D,iCAAoB;YACZ,KAAKve;CAtGd;;UAyGCmc,+BAAmB;YACX,KAAKyB;CA1Gd;;UA6GCY,6BAAkB;YACV,KAAKZ,MAAL,GAAc,KAAKE;CA9G5B;;UAiHC5B,qBAAwB;SACf0B,MADe,GACJ,KAAXA;YACD,CAACA,MAAD,EAASA,MAAM,GAAG,KAAKE,QAAvB;CAnHT;;;;;;;UA0HCX,+BAAW;YACH,KAAKY;CA3Hd;;UA8HCU,+BAAW;YACH5V,IAAI,CAAC,KAAKkV,SAAN;CA/Hb;;UAkICW,qBAAe;YACP,KAAKX,SAAL,KAAmB;CAnI5B;;;;;;;UA0IC1H,mBAAI5Q,MAAW;UACTA,KAAKiT,KAAKjT;CA3IjB;;;;;;UAgJCmR,yBAAO+H,OAAc;SACZlZ,IADY,GACH,KAATA;SACFzG,GAAG,GAAGyG,IAAI,CAACpI;SACbD,CAAC,GAAGuhB,KAAK,CAACthB;;YACPD,CAAC;CAAIqI,MAAAA,IAAI,CAACzG,GAAG,GAAG5B,CAAP,CAAJqI,GAAgBkZ,KAAK,CAACvhB,CAAD,CAArBqI;;CApJd;;;;;;UAyJC4Y,+BAAUrf,KAAc;SACfyG,IADe,GACN,KAATA;CACRzG,IAAAA,GAAG,GAAGA,GAAG,IAAI,CAAbA;SACIyG,IAAI,CAACpI,MAALoI,GAAczG,KAAKyG,IAAI,CAACpI,MAALoI,GAAczG,GAAdyG;CA5JzB;;UA8JC2Y,6BAAU;YACF,KAAK3Y,IAAL,CAAUpI;CA/JnB;;;EAAA;;;;;;;;CCKA;;;;;AAIA,KAAauhB,WAAb;CAAA;CAAA,eAAA;;;;;;;;;;;wBAcEpf,MACAqf,QACAC,SACA/C,YACAU,SACAC,OACC;iBACDqC,UAAA,KAAA,EAAMvf,IAAN,EAAYuc,UAAZ,EAAwBU,OAAxB,EAAiCC,KAAjC;;WACKoC,UAAUA;SAEX,EAAED,MAAM,CAAC,CAAD,CAANA,IAAa,CAAf,GAAmBA,MAAM,CAAC,CAAD,CAANA,GAAY,CAAZA;SACnB,EAAEA,MAAM,CAAC,CAAD,CAANA,GAAY,CAAd,GAAkBA,MAAM,CAAC,CAAD,CAANA,GAAY,GAAZA;CACtBvM,IAAAA,MAAM,CAAC0M,UAAP1M,CAAkBuM,MAAM,CAAC,CAAD,CAAxBvM,EAA6BuM,MAAM,CAAC,CAAD,CAAnCvM;WACKuM,SAAS,CAACA,MAAM,CAAC,CAAD,CAAP,EAAYA,MAAM,CAAC,CAAD,CAAlB;;SACVA,MAAM,CAAC,CAAD,CAANA,KAAcA,MAAM,CAAC,CAAD,CAApBA,IAA2BA,MAAM,CAAC,CAAD,CAANA,KAAc,GAAG;aAC1C3W,QAAQ+W,MAAKC;aACbviB,OAAUsiB,MAAKtiB,IAAL,MAAA,GAAakiB,MAAM,CAAC,CAAD,CAAnB,IACdA,MAAM,CAAC,CAAD,CAANA,KAAcA,MAAM,CAAC,CAAD,CAApBA,GAA0B,EAA1BA,YAAqCA,MAAM,CAAC,CAAD,CAANA,KAAc,GAAdA,GAAoB,KAApBA,GAA4BA,MAAM,CAAC,CAAD,EADzD;;;;;;;;UAKjBM,uBAAMvE,MAAcwE,WAA4B;SACzCC,GAAG,GAAG,IAAI1B,YAAJ,CAAiB,IAAIhD,MAAJ,CAAWC,IAAX,CAAjB,EAAmCA,IAAnC,EAAyC,CAAzC,EAA4C,CAA5C;SACRlI,GAAG,GAAG,KAAKxK,KAAL,CAAWmX,GAAX;;SACN3M,KAAK;WACFP,GAAG,GAAG;WACR+J;;UACD;CACFA,QAAAA,GAAG,GAAGxJ,GAAG,CAACqI,QAAJrI,EAANwJ;CACA/J,QAAAA,GAAG,CAACmN,OAAJnN,OACKtI,GAAG,CAACjM,MAAM,CAACse,GAAG,CAAC,CAAD,CAAJ,CAAP,EAAiB,CAAjB,UAAuBrS,GAAG,CAACjM,MAAM,CAACse,GAAG,CAAC,CAAD,CAAJ,CAAP,EAAiB,CAAjB,aAA0BxJ,GAAG,CAACuJ,IAAJvJ,CAASrO,QAATqO,YAC1DA,GAAG,CAACP,iBACGvI,SAAS,CAACsS,GAAG,CAAC,CAAD,CAAJ,QAHlB/J;CAFD,eAOUO,GAAG,GAAGA,GAAG,CAACsI;;WAChBoE,SAAS,KAAK,OAAOjN,GAAG,CAACuG,IAAJvG,CAAS,UAATA,EAAqBkN,GAAG,CAACrE,MAAJqE,CAAWrE,MAAXqE,EAArBlN;aACnB,IAAI7J,WAAJ,CAAgB6J,GAAG,CAACzS,IAAJyS,CAAS,IAATA,CAAhB;;;YAEAkN,GAAG,CAAC5Z;CApDb;;UAsDWyZ,qCAA+C;YACjD5M,MAAM;CAvDf;;UAyDCiN,uBAAe;SACRC,KAAK,GAAG,KAAKV,OAAL,CAAa,IAAb;SACV1hB,CAAC,GAAGoiB,KAAK,IAAIA,KAAK,CAACniB;CAEvBiV,IAAAA,MAAM,CAACvV,EAAPuV,CAAUlV,CAAVkV,yBAAAA;UAEKkN,QAAQA;UACRV,UAAU;SAETW,KAAK,GAAG,KAAKC,MAAL,CAAYF,KAAZ;UAEThC,QAAQiC,KAAK,CAAC/f,IAAN+f,CAAW,KAAK9X,KAAhB8X;;YAENriB,CAAC;CAAIqiB,MAAAA,KAAK,CAACriB,CAAD,CAALqiB,eAAqBriB,YAAOqiB,KAAK,CAACriB,CAAD,CAAjCqiB;;;UACPE,UAAUF;YAERD;CAzET;;UA4EWlC,iCAAW5X,OAAc;SAC9B,KAAKmZ,MAAL,CAAY,CAAZ,GAAgBE,eAAA,CAAMzB,UAAN,KAAA,KAAA,EAAiB5X,KAAjB;CA7EtB;;UA+ECka,+BAAmB;YACX,KAAKJ,KAAL,IAAc,KAAKD,IAAL;CAhFvB;;UAmFCvC,6BAAS6C,OAA4B;SAC5B1G,EAD4B,GACT,KAAnBA;SAAI8D,UADwB,GACT,KAAfA;YACLA,UAAU,GACdA,UADc,GAEb4C,KAAK,IAAI,CAACvZ,UAAU,CAACuZ,KAAD,EAAQ1G,EAAR,CAApB0G,IAAoC,KAAKL,KAAzCK,GACD,EADCA,IAEA,KAAKN,IAAL,IAAa,KAAKtC,UAFlB4C;CAvFN;;UA4FCC,2BAAQ9D,SAAmC;SACpCtJ,GAAG,GAAG,KAAKqK,OAAL,CAAaf,OAAO,CAACvW,IAArB,EAA2BuW,OAAO,CAAChd,GAARgd,EAA3B,EAA0CA,OAAO,CAAC6B,MAAlD;MACXnL,OAAOsJ,OAAO,CAACiC,MAARjC;YACDtJ;CA/FT;;UAkGSgN,yBAAOF,OAAeK,OAA4B;SACrDziB,CAAC,GAAGoiB,KAAK,CAACniB;SACRoiB,KAAe,GAAG,IAAItiB,KAAJ,CAAUC,CAAV;SACvB+b,EAAE,GAAG,KAAKA;;YACJ/b,CAAC;CAAIqiB,MAAAA,KAAK,CAACriB,CAAD,CAALqiB,GAAWD,KAAK,CAACpiB,CAAD,CAALoiB,CAAS9B,OAAT8B,CAAiBK,KAAK,GAAGA,KAAK,CAACjgB,MAANigB,CAAa1G,EAAb0G,CAAH,GAAsB,CAAC1G,EAAD,CAA5CqG,CAAXC;;;YACLA;CAvGT;;UA0GC/B,2BAAQmC,OAA0B;SACzB1G,EADyB,GACZ,KAAbA;SAAI3Z,IADqB,GACZ,KAATA;SACRpC;YAEGoC,IAAI,GACRA,IADQ,GAERqgB,KAAK,GACL,CAAEziB,CAAC,GAAGkJ,UAAU,CAACuZ,KAAD,EAAQ1G,EAAR,CAAd/b,EAA4B,CAACA,CAA/B,UACK,KAAKT,iBAAYkjB,KAAK,CAACziB,CAAD,OAD3B,GAEC,KAAKmgB,MAAL,CAAY,KAAKmC,MAAL,CAAY,KAAKE,QAAL,EAAZ,EAA6BC,KAA7B,EAAoCngB,IAApC,CAAyC,KAAKiI,KAA9C,CAAZ,CAHI,GAIL,KAAK4L;CApHV;;;EAAA,CAAiCgJ,IAAjC;;;ACrBA,CAaA;;;;;AAKA,KAAawD,OAAb,aADCrE,KAAK,CAAC;CAAE/e,EAAAA,IAAI,EAAE,KAAR;CAAegL,EAAAA,KAAK,EAAE;CAAtB,CAAD;CACN;CAAA,sBAAA;;;;;;;;;UACC4X,uBAAe;SACRC,KAAK,0BAASD;;UAEflC,cAAcmC,KAAK,CAAC,CAAD,CAALA,CAASxC,QAATwC,CAAkB,CAAC,KAAKrG,EAAN,CAAlBqG;YACZA;CALT;;UAOCtX,uBAAM8T,SAAmC;SAClCwD,KAAK,GAAG,KAAKI,QAAL;SACb5gB,GAAG,GAAGwgB,KAAK,CAACniB;SACZgiB,GAAG,GAAGrD,OAAO,CAAC7X,MAAR6X;SACHtJ;SACHtV,CAAS,GAAG;;YACNA,CAAC,GAAG4B,KAAK5B,CAAC;WAASsV,GAAG,GAAG,KAAKsN,QAAL,CAAcR,KAAK,CAACpiB,CAAD,CAAnB,EAAwBA,CAAxB,EAA2BiiB,GAA3B,GAAkC,OAAO3M,GAAP;;;YAC3D,KAAKoN,OAAL,CAAaT,GAAb;CAdT;;UAgBWH,mCAAYlD,SAAmC;SAClDwD,KAAK,GAAG,KAAKI,QAAL;SACb5gB,GADK,GACCwgB,KAAK,CAACniB;wBACC,KAAKwhB;SAAjBoB,GAFI;SAECC,GAFD;SAGLb,GAHK,GAGCrD,OAAO,CAAC7X,MAAR6X;SAEHtJ;SACHmM,MAAc,GAAG;SACjBzhB;SACA+iB;SACAC;;CAEDC,IAAAA,GAAG,EAAE,OAAOxB,MAAM,GAAGqB,GAAhB,EAAqBrB,MAAM,EAA3B,EAA+B;CACnCuB,MAAAA,IAAI,GAAGf,GAAG,CAACjB,OAAJiB,EAAPe;CACAD,MAAAA,IAAI,GAAGd,GAAG,CAACrgB,GAAJqgB,EAAPc;;YACK/iB,CAAC,GAAG,GAAGA,CAAC,GAAG4B,KAAK5B,CAAC,IAAI;aACpBsV,GAAG,GAAG,KAAKsN,QAAL,CAAcR,KAAK,CAACpiB,CAAD,CAAnB,EAAwBA,CAAxB,EAA2BiiB,GAA3B,GAAkC;eACxCR,MAAM,GAAGoB,KAAK,OAAOvN,GAAP;CAClB2M,UAAAA,GAAG,CAAClB,KAAJkB,CAAUc,IAAVd,EAAgBe,IAAhBf;iBACMgB;;;;;YAIF,KAAKP,OAAL,CAAaT,GAAb;CAvCT;;UAyCCW,6BAAS/D,MAAY7e,GAAWiiB,KAA+B;SAC1D3M;YACG,CAAC,CAACuJ,IAAI,CAAC7c,IAAL6c,CAAUoD,GAAVpD,CAAD,KAAoBvJ,GAAG,GAAGuJ,IAAI,CAAC/T,KAAL+T,CAAWoD,GAAXpD,CAA1B,CAAD,MAAiDvJ,GAAG,GAAG,KAAKkK,KAAL,CAAW,KAAK+C,OAAL,CAAaviB,CAAb,CAAX,EAA4BiiB,GAA5B,EAAiC3M,GAAjC,CAAvD;CA3CT;;;EAAA,CAA6BkM,WAA7B,cAAA;;;AClBA,CAcA;;;;AAIA,KAAa0B,MAAb,aADC5E,KAAK,CAAC;CAAE/e,EAAAA,IAAI,EAAE,IAAR;CAAcgL,EAAAA,KAAK,EAAE;CAArB,CAAD;CACN;CAAA,sBAAA;;;;;;;;;UAGC4X,uBAAe;SACRC,KAAK,0BAASD;SACnBvgB,GAAG,GAAGwgB,KAAK,CAACniB;SACZ8b,EAAE,GAAG,KAAKA;SACVoH,MAAgB,GAAG;;CACnBC,IAAAA,OAAmB,GAAG;;CACtB9a,IAAAA,KAAe,GAAG,CACjB,EADiB;CAAA;;SAIftI,GAAWoI,GAAWtB,GAA6B4K,MAVzC;;UAaT1R,CAAC,GAAG,GAAGA,CAAC,GAAG4B,KAAK5B,CAAC,IAAI;CACzBojB,MAAAA,OAAO,CAACpjB,CAAD,CAAPojB,GAAa,EAAbA,CADyB;;CAEzBjF,MAAAA,aAAa,CAACiE,KAAK,CAACpiB,CAAD,CAALoiB,CAASxC,QAATwC,CAAkB,CAACrG,EAAD,CAAlBqG,CAAD,EAA0B,KAA1B,EAAiC,UAAA1W,IAAA,EAAQ;CACrD0X,QAAAA,OAAO,CAACpjB,CAAD,CAAPojB,CAAW9H,IAAX8H,CAAgB1X,IAAhB0X,EADqD;;aAEjD,CAAC9a,KAAK,CAACoD,IAAD,GAAQ;CACjBpD,UAAAA,KAAK,CAACoD,IAAD,CAALpD,GAAc,EAAdA,CADiB;;CAEjB6a,UAAAA,MAAM,CAAC7H,IAAP6H,CAAYzX,IAAZyX,EAFiB;;CAFN,OAAA,CAAbhF;CAfa,KAAA;;;UAyBTne,CAAC,GAAG,GAAGA,CAAC,GAAG4B,KAAK5B,CAAC,IAAI;CACzB0R,MAAAA,KAAK,GAAG0R,OAAO,CAACpjB,CAAD,CAAf0R,CADyB;;WAErB,CAACA,KAAK,CAACzR,QAAQ;;CAElBqI,QAAAA,KAAK,CAAC,CAAD,CAALA,CAASgT,IAAThT,CAAc8Z,KAAK,CAACpiB,CAAD,CAAnBsI,EAFkB;;CAGlBoJ,QAAAA,KAAK,GAAGyR,MAARzR,CAHkB;CAFM,OAAA;;;CASzBtJ,MAAAA,CAAC,GAAGsJ,KAAK,CAACzR,MAAVmI;;cACOA,CAAC,IAAI;CACXtB,QAAAA,CAAC,GAAGwB,KAAK,CAACoJ,KAAK,CAACtJ,CAAD,CAAN,CAATtB;;aACIA,CAAC,CAACgC,GAAFhC,KAAU9G,GAAG;;CAEhB8G,UAAAA,CAAC,CAACwU,IAAFxU,CAAOsb,KAAK,CAACpiB,CAAD,CAAZ8G,EAFgB;;CAGhBA,UAAAA,CAAC,CAACgC,GAAFhC,GAAQ9G,CAAR8G;;;CAxCW,KAAA;;;UA8CT+Y,aAAavX,KAAK,CAAC,CAAD,CAALA,CAASrI,MAATqI,GAAkB,EAAlBA,GAAuB6a;UAEpC7a,QAAQ6a,MAAM,CAACljB,MAAPkjB,IAAiB7a;CAC9B6a,IAAAA,MAAM,CAACljB,MAAPkjB,IAAiB,CAAC7a,KAAK,CAAC,CAAD,CAALA,CAASrI,MAA3BkjB,IAAqC,KAAKjD,UAAL,CAAgB5X,KAAhB,CAArC6a;YACOf;CArDT;;UAuDCtX,uBAAM8T,SAAmC;SAChCtW,KADgC,GACtB,KAAVA;SACF8Z,KAAa,GAAG9Z,KAAK,GAAGA,KAAK,CAACsW,OAAO,CAACmB,QAARnB,EAAD,CAALtW,IAA6BA,KAAK,CAAC,CAAD,CAArC,GAA2C,KAAKka,QAAL;SACrE5gB,GAAG,GAAGwgB,KAAK,CAACniB;SACZgiB,GAAG,GAAGrD,OAAO,CAAC7X,MAAR6X;SACHtJ;SACH+N;SACArjB,CAAC,GAAG;;YACEA,CAAC,GAAG4B,KAAK5B,CAAC,IAAI;CACpBsV,MAAAA,GAAG,GAAG8M,KAAK,CAACpiB,CAAD,CAALoiB,CAAStX,KAATsX,CAAeH,GAAfG,KAAuB,KAAKM,OAAL,CAAaT,GAAb,CAA7B3M;WACI,CAACA,KAAK;;WACN,CAACA,GAAG,CAACqJ,YAAY;CACpB0E,QAAAA,KAAK,GAAG/N,GAAR+N;;;;WAGG,CAACA,KAAD,IAAU/N,GAAG,CAACwJ,GAAJxJ,IAAW+N,KAAK,CAACvE,KAAKuE,KAAK,GAAG/N,GAAR+N;CACpCpB,MAAAA,GAAG,CAAClB,KAAJkB;;;YAEM,KAAKzC,KAAL,CAAW,KAAKa,MAAhB,EAAwB4B,GAAxB,EAA6BoB,KAA7B;CAzET;;UA2EWvB,mCAAYlD,SAAmC;SAClDtW,KADkD,GACxC,KAAVA;wBACa,KAAKmZ;SAAjBoB,GAFiD;SAE5CC,GAF4C;SAGvDb,GAHuD,GAGjDrD,OAAO,CAAC7X,MAAR6X;SAEHwD;SACHxgB;SACA0T;SACA+N;SACA5B,MAAc,GAAG;SACjBzhB;SACA+iB;SACAC;;SAEG,CAAC1a,OAAO;CACX8Z,MAAAA,KAAK,GAAG,KAAKI,QAAL,EAARJ;CACA9Z,MAAAA,KAAK,GAAG,KAAKA,KAAbA;CACA1G,MAAAA,GAAG,GAAGwgB,KAAK,CAACniB,MAAZ2B;;;CAGDqhB,IAAAA,GAAG,EAAE,OAAOxB,MAAM,GAAGqB,GAAhB,EAAqBrB,MAAM,EAA3B,EAA+B;WAC/BnZ,OAAO;CACV8Z,QAAAA,KAAK,GAAG9Z,KAAK,CAAC2Z,GAAG,CAAClC,QAAJkC,EAAD,CAAL3Z,IAAyBA,KAAK,CAAC,CAAD,CAAtC8Z;CACAxgB,QAAAA,GAAG,GAAGwgB,KAAK,CAACniB,MAAZ2B;;;WAEGA,KAAK;CACRohB,QAAAA,IAAI,GAAGf,GAAG,CAACjB,OAAJiB,EAAPe;CACAD,QAAAA,IAAI,GAAGd,GAAG,CAACrgB,GAAJqgB,EAAPc;CACAM,QAAAA,KAAK,GAAG,IAARA;;cACKrjB,CAAC,GAAG,GAAGA,CAAC,GAAG4B,KAAK5B,CAAC,IAAI;CACzBsV,UAAAA,GAAG,GAAG8M,KAAK,CAACpiB,CAAD,CAALoiB,CAAStX,KAATsX,CAAeH,GAAfG,CAAN9M;eACI,CAACA,KAAK,SAAS2N,GAAT;;eACN,CAAC3N,GAAG,CAACqJ,YAAY;CACpB0E,YAAAA,KAAK,GAAG/N,GAAR+N;;;;eAGG,CAACA,KAAD,IAAU/N,GAAG,CAACwJ,GAAJxJ,IAAW+N,KAAK,CAACvE,KAAKuE,KAAK,GAAG/N,GAAR+N;CACpCpB,UAAAA,GAAG,CAAClB,KAAJkB,CAAUc,IAAVd,EAAgBe,IAAhBf;;;;WAGER,MAAM,GAAGoB,KAAK,OAAO,KAAKrD,KAAL,CAAW,KAAKa,MAAhB,EAAwB4B,GAAxB,EAA6BoB,KAA7B,CAAP;;;YAEZ,KAAKX,OAAL,CAAaT,GAAb;CArHT;;;EAAA,CAA4BT,WAA5B,cAAA;;CCRA;;;;AAGA,KAAa8B,SAAb;CAAA;CAAA,eAAA;;;;;;;;;;;;sBAYElhB,MACAuN,OACAyO,YACAO,YACAU,SACAC,OACC;iBACDqC,UAAA,KAAA,EAAMvf,IAAN,EAAYuc,UAAZ,EAAwBU,OAAxB,EAAiCC,KAAjC;;WACKlB,aAAaA;;WACb6B,cAActQ,OAAOyO;;;;;;;;;;;;;;UAS3BmF,2BAAQlb,MAAyBzG,KAAagd,SAAmC;CAChFA,IAAAA,OAAO,CAACkC,OAARlC,CAAgBhd,GAAhBgd;YACO,KAAKe,OAAL,CAAatX,IAAb,EAAmBzG,GAAnB,EAAwBgd,OAAxB;CAhCT;;;EAAA,CAA+BO,IAA/B;;CCDA;;;;;;;AAMA,KAAaqE,aAAb;CAAA;CAAA,oBAAA;;;;;;;;;;;;;0BAYEphB,MACAqhB,QACArF,YACAO,YACAU,SACAC,OACC;iBACDoE,eAAA,KAAA,EAAMthB,IAAN,EAAYqhB,MAAZ,EAAoBrF,UAApB,EAAgCO,UAAhC,EAA4CU,OAA5C,EAAqDC,KAArD;;WAlBD/f,OAAe;SAmBRmS,KAAK,GAAGmQ,MAAKhC;SAEf7f,CAAC,GAAG0R,KAAK,CAACzR;SACbkW,IAAI,GAAG;;SACJnW,GAAG;WACA2jB,KAAK,GAAG;;cACP3jB,CAAC;CAAI2jB,QAAAA,KAAK,CAAC3jB,CAAD,CAAL2jB,GAAWlY,IAAI,CAACiG,KAAK,CAAC1R,CAAD,CAAN,CAAf2jB;;;CACZxN,MAAAA,IAAI,UAAOwN,KAAK,CAACrhB,IAANqhB,CAAW,OAAXA,QAAXxN;;;WAEIiK,QAAQjK;;;;;;;UAEdrL,uBAAM8T,SAAuB;YACrB,KAAK2E,OAAL,CAAa3E,OAAO,CAACyC,QAARzC,EAAb,EAAiC,CAAjC,EAAoCA,OAApC;CAhCT;;;EAAA,CAAmC0E,SAAnC;;;AClBA,CAgBA;;;;;;;;AAQA,KAAaM,YAAb,aADCtF,KAAK,CAAC;CAAE/e,EAAAA,IAAI,EAAE;CAAR,CAAD;CACN;CAAA,oBAAA;;;;;;;;;;;;;;;;;;yBAoBE6C,MACAyhB,QACAC,MACAnU,OACAgP,YACAU,SACAC,OACC;;;CACDwE,IAAAA,IAAI,GAAGA,IAAI,KAAK,KAATA,IAAkBzkB,KAAK,CAACykB,IAAD,CAAvBA,GAAgCA,IAAhCA,GAAuC,CAAC,CAACA,IAAF,IAAU,CAAxDA;SAEM5f,MAAM,GAAGD,gBAAgB,IAAI,CAAC6f;;CACnCC,IAAAA,OAAO,GAAGF,MAAM,CAACjG;SACjBQ,UAAU,GAAGyF,MAAM,CAACzF,WALpB;;;;;;;;CAeDyF,IAAAA,MAAM,GAAG,IAAIjjB,MAAJ,CACRsD,MAAM,GAAG6f,OAAH,YAAoBA,aADlB,EAER,CAAC3F,UAAU,GAAG,GAAH,GAAS,EAApB,KAA2ByF,MAAM,CAACG,SAAPH,GAAmB,GAAnBA,GAAyB,EAApD,KAA2D3f,MAAM,GAAG,GAAH,GAAS,EAA1E,CAFQ,CAAT2f;mCAKMzhB,MAAMuN,OAAOyO,YAAYO,YAAYU,SAASC;WAC/CuE,SAASA;WACTC,OAAOA;WACPhZ,QAAQ5G,MAAM,GAAG2d,MAAKoC,WAAR,GAAsBpC,MAAKqC;CAE9ChgB,IAAAA,MAAM,GAAI2d,MAAKsC,OAAL,GAAeL,IAAI,KAAK,KAATA,GAAiBM,QAAjBN,GAA4BO,WAA/C,GAA+DxC,MAAKyC,MAAL,GAAcC,QAAQ,CAACT,IAAD,CAA3F5f;;WAEKkc,QAAQ2D;;;;;;;UAEdjZ,uBAAM8T,SAAuB;YACrB,KAAK2E,OAAL,CAAa3E,OAAO,CAACyC,QAARzC,EAAb,EAAiC,CAAjC,EAAoCA,OAApC;CAzDT;;;;;;UA8DCqF,mCAAYrF,SAAmC;SACxCpR,GAAG,GAAG,KAAKqW;SAChBrG,IAAI,GAAGoB,OAAO,CAACsC,OAARtC;SACPjP,KAAK,GAAGiP,OAAO,CAACuC,SAARvC;CACTpR,IAAAA,GAAG,CAACvC,SAAJuC,GAAgBmC,KAAhBnC;YACOA,GAAG,CAACxL,IAAJwL,CAASgQ,IAAThQ,IACJ,KAAK+V,OAAL,CAAa,KAAKY,OAAL,CAAa3G,IAAb,EAAmB7N,KAAnB,EAA0BnC,GAAG,CAACvC,SAA9B,CAAb,EAAuDuC,GAAG,CAACvC,SAAJuC,GAAgBmC,KAAvE,EAA8EiP,OAA9E,CADIpR,GAEJ,KAAKgS,KAAL,CAAW,KAAKa,MAAhB,EAAwBzB,OAAxB;CArEL;;;;;;UA0ECsF,+BAAUtF,SAAmC;SACtC3S,CAAC,GAAG,KAAK4X,MAAL,CAAY7Y,IAAZ,CAAiB4T,OAAO,CAACsC,OAARtC,CAAgB,IAAhBA,CAAjB;;SACN3S,GAAG;cACC,KAAKsX,OAAL,CAAa,KAAKe,MAAL,CAAYrY,CAAZ,CAAb,EAA6BA,CAAC,CAAC,CAAD,CAADA,CAAKhM,MAAlC,EAA0C2e,OAA1C;;;YAED,KAAKY,KAAL,CAAW,KAAKa,MAAhB,EAAwBzB,OAAxB;CA/ET;;;EAAA,CAAkC0E,SAAlC,cAAA;;CAmFA,SAASiB,QAAT,CAAkBT,IAAlB,EAA8E;UACtEA,IAAI,KAAK,KAATA,GACJM,QADIN,GAEJA,IAAI,KAAK,IAATA,GACAU,OADAV,GAEAA,IAAI,IAAI,CAARA,GACA,UAAC7X,CAAD;YAAyBA,CAAC,CAAC6X,IAAD;CAD1B,GAAAA,GAEA7hB,QAAQ,aAAWsG,QAAQ,CAAC,IAAIxI,KAAJ,CAAU,CAAC+jB,IAAX,CAAD,EAAmB,UAAC7b,CAAD,EAAIjI,CAAJ;oBAAeA,CAAC,GAAG;CAAtC,GAAA,CAARuI,CAAoDjG,IAApDiG,CAAyD,MAAzDA,CAAX,EAA+E,CAAC,GAAD,CAA/E;;;CAGZ,SAAS6b,QAAT,GAA4B;UACpB;;;CAGR,SAASI,OAAT,CAAiBvY,CAAjB,EAAwC;UAChCA;;;CAGR,SAASoY,WAAT,CAAqB7G,IAArB,EAAmC7N,KAAnC,EAAkD8U,GAAlD,EAAuE;UAC/DjH,IAAI,CAAC5L,SAAL4L,CAAe7N,KAAf6N,EAAsBiH,GAAtBjH;;;;AC9HR,KAaakH,eAAb,aADCpG,KAAK,CAAC;CAAE/e,EAAAA,IAAI,EAAE;CAAR,CAAD;CACN;CAAA,uBAAA;;;4BAEE6C,MACAmC,KACA6Z,YACAO,YACAU,SACAC,OACC;iBACDqF,kBAAA,KAAA,EAAMviB,IAAN,EAAY,IAAIxB,MAAJ,CAAW0D,QAAQ,CAACC,GAAD,CAAnB,EAA0B6Z,UAAU,GAAG,GAAH,GAAS,EAA7C,CAAZ,EAA8D,CAA9D,EAAiE7Z,GAAG,CAACiH,UAAJjH,CAAe,CAAfA,CAAjE,EAAoFoa,UAApF,EAAgGU,OAAhG,EAAyGC,KAAzG;;WACKc,QAAQ7b;;;;;;EAVf,CAAqCqf,YAArC,cAAA;;CCbA;;;;;;;AASA;CAaA;;;CAGA;;AAEA,CAAO,SAASgB,YAAT,GAAqE;AAE5E,CAAO,SAASC,WAAT,CAAqBxc,IAArB,EAAgCzG,GAAhC,EAA6Cgd,OAA7C,EAAoE;CAC1EA,EAAAA,OAAO,CAACpF,MAARoF,CAAevW,IAAfuW;;AAED,CAAO,SAASkG,WAAT,CAAqBhf,GAArB,EAA0B;OAC1B3C,EAAE,GAAG/D,IAAI,CAAC0G,GAAD,CAAJ1G,GAAY0G,GAAZ1G,GAAkB;YAAM0G;CAAnC;UACO,UAACuC,IAAD,EAAYzG,GAAZ,EAAyBgd,OAAzB,EAAmD;CACzDA,IAAAA,OAAO,CAAC3F,GAAR2F,CAAYzb,EAAE,CAACkF,IAAD,EAAOzG,GAAP,EAAYgd,OAAZ,CAAdA;CADD;;;CAKD;;;CAGA;CAEA;CACA;CACA;CACA;CACA;CACA;CACA;;AA2IA,CAAO,SAAS9T,KAAT,GAA4B;UAC3Bia,OAAO,CAACphB,SAAD;;;CAaf,SAASohB,OAAT,CAAiB5iB,IAAjB,EAAiE6iB,cAAjE,EAA8G;OACzG5iB;OACH2hB;OACAF;OACAC,IAAsB,GAAG;OACzBjE;OACAzB,UAAmB,GAAG;OACtBO;OACAU;OACAC;;OACGzd,KAAK,CAACM,IAAI,CAAC,CAAD,CAAL,GAAW;SACbiE,KAAI,GAAGjE,IAAI,CAAC,CAAD;SAChBmD,CAAC,GAAGc,KAAI,CAAC2d;;SACNpjB,KAAK,CAAC2E,CAAD,GAAK;CACbue,MAAAA,MAAM,GAAGve,CAATue;CACAC,MAAAA,IAAI,GAAG1d,KAAI,CAAC0d,IAAZA;CACAjE,MAAAA,UAAU,GAAGzZ,KAAI,CAACyZ,UAAlBA;CAHD,WAIO,IAAIoF,cAAc,CAAC3f,CAAD,CAAlB,EAAuB;CAC7Bye,MAAAA,OAAO,GAAGze,CAAVye;CACA3F,MAAAA,UAAU,GAAGhY,KAAI,CAACgY,UAAlBA;;;CAEDhc,IAAAA,IAAI,GAAGgE,KAAI,CAAChE,IAAZA;CACAuc,IAAAA,UAAU,GAAGvY,KAAI,CAACuY,UAAlBA;CACAU,IAAAA,OAAO,GAAGjZ,KAAI,CAACiZ,OAAfA;CACAC,IAAAA,KAAK,GAAGlZ,KAAI,CAACkZ,KAAbA;CAdD,SAeO;SACFtf,CAAC,GAAG;;SAEJilB,cAAc,CAAC9iB,IAAI,CAAC,CAAD,CAAL,GAAW;CAC5BC,MAAAA,IAAI,GAAGD,IAAI,CAAC,CAAD,CAAXC;CACAzB,MAAAA,KAAK,CAACwB,IAAI,CAAC,CAAD,CAAL,CAALxB,GAAkBkjB,MAAM,GAAG1hB,IAAI,CAAC,CAAD,CAA/BxB,GAAuCojB,OAAO,GAAG5hB,IAAI,CAAC,CAAD,CAArDxB;CAFD,WAGO,IAAIskB,cAAc,CAAC9iB,IAAI,CAAC,CAAD,CAAL,CAAlB,EAA6B;CACnCnC,MAAAA,CAAC,GAAG,CAAJA;CACAW,MAAAA,KAAK,CAACwB,IAAI,CAAC,CAAD,CAAL,CAALxB,GAAkBkjB,MAAM,GAAG1hB,IAAI,CAAC,CAAD,CAA/BxB,GAAuCojB,OAAO,GAAG5hB,IAAI,CAAC,CAAD,CAArDxB;;;SAGGkjB,QAAQ;WACP7kB,MAAM,CAACmD,IAAI,CAACnC,CAAD,CAAL,CAANhB,IAAmBK,KAAK,CAAC8C,IAAI,CAACnC,CAAD,CAAL,GAAW8jB,IAAI,GAAG3hB,IAAI,CAACnC,CAAC,EAAF,CAAX8jB;WACnCoB,YAAY,CAAC/iB,IAAI,CAACnC,CAAD,CAAL,GAAW6f,UAAU,GAAG1d,IAAI,CAACnC,CAAC,EAAF,CAAjB6f;CAF5B,WAGO;WACF7gB,MAAM,CAACmD,IAAI,CAACnC,CAAD,CAAL,GAAWoe,UAAU,GAAGjc,IAAI,CAACnC,CAAC,EAAF,CAAjBoe;;;SAElBpf,MAAM,CAACmD,IAAI,CAACnC,CAAD,CAAL,GAAW2e,UAAU,GAAGxc,IAAI,CAACnC,CAAC,EAAF,CAAjB2e;CACrBU,IAAAA,OAAO,GAAGld,IAAI,CAACnC,CAAC,EAAF,CAAdqf;CACAC,IAAAA,KAAK,GAAGnd,IAAI,CAACnC,CAAC,EAAF,CAAZsf;;;CAEDD,EAAAA,OAAO,GAAGA,OAAO,IAAI2F,cAArB3F;UACOwE,MAAM,GACVsB,QAAQ,CAAC/iB,IAAD,EAAOyhB,MAAP,EAAexE,OAAO,KAAKuF,YAAZvF,GAA2B,KAA3BA,GAAmCyE,IAAlD,EAAwDjE,UAAxD,EAAoElB,UAApE,EAAgFU,OAAhF,EAAyFC,KAAzF,CADE,GAEVyE,OAAO,GACPqB,QAAQ,CAAChjB,IAAD,EAAO2hB,OAAP,EAAgB3F,UAAhB,EAA4BO,UAA5B,EAAwCU,OAAxC,EAAiDC,KAAjD,CADD,GAEP;;;CAGJ,SAAS4F,YAAT,CAAsBnB,OAAtB,EAAwC;UAChC5kB,KAAK,CAAC4kB,OAAD,CAAL5kB,IAAkBD,KAAK,CAAC6kB,OAAD,CAAvB5kB,IAAoC0B,OAAO,CAACkjB,OAAD;;;CAEnD,SAASkB,cAAT,CAAwBlB,OAAxB,EAA0C;UAClCpjB,KAAK,CAACojB,OAAD,CAALpjB,IAAkBukB,YAAY,CAACnB,OAAD;;;CAGtC,SAASqB,QAAT,CACChjB,IADD,EAEC2hB,OAFD,EAGC3F,UAHD,EAICO,UAJD,EAKCU,OALD,EAMCC,KAND,EAOE;OACKzf,CAAC,GAAGV,KAAK,CAAC4kB,OAAD,CAAL5kB,IAAmB4kB,OAAD,CAAoB9jB,MAAnB8jB,GAA4B,CAA/C5kB,GAAmDulB,eAAnDvlB,GAAqEqkB;UACxE,IAAI3jB,CAAJ,CAAMuC,IAAN,EAAY2hB,OAAZ,EAAqB3F,UAArB,EAAiCO,UAAjC,EAA6CU,OAA7C,EAAsDC,KAAtD;;;CAGR,IAAM+F,eAAe,GAAG/a,OAAO,CAAC,kBAAD,EAAqB,CAArB,EAAwB,EAAxB,CAA/B;;CAEA,SAAS6a,QAAT,CACC/iB,IADD,EAEC2hB,OAFD,EAGCD,IAHD,EAICjE,UAJD,EAKClB,UALD,EAMCU,OAND,EAOCC,KAPD,EAQE;OACK1B,MAAM,GAAGmG,OAAO,CAACnG;;OACnB,CAACkG,MAAM;SACNnQ,CAAa,GAAG;;SAChBiK,MAAM,CAAC3d,MAAP2d,IAAiB,CAAjBA,IAAsBA,MAAM,KAAK,GAAjCA,IAAwCA,MAAM,KAAK,KAAK;CAC3DjK,MAAAA,CAAC,GAAGiK,MAAM,KAAK,GAAXA,GAAiB,EAAjBA,GAAsBA,MAA1BjK;CADD,WAEO,IAAIiK,MAAM,CAAC3d,MAAP2d,IAAiB,CAAjBA,IAAsBA,MAAM,CAAC,CAAD,CAANA,KAAc,IAApCA,IAA4CyH,eAAe,CAACzH,MAAM,CAAC,CAAD,CAAP,CAA/D,EAA4E;CAClFjK,MAAAA,CAAC,GAAGiK,MAAM,CAAC,CAAD,CAAVjK;;;SAEGA,CAAC,IAAI,GAAG,OAAOyR,QAAQ,CAAChjB,IAAD,EAAOuR,CAAP,EAAoBoQ,OAAO,CAAC3F,UAA5B,EAAwCO,UAAxC,EAAoDU,OAApD,EAA6DC,KAA7D,CAAf;;;UAEN,IAAIsE,YAAJ,CAAiBxhB,IAAjB,EAAuB2hB,OAAvB,EAAgCD,IAAhC,EAAsCjE,UAAtC,EAAkDlB,UAAlD,EAA8DU,OAA9D,EAAuEC,KAAvE;;;CAGR;;;CAGA;;;AAwCA,CAAO,SAASgG,GAAT,GAAyB;UACxBC,aAAa,CAAC5hB,SAAD,EAAYgf,OAAZ,EAAqB,CAAC,CAAD,EAAI,CAAJ,CAArB;;;AA0BrB,CAAO,SAAS6C,GAAT,GAAyB;UACxBD,aAAa,CAAC5hB,SAAD,EAAYgf,OAAZ,EAAqB,CAAC,CAAD,EAAI,CAAC,CAAL,CAArB;;;AAyBrB,CAAO,SAAS8C,IAAT,GAA0B;UACzBF,aAAa,CAAC5hB,SAAD,EAAYgf,OAAZ,EAAqB,CAAC,CAAD,EAAI,CAAC,CAAL,CAArB;;;AA8BrB,CAAO,SAAS+C,MAAT,GAA4B;UAC3BH,aAAa,CAAC5hB,SAAD,EAAYgf,OAAZ,EAAqB,CAAC,CAAD,EAAI,CAAJ,CAArB;;;CAIrB;;;CAGA;;AAwCA,CAAO,SAASgD,EAAT,GAAuB;UACtBJ,aAAa,CAAC5hB,SAAD,EAAYuf,MAAZ,EAAoB,CAAC,CAAD,EAAI,CAAJ,CAApB;;;AA8BrB,CAAO,SAAS0C,MAAT,GAA2B;UAC1BL,aAAa,CAAC5hB,SAAD,EAAYuf,MAAZ,EAAoB,CAAC,CAAD,EAAI,CAAC,CAAL,CAApB;;;AA8BrB,CAAO,SAAS2C,OAAT,GAA4B;UAC3BN,aAAa,CAAC5hB,SAAD,EAAYuf,MAAZ,EAAoB,CAAC,CAAD,EAAI,CAAC,CAAL,CAApB;;;AA8BrB,CAAO,SAAS4C,SAAT,GAA8B;UAC7BP,aAAa,CAAC5hB,SAAD,EAAYuf,MAAZ,EAAoB,CAAC,CAAD,EAAI,CAAJ,CAApB;;;CAIrB;;;CAGA;;CAUA,SAASqC,aAAT,CACCpjB,IADD,EAECgd,IAFD,EAGC4G,aAHD,EAIK;OACA3jB,MACHsf,SACAU,OACAX,QACA9C,YACAU,SACAC;;OACGzd,KAAK,CAACM,IAAI,CAAC,CAAD,CAAL,GAAW;SACbiE,MAAI,GAAGjE,IAAI,CAAC,CAAD;SAChB4G,CAAC,GAAG3C,MAAI,CAACgc;SACNvhB,OAAO,CAACkI,CAAD,CAAPlI,IAAczB,IAAI,CAAC2J,CAAD,GAAKqZ,KAAK,GAAGrZ,CAARqZ;CAC3BX,IAAAA,MAAM,GAAGrb,MAAI,CAACqb,MAAdA;CACArf,IAAAA,IAAI,GAAGgE,MAAI,CAAChE,IAAZA;CACAuc,IAAAA,UAAU,GAAGvY,MAAI,CAACuY,UAAlBA;CACAU,IAAAA,OAAO,GAAGjZ,MAAI,CAACiZ,OAAfA;CACAC,IAAAA,KAAK,GAAGlZ,MAAI,CAACkZ,KAAbA;CARD,SASO;SACFtf,CAAC,GAAG;SACJb,KAAK,CAACgD,IAAI,CAACnC,CAAD,CAAL,GAAWoC,IAAI,GAAGD,IAAI,CAACnC,CAAC,EAAF,CAAXoC;SAChBvB,OAAO,CAACsB,IAAI,CAACnC,CAAD,CAAL,CAAPa,IAAoBzB,IAAI,CAAC+C,IAAI,CAACnC,CAAD,CAAL,GAAWoiB,KAAK,GAAGjgB,IAAI,CAACnC,CAAC,EAAF,CAAZoiB;SACnCvhB,OAAO,CAACsB,IAAI,CAACnC,CAAD,CAAL,GAAWyhB,MAAM,GAAGtf,IAAI,CAACnC,CAAC,EAAF,CAAbyhB;SAClBziB,MAAM,CAACmD,IAAI,CAACnC,CAAD,CAAL,GAAW2e,UAAU,GAAGxc,IAAI,CAACnC,CAAC,EAAF,CAAjB2e;CACrBU,IAAAA,OAAO,GAAGld,IAAI,CAACnC,CAAC,EAAF,CAAdqf;CACAC,IAAAA,KAAK,GAAGnd,IAAI,CAACnC,CAAC,EAAF,CAAZsf;;;OAEG,CAACmC,QAAQA,MAAM,GAAGsE,aAATtE;;OACTW,OAAO;CACVV,IAAAA,OAAO,GAAGsE,YAAY,CAAC5D,KAAD,CAAtBV;YACO,IAAIvC,IAAJ,CAAS/c,IAAT,EAAeqf,MAAf,EAAuBC,OAAvB,EAAgC/C,UAAhC,EAA4CU,OAA5C,EAAqDC,KAArD;;;;CAIT,SAAS0G,YAAT,CAAsB5D,KAAtB,EAAsF;UAC9E,UAAS6D,KAAT,EAAgB;YACf1d,QAAQ,CAACnJ,IAAI,CAACgjB,KAAD,CAAJhjB,GAAegjB,KAAD,CAAmC6D,KAAnC,CAAd7mB,GAA0DgjB,KAA3D,EAAkE,UAACrZ,CAAD,EAAI/I,CAAJ,EAAU;WACtF,CAAC+I,GAAG,OAAOjB,IAAP;WACJ+W,IAAU,GAAG9V,CAAC,CAACqW,KAAFrW,GAAUA,CAAVA,GAAclI,OAAO,CAACkI,CAAD,CAAPlI,GAAakkB,OAAO,CAAChc,CAAD,CAApBlI,GAA0BkkB,OAAO,CAAC,CAAChc,CAAD,CAAD,EAAM6b,YAAN;CAChE1P,MAAAA,MAAM,CAACvV,EAAPuV,CAAU2J,IAAV3J,EAAgB,4DAAhBA,EAA8E+Q,KAA9E/Q,EAAqFlV,CAArFkV,EAAwFnM,CAAxFmM;cACO2J;CAJO,KAAA;CADhB;;;CCzmBD,IAAMqH,UAAU,GAAG,GAAnB;CAAA,IACCC,QAAQ,GAAG,GADZ;CAGA,IAAMC,cAAc,GAAG9b,OAAO,CAAC,OAAD,CAA9B;CAAA,IACC+b,YAAY,GAAG/b,OAAO,CAAC,UAAD,CADvB;CAGA,IAAMgc,cAAc,GAAGJ,UAAU,CAACjmB,MAAlC;CAAA,IACCsmB,YAAY,GAAGJ,QAAQ,CAAClmB,MADzB;CAGA,IAAMumB,cAAc,WAApB;CAEAlB,GAAG,CAAC,GAAD,EAAM;UAAM;CAAZ,CAAA,EAAgBV,YAAhB,CAAHU;CAEA,IAAMmB,SAAS,GAAG3b,KAAK,CAAC0b,cAAc,CAACjc,KAAfic,CAAqB,EAArBA,CAAD,EAA2B5B,YAA3B,CAAvB;CAAA,IACC8B,QAAQ,GAAG5b,KAAK,CAAC,2DAAD,QAAA,EAAsE,KAAtE,EAA6E8Z,YAA7E,CADjB;CAAA,IAEC+B,UAAU,GAAGrB,GAAG,CACf,YADe,EAEf;UAAM,CACL,GADK,EAELM,MAAM,CACL,SADK,EAEL,CACCc,QADD,EAECC,UAFD,EAGCC,SAHD,EAICH,SAJD;OAKK7lB,cAAY0D,QAAQ,CAACkiB,cAAc,GAAG,GAAlB,SALzB;CAAA,GAFK,EASL5B,YATK,CAFD,EAaL,GAbK;CAFS,CAAA,EAiBfA,YAjBe,CAFjB;CAAA,IAqBCgC,SAAS,GAAGtB,GAAG,CAAC,WAAD,EAAc;UAAM,CAClC,GADkC,EAElCM,MAAM,CACL,WADK,EAEL,CAACc,QAAD,EAAWC,UAAX,EAAuBC,SAAvB,EAAkCH,SAAlC,EAA6C,IAAI7lB,MAAJ,QAAgB0D,QAAQ,CAACkiB,cAAc,GAAG,GAAlB,QAAxB,CAA7C,CAFK,EAGL5B,YAHK,CAF4B,EAOlC,GAPkC;CAApB,CAAA,CArBhB;CAAA,IA8BCiC,IAAI,GAAGvB,GAAG,CACT,MADS,EAET,CACC,CAAC,WAAD,EAAcY,UAAd,EAA0BY,YAA1B,CADD,EAEClB,MAAM,CACL,UADK,EAEL,CACCc,QADD,EAECC,UAFD,EAGCC,SAHD,EAIC9b,KAAK,CAAC,CAAC0b,cAAc,GAAGN,UAAU,CAAC,CAAD,CAA5B,EAAiC3b,KAAjC,CAAuC,EAAvC,CAAD,EAA6Cqa,YAA7C,CAJN,EAKC,IAAIhkB,MAAJ,QAAgB0D,QAAQ,CAACkiB,cAAc,GAAGN,UAAU,CAAC,CAAD,CAA3BM,GAAiCL,QAAQ,CAAC,CAAD,CAA1C,QAAxB,CALD,CAFK,EASLvB,YATK,CAFP,EAaC,CAAC,SAAD,EAAYuB,QAAZ,EAAsBW,YAAtB,CAbD,CAFS,EAiBT,UAACze,IAAD,EAAYzG,GAAZ,EAAyBqgB,GAAzB,EAA+C;OACxC8E,aAAa,GAAG1e,IAAI,CAAC,CAAD;OACzB2e,QAAQ,GAAG3e,IAAI,CAAC,CAAD;CAChB4Z,EAAAA,GAAG,CAAChJ,GAAJgJ,CAAQ,CACPA,GAAG,CAACrE,MAAJqE,CAAWzE,IAAXyE,CAAgBrQ,SAAhBqQ,CAA0B8E,aAA1B9E,EAAyC+E,QAAQ,GAAGT,YAApDtE,CADO,EAEP8E,aAAa,GAAGT,cAFT,EAGPU,QAHO,CAAR/E;CApBQ,CAAA,CA9BX;;CA0DA,SAASgF,gBAAT,CAA0B7kB,IAA1B,EAAgC8kB,IAAhC,EAAsCC,KAAtC,EAA8C;UACtC7B,GAAG,CACTljB,IADS,EAET,CACC0I,KAAK,CAACoc,IAAD,EAAOJ,YAAP,CADN,EAEClB,MAAM,CAAC,CACNiB,IADM,EAENX,UAAU,CAAC,CAAD,CAFJ;OAGFtlB,sBAAmBumB,KAAK,GAAG,EAAH,GAAQ,SAAQD,OAAO5iB,QAAQ,CAAC4hB,UAAU,CAAC,CAAD,CAAX,gBAHrD;CAAA,GAAD,CAFP,EAOCpb,KAAK,CAACoc,IAAD,EAAOJ,YAAP,CAPN,CAFS,EAWT,UAACze,IAAD,EAAYzG,GAAZ,EAAyBqgB,GAAzB,EAA+C;SACxCzE,IAAI,GAAGyE,GAAG,CAACrE,MAAJqE,CAAWzE;SACpB7N,KAAK,GAAGtH,IAAI,CAAC,CAAD;SACfoc,GAAG,GAAGpc,IAAI,CAAC,CAAD,CAAJA,GAAU;SAChB+e,KAAK,GAAG/e,IAAI,CAAC,CAAD;;SACT+e,KAAK,CAACnnB,QAAQ;WACX2C,MAAM,GAAG+M,KAAK,GAAG;WACnB3P,CAAC,GAAG;WACPyH,CAAC,GAAG2f,KAAK,CAACnnB;WACVonB;WACKlR,IAAI,GAAG;;cAENnW,CAAC,GAAGyH,GAAGzH,CAAC,IAAI;CAClBqnB,QAAAA,MAAM,GAAGD,KAAK,CAACpnB,CAAD,CAALonB,CAAS,CAATA,CAATC;aACI1X,KAAK,GAAG0X,QAAQlR,IAAI,CAACmF,IAALnF,CAAUmR,OAAO,CAAC9J,IAAD,EAAO7N,KAAP,EAAc0X,MAAd,CAAjBlR;CACpBA,QAAAA,IAAI,CAACmF,IAALnF,OAAciR,KAAK,CAACpnB,CAAD,CAALonB,CAAS,CAATA,OAAdjR;CACAxG,QAAAA,KAAK,GAAGyX,KAAK,CAACpnB,CAAD,CAALonB,CAAS,CAATA,CAARzX;;;WAEGA,KAAK,GAAG8U,KAAKtO,IAAI,CAACmF,IAALnF,CAAUmR,OAAO,CAAC9J,IAAD,EAAO7N,KAAP,EAAc8U,GAAd,CAAjBtO;CAEjB8L,MAAAA,GAAG,CAAChJ,GAAJgJ,CAAQ,CAAC,MAAD,EAAS9L,IAAI,CAAC7T,IAAL6T,CAAU,KAAVA,CAAT,EAA2BvT,MAA3B,EAAmC6hB,GAAG,GAAG,CAAzC,CAARxC;CAfD,WAgBO;CACNA,MAAAA,GAAG,CAAChJ,GAAJgJ,CAAQ,CAAC,QAAD,EAAWzE,IAAI,CAAC5L,SAAL4L,CAAe7N,KAAf6N,EAAsBiH,GAAtBjH,CAAX,CAARyE;;CAjCO,GAAA;;YAsCDqF,QAAQ9J,MAAM7N,OAAO8U,KAAK;mBACvBjY,SAAS,CAACgR,IAAI,CAAC5L,SAAL4L,CAAe7N,KAAf6N,EAAsBiH,GAAtBjH,CAAD;;;;CAItB,IAAM+J,SAAS,GAAGzc,KAAK,CAAC,UAAD,EAAa,2BAAb,EAA0C,CAA1C,CAAvB;CAAA,IACC0c,SAAS,GAAG7B,EAAE,CACb,WADa,EAEb,CACCsB,gBAAgB,CAAC,UAAD,EAAa,GAAb,CADjB,EAECA,gBAAgB,CAAC,UAAD,EAAa,GAAb,CAFjB,EAGCA,gBAAgB,CAAC,SAAD,EAAY,GAAZ,EAAiB,IAAjB,CAHjB,EAIC3B,GAAG,CAAC,CAACuB,IAAD,CAAD,EAASY,WAAW,CAAC,MAAD,EAAS,UAAAtR,IAAA;UAAQA,IAAI,CAAC,CAAD,CAAJA,CAAQ,CAARA;CAAjB,CAAA,CAApB,CAJJ,EAKCrL,KAAK,CAAC,QAAD,EAAW,uCAAX,EAAoD,aAApD,EAAmE2c,WAAW,CAAC,QAAD,EAAW,UAAArV,GAAA;UAAO,CAACA;CAAnB,CAAA,CAA9E,CALN,EAMCtH,KAAK,CAAC,KAAD,EAAQ4c,iBAAiB,CAAC,QAAD,EAAWC,GAAX,CAAzB,CANN,EAOC7c,KAAK,CAAC,WAAD,EAAc4c,iBAAiB,CAAC,WAAD,EAAc5oB,SAAd,CAA/B,CAPN,EAQCgM,KAAK,CAAC,MAAD,EAAS4c,iBAAiB,CAAC,MAAD,EAAS5oB,SAAT,CAA1B,CARN,EASCgM,KAAK,CAAC,MAAD,EAAS4c,iBAAiB,CAAC,SAAD,EAAY,IAAZ,CAA1B,CATN,EAUC5c,KAAK,CAAC,OAAD,EAAU4c,iBAAiB,CAAC,SAAD,EAAY,KAAZ,CAA3B,CAVN,CAFa,EAcb,KAda,EAeb,UAACrf,IAAD,EAAYzG,GAAZ,EAAyBqgB,GAAzB;UAA+CA,GAAG,CAAChJ,GAAJgJ,CAAQ5Z,IAAI,CAAC,CAAD,CAAZ4Z;CAflC,CAAA,CADf;CAAA,IAkBC2F,KAAK,GAAGpC,GAAG,CACV,OADU,EAEV,CAAC+B,SAAD,EAAY7B,MAAM,CAAC,WAAD,EAAc,CAAC,CAAC,MAAD,EAAS,KAAT,EAAgB,GAAhB,EAAqBd,YAArB,CAAD,EAAqC4C,SAArC,EAAgD,KAAhD,CAAd,CAAlB,CAFU,EAGV,UAACnf,IAAD,EAAOpI,MAAP,EAAegiB,GAAf,EAAuB;OAChB4F,KAAK,GAAG;;QACT,IAAI7nB,CAAC,GAAG,CAAR,EAAWyH,CAAC,GAAGY,IAAI,CAACpI,QAAQD,CAAC,GAAGyH,GAAGzH,CAAC,IAAI;CAAG6nB,IAAAA,KAAK,CAACxf,IAAI,CAACrI,CAAD,CAAL,CAAL6nB,GAAiBxf,IAAI,CAACrI,CAAC,GAAG,CAAL,CAAJqI,CAAY,CAAZA,CAAjBwf;;;CAChD5F,EAAAA,GAAG,CAAChJ,GAAJgJ,CAAQ4F,KAAR5F;CANS,CAAA,CAlBZ;CA4BA,IAAM6F,aAAa,GAAG,kBAAtB;CAAA,IACCC,SAAS,GAAGjd,KAAK,CAAC,UAAD,EAAa,IAAIlK,MAAJ,QAAgBknB,uBAAhB,CAAb,EAAoD,CAApD,EAAuD,GAAvD,CADlB;CAAA,IAECE,cAAc,GAAGpC,MAAM,CAAC,gBAAD,EAAmB;UAAM,CAC/CqC,IAD+C,EAE/C3C,GAAG,CAAC,CAACuB,IAAD,CAAD,EAAS,UAACxe,IAAD,EAAYzG,GAAZ,EAAyBqgB,GAAzB,EAA+C;CAC1DA,IAAAA,GAAG,CAAChJ,GAAJgJ,CAAQ;CAAE1iB,MAAAA,IAAI,EAAE,MAAR;CAAgB8I,MAAAA,IAAI,EAAEA,IAAI,CAAC,CAAD,CAAJA,CAAQ,CAARA;CAAtB,KAAR4Z;CADE,GAAA,CAF4C,EAK/CnX,KAAK,CAAC,GAAD,EAAM,UAACzC,IAAD,EAAYzG,GAAZ,EAAyBqgB,GAAzB,EAA4CpD,IAA5C,EAA2D;;SAEjEoD,GAAG,CAAClC,QAAJkC,OAAmB;cAEfpD,IAAI,CAACU,KAALV,CAAW,iBAAXA,EAA8BoD,GAA9BpD;CACRqJ,IAAAA,UAAU,CAAC7f,IAAD,EAAOzG,GAAP,EAAYqgB,GAAZ,CAAViG,CALqE;CAAjE,GAAA,CAL0C,EAY/Cpd,KAAK,CAACob,UAAU,CAAC,CAAD,CAAX,EAAgBgC,UAAhB,CAZ0C;CAa/Cpd,EAAAA,KAAK,CAAC,IAAIlK,MAAJ,aAAqB0D,QAAQ,CAAC4hB,UAAU,CAAC,CAAD,CAAX,gBAAyB5hB,QAAQ,CAAC4hB,UAAU,CAAC,CAAD,CAAX,CAA9D,CAAD,EAAmFgC,UAAnF,CAb0C;CAAzB,CAAA,CAFxB;CAAA,IAiBCD,IAAI,GAAG3C,GAAG,CACT,MADS,EAET,CACCyC,SADD,EAECH,KAFD,EAGCjC,EAAE,CAAC,UAAD,EAAa,CACd7a,KAAK,CAAC,QAAD,EAAW,KAAX,EAAkB,GAAlB,EAAuB8Z,YAAvB,CADS,EAEdU,GAAG,CAAC,YAAD,EAAe,CACjBxa,KAAK,CAAC,GAAD,EAAM,KAAN,EAAa,GAAb,EAAkB8Z,YAAlB,CADY,EAEjBoD,cAFiB,EAGjBtC,MAAM,CAAC,CAAC5a,KAAK,CAAC,WAAD,EAAc,IAAIlK,MAAJ,SAAkBknB,wBAAlB,CAAd,EAAwD,CAAxD,EAA2D,GAA3D,CAAN,CAAD,EAAyE,UAACzf,IAAD,EAAOzG,GAAP,EAAYqgB,GAAZ,EAAoB;OAC5FkG,QAAQ,GAAG9f,IAAI,CAAC,CAAD;OACpB+f,IAAI,GAAGnG,GAAG,CAACxB,MAAJwB,CAAWxB;OAClB4H,GAAG,GAAGD,IAAI,CAAC/f,IAAL+f,CAAU,CAAVA;;OAEHD,UAAU;SACTA,QAAQ,KAAKE,KAAK;WACjBjC,cAAc,CAACiC,GAAD,GAAO;CACxBpG,QAAAA,GAAG,CAAClB,KAAJkB;CADD,aAEO;+BACcoG;;;CALvB,SAQO,IAAI,CAACjC,cAAc,CAACiC,GAAD,CAAnB,EAA0B;2BACZA;;CAdhB,CAAA,CAHW,CAAf,CAFW,CAAb,CAHH,CAFS,EA8BT,UAAChgB,IAAD,EAAYzG,GAAZ,EAAyBqgB,GAAzB,EAA+C;OACxCoG,GAAG,GAAGhgB,IAAI,CAAC,CAAD;OACfigB,QAAQ,GAAGjgB,IAAI,CAAC,CAAD,CAAJA,CAAQ,CAARA,KAAcA,IAAI,CAAC,CAAD,CAAJA,CAAQ,CAARA,EAAW,CAAXA;OACzBkgB,IAAI,GAAG;CAAEhpB,IAAAA,IAAI,EAAE,MAAR;CAAgB8oB,IAAAA,GAAG,EAAHA,GAAhB;CAAqBR,IAAAA,KAAK,EAAExf,IAAI,CAAC,CAAD,CAAhC;CAAqCigB,IAAAA,QAAQ,EAARA;CAArC;CAERrG,EAAAA,GAAG,CAAChJ,GAAJgJ,CAAQsG,IAARtG;;OAEIqG,QAAQ,IAAIlC,cAAc,CAACiC,GAAD,GAAO;CACpCpG,IAAAA,GAAG,CAACzI,MAAJyI,CAAWqG,QAAXrG;CACAqG,IAAAA,QAAQ,CAACroB,MAATqoB,GAAkB,CAAlBA;;CAvCO,CAAA,CAjBX;;CA6DA,SAASJ,UAAT,CAAoBM,IAApB,EAAkCvoB,MAAlC,EAAkDgiB,GAAlD,EAAqE;OAC9D5Z,IAAI,GAAG4Z,GAAG,CAAC5Z;OAChBzG,GAAG,GAAGyG,IAAI,CAACpI;OACR6Z;;OACAlY,GAAG,KAAKkY,IAAI,GAAGzR,IAAI,CAACzG,GAAG,GAAG,CAAP,CAAhB,CAAHA,IAAiCkY,IAAI,CAACva,IAALua,KAAc,QAAQ;CAC1DA,IAAAA,IAAI,CAACzR,IAALyR,IAAa0O,IAAb1O;CADD,SAEO;CACNmI,IAAAA,GAAG,CAAChJ,GAAJgJ,CAAQ;CAAE1iB,MAAAA,IAAI,EAAE,MAAR;CAAgB8I,MAAAA,IAAI,EAAEmgB;CAAtB,KAARvG;;;;AAIF,KAAawG,WAAW,GAAGnD,GAAG,CAC7B,cAD6B,EAE7B,CAAC,KAAD,EAAQG,IAAI,CAAC,CAACwC,IAAD,CAAD,CAAZ,EAAsBnd,KAAK,CAAC,KAAD,EAAQ,MAAR,EAAgB8Z,YAAhB,CAA3B,CAF6B,EAG7B,UAACvc,IAAD,EAAYzG,GAAZ,EAAyBqgB,GAAzB,EAA+C;CAC9CA,EAAAA,GAAG,CAACzI,MAAJyI,CAAW5Z,IAAI,CAAC,CAAD,CAAf4Z;CAJ4B,CAAA,CAAvB;CAQPwG,WAAW,CAACtG,IAAZsG;;CAGA,SAAShB,WAAT,CAAqBloB,IAArB,EAA2BmpB,UAA3B,EAAuC;UAC/B,UAASrgB,IAAT,EAAoBzG,GAApB,EAAiCqgB,GAAjC,EAAoD;CAC1DA,IAAAA,GAAG,CAAChJ,GAAJgJ,CAAQ,CAAC1iB,IAAD,EAAOmpB,UAAU,CAACrgB,IAAD,CAAjB,CAAR4Z;CADD;;;CAKD,SAASyF,iBAAT,CAA2BnoB,IAA3B,EAAsC;UAC9BkoB,WAAW,CAACloB,IAAD,EAAO,UAAA0I,CAAA;YAAKA;CAAZ,GAAA;;;CAGnB,SAAS6e,YAAT,CAAsBze,IAAtB,EAAiCzG,GAAjC,EAA8CqgB,GAA9C,EAAiE;CAChEA,EAAAA,GAAG,CAAChJ,GAAJgJ,CAAQA,GAAG,CAACb,OAAJa,EAARA;;;CCpPD;;;;;;;;;CCAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}